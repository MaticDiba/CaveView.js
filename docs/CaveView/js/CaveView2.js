!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).CV2={})}(this,(function(t){"use strict";const e="2.3.0-test",n=600,i=10,r=11,s=13,a=11,o=12,l=13,h=15,c=18,u=19;class d{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e<i;e++)n[e].call(this,t);t.target=null}}}const p=0,f=1,m=2,g=100,v=301,x=302,y=306,_=1e3,M=1001,b=1002,w=1003,S=1006,E=1008,T=1009,L=1012,C=1014,A=1015,R=1016,P=1020,D=1022,I=1023,N=1026,z=1027,F=3e3,O=3001,U=3007,B=3002,k=7680,H=7682,G=35044,V="300 es",W=[];for(let t=0;t<256;t++)W[t]=(t<16?"0":"")+t.toString(16);const j=Math.PI/180,X=180/Math.PI;function q(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(W[255&t]+W[t>>8&255]+W[t>>16&255]+W[t>>24&255]+"-"+W[255&e]+W[e>>8&255]+"-"+W[e>>16&15|64]+W[e>>24&255]+"-"+W[63&n|128]+W[n>>8&255]+"-"+W[n>>16&255]+W[n>>24&255]+W[255&i]+W[i>>8&255]+W[i>>16&255]+W[i>>24&255]).toUpperCase()}function Y(t,e,n){return Math.max(e,Math.min(n,t))}function Z(t,e,n){return(1-n)*t+n*e}function J(t){return t*X}function Q(t){return 0==(t&t-1)&&0!==t}function K(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}class ${constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}$.prototype.isVector2=!0;class tt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,a,o,l){const h=this.elements;return h[0]=t,h[1]=i,h[2]=a,h[3]=e,h[4]=r,h[5]=o,h[6]=n,h[7]=s,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],h=n[4],c=n[7],u=n[2],d=n[5],p=n[8],f=i[0],m=i[3],g=i[6],v=i[1],x=i[4],y=i[7],_=i[2],M=i[5],b=i[8];return r[0]=s*f+a*v+o*_,r[3]=s*m+a*x+o*M,r[6]=s*g+a*y+o*b,r[1]=l*f+h*v+c*_,r[4]=l*m+h*x+c*M,r[7]=l*g+h*y+c*b,r[2]=u*f+d*v+p*_,r[5]=u*m+d*x+p*M,r[8]=u*g+d*y+p*b,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8];return e*s*h-e*a*l-n*r*h+n*a*o+i*r*l-i*s*o}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8],c=h*s-a*l,u=a*o-h*r,d=l*r-s*o,p=e*c+n*u+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=c*f,t[1]=(i*l-h*n)*f,t[2]=(a*n-i*s)*f,t[3]=u*f,t[4]=(h*e-i*o)*f,t[5]=(i*r-a*e)*f,t[6]=d*f,t[7]=(n*o-l*e)*f,t[8]=(s*e-n*r)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,a){const o=Math.cos(r),l=Math.sin(r);return this.set(n*o,n*l,-n*(o*s+l*a)+s+t,-i*l,i*o,-i*(-l*s+o*a)+a+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,r=i[0],s=i[3],a=i[6],o=i[1],l=i[4],h=i[7];return i[0]=e*r+n*o,i[3]=e*s+n*l,i[6]=e*a+n*h,i[1]=-n*r+e*o,i[4]=-n*s+e*l,i[7]=-n*a+e*h,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}let et;tt.prototype.isMatrix3=!0;let nt=0;class it extends d{constructor(t=it.DEFAULT_IMAGE,e=it.DEFAULT_MAPPING,n=1001,i=1001,r=1006,s=1008,a=1023,o=1009,l=1,h=3e3){super(),Object.defineProperty(this,"id",{value:nt++}),this.uuid=q(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new $(0,0),this.repeat=new $(1,1),this.center=new $(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new tt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const i=this.image;if(void 0===i.uuid&&(i.uuid=q()),!e&&void 0===t.images[i.uuid]){let e;if(Array.isArray(i)){e=[];for(let t=0,n=i.length;t<n;t++)i[t].isDataTexture?e.push(rt(i[t].image)):e.push(rt(i[t]))}else e=rt(i);t.images[i.uuid]={uuid:i.uuid,url:e}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case _:t.x=t.x-Math.floor(t.x);break;case M:t.x=t.x<0?0:1;break;case b:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case _:t.y=t.y-Math.floor(t.y);break;case M:t.y=t.y<0?0:1;break;case b:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&this.version++}}function rt(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?class{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===et&&(et=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),et.width=t.width,et.height=t.height;const n=et.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=et}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}it.DEFAULT_IMAGE=void 0,it.DEFAULT_MAPPING=300,it.prototype.isTexture=!0;class st{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,a=.1,o=t.elements,l=o[0],h=o[4],c=o[8],u=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(h-u)<s&&Math.abs(c-f)<s&&Math.abs(p-m)<s){if(Math.abs(h+u)<a&&Math.abs(c+f)<a&&Math.abs(p+m)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,v=(g+1)/2,x=(h+u)/4,y=(c+f)/4,_=(p+m)/4;return t>o&&t>v?t<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=x/n,r=y/n):o>v?o<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(o),n=x/i,r=_/i):v<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(v),n=y/r,i=_/r),this.set(n,i,r,e),this}let v=Math.sqrt((m-p)*(m-p)+(c-f)*(c-f)+(u-h)*(u-h));return Math.abs(v)<.001&&(v=1),this.x=(m-p)/v,this.y=(c-f)/v,this.z=(u-h)/v,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}st.prototype.isVector4=!0;class at extends d{constructor(t,e,n={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new st(0,0,t,e),this.scissorTest=!1,this.viewport=new st(0,0,t,e),this.texture=new it(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:S,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}at.prototype.isWebGLRenderTarget=!0;class ot{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,r,s,a){let o=n[i+0],l=n[i+1],h=n[i+2],c=n[i+3];const u=r[s+0],d=r[s+1],p=r[s+2],f=r[s+3];if(0===a)return t[e+0]=o,t[e+1]=l,t[e+2]=h,void(t[e+3]=c);if(1===a)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(c!==f||o!==u||l!==d||h!==p){let t=1-a;const e=o*u+l*d+h*p+c*f,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,a=Math.sin(a*s)/r}const r=a*n;if(o=o*t+u*r,l=l*t+d*r,h=h*t+p*r,c=c*t+f*r,t===1-a){const t=1/Math.sqrt(o*o+l*l+h*h+c*c);o*=t,l*=t,h*=t,c*=t}}t[e]=o,t[e+1]=l,t[e+2]=h,t[e+3]=c}static multiplyQuaternionsFlat(t,e,n,i,r,s){const a=n[i],o=n[i+1],l=n[i+2],h=n[i+3],c=r[s],u=r[s+1],d=r[s+2],p=r[s+3];return t[e]=a*p+h*c+o*d-l*u,t[e+1]=o*p+h*u+l*c-a*d,t[e+2]=l*p+h*d+a*u-o*c,t[e+3]=h*p-a*c-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,r=t._z,s=t._order,a=Math.cos,o=Math.sin,l=a(n/2),h=a(i/2),c=a(r/2),u=o(n/2),d=o(i/2),p=o(r/2);switch(s){case"XYZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"YXZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"ZXY":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"ZYX":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"YZX":this._x=u*h*c+l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c-u*d*p;break;case"XZY":this._x=u*h*c-l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],a=e[5],o=e[9],l=e[2],h=e[6],c=e[10],u=n+a+c;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(h-o)*t,this._y=(r-l)*t,this._z=(s-i)*t}else if(n>a&&n>c){const t=2*Math.sqrt(1+n-a-c);this._w=(h-o)/t,this._x=.25*t,this._y=(i+s)/t,this._z=(r+l)/t}else if(a>c){const t=2*Math.sqrt(1+a-n-c);this._w=(r-l)/t,this._x=(i+s)/t,this._y=.25*t,this._z=(o+h)/t}else{const t=2*Math.sqrt(1+c-n-a);this._w=(s-i)/t,this._x=(r+l)/t,this._y=(o+h)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Y(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,a=e._x,o=e._y,l=e._z,h=e._w;return this._x=n*h+s*a+i*l-r*o,this._y=i*h+s*o+r*a-n*l,this._z=r*h+s*l+n*o-i*a,this._w=s*h-n*a-i*o-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let a=s*t._w+n*t._x+i*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),h=Math.atan2(l,a),c=Math.sin((1-e)*h)/l,u=Math.sin(e*h)/l;return this._w=s*c+this._w*u,this._x=n*c+this._x*u,this._y=i*c+this._y*u,this._z=r*c+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}ot.prototype.isQuaternion=!0;class lt{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(ct.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(ct.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,a=t.z,o=t.w,l=o*e+s*i-a*n,h=o*n+a*e-r*i,c=o*i+r*n-s*e,u=-r*e-s*n-a*i;return this.x=l*o+u*-r+h*-a-c*-s,this.y=h*o+u*-s+c*-r-l*-a,this.z=c*o+u*-a+l*-s-h*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,a=e.y,o=e.z;return this.x=i*o-r*a,this.y=r*s-n*o,this.z=n*a-i*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return ht.copy(this).projectOnVector(t),this.sub(ht)}reflect(t){return this.sub(ht.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Y(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}lt.prototype.isVector3=!0;const ht=new lt,ct=new ot;class ut{constructor(t=new lt(1/0,1/0,1/0),e=new lt(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.length;o<l;o+=3){const l=t[o],h=t[o+1],c=t[o+2];l<e&&(e=l),h<n&&(n=h),c<i&&(i=c),l>r&&(r=l),h>s&&(s=h),c>a&&(a=c)}return this.min.set(e,n,i),this.max.set(r,s,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.count;o<l;o++){const l=t.getX(o),h=t.getY(o),c=t.getZ(o);l<e&&(e=l),h<n&&(n=h),c<i&&(i=c),l>r&&(r=l),h>s&&(s=h),c>a&&(a=c)}return this.min.set(e,n,i),this.max.set(r,s,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=pt.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),ft.copy(e.boundingBox),ft.applyMatrix4(t.matrixWorld),this.union(ft));const n=t.children;for(let t=0,e=n.length;t<e;t++)this.expandByObject(n[t]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,pt),pt.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Mt),bt.subVectors(this.max,Mt),mt.subVectors(t.a,Mt),gt.subVectors(t.b,Mt),vt.subVectors(t.c,Mt),xt.subVectors(gt,mt),yt.subVectors(vt,gt),_t.subVectors(mt,vt);let e=[0,-xt.z,xt.y,0,-yt.z,yt.y,0,-_t.z,_t.y,xt.z,0,-xt.x,yt.z,0,-yt.x,_t.z,0,-_t.x,-xt.y,xt.x,0,-yt.y,yt.x,0,-_t.y,_t.x,0];return!!Et(e,mt,gt,vt,bt)&&(e=[1,0,0,0,1,0,0,0,1],!!Et(e,mt,gt,vt,bt)&&(wt.crossVectors(xt,yt),e=[wt.x,wt.y,wt.z],Et(e,mt,gt,vt,bt)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return pt.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(pt).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(dt[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),dt[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),dt[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),dt[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),dt[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),dt[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),dt[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),dt[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(dt)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}ut.prototype.isBox3=!0;const dt=[new lt,new lt,new lt,new lt,new lt,new lt,new lt,new lt],pt=new lt,ft=new ut,mt=new lt,gt=new lt,vt=new lt,xt=new lt,yt=new lt,_t=new lt,Mt=new lt,bt=new lt,wt=new lt,St=new lt;function Et(t,e,n,i,r){for(let s=0,a=t.length-3;s<=a;s+=3){St.fromArray(t,s);const a=r.x*Math.abs(St.x)+r.y*Math.abs(St.y)+r.z*Math.abs(St.z),o=e.dot(St),l=n.dot(St),h=i.dot(St);if(Math.max(-Math.max(o,l,h),Math.min(o,l,h))>a)return!1}return!0}const Tt=new ut,Lt=new lt,Ct=new lt,At=new lt;class Rt{constructor(t=new lt,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Tt.setFromPoints(t).getCenter(n);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){At.subVectors(t,this.center);const e=At.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.add(At.multiplyScalar(n/t)),this.radius+=n}return this}union(t){return Ct.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Lt.copy(t.center).add(Ct)),this.expandByPoint(Lt.copy(t.center).sub(Ct)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Pt=new lt,Dt=new lt,It=new tt;class Nt{constructor(t=new lt(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=Pt.subVectors(n,e).cross(Dt.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(Pt),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||It.getNormalMatrix(t),i=this.coplanarPoint(Pt).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}Nt.prototype.isPlane=!0;const zt=new Rt,Ft=new lt;class Ot{constructor(t=new Nt,e=new Nt,n=new Nt,i=new Nt,r=new Nt,s=new Nt){this.planes=[t,e,n,i,r,s]}set(t,e,n,i,r,s){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(i),a[4].copy(r),a[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],s=n[2],a=n[3],o=n[4],l=n[5],h=n[6],c=n[7],u=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],v=n[14],x=n[15];return e[0].setComponents(a-i,c-o,f-u,x-m).normalize(),e[1].setComponents(a+i,c+o,f+u,x+m).normalize(),e[2].setComponents(a+r,c+l,f+d,x+g).normalize(),e[3].setComponents(a-r,c-l,f-d,x-g).normalize(),e[4].setComponents(a-s,c-h,f-p,x-v).normalize(),e[5].setComponents(a+s,c+h,f+p,x+v).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),zt.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(zt)}intersectsSprite(t){return zt.center.set(0,0,0),zt.radius=.7071067811865476,zt.applyMatrix4(t.matrixWorld),this.intersectsSphere(zt)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let t=0;t<6;t++){if(e[t].distanceToPoint(n)<i)return!1}return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Ft.x=i.normal.x>0?t.max.x:t.min.x,Ft.y=i.normal.y>0?t.max.y:t.min.y,Ft.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Ft)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}class Ut{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,a,o,l,h,c,u,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=h,g[10]=c,g[14]=u,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Ut).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/Bt.setFromMatrixColumn(t,0).length(),r=1/Bt.setFromMatrixColumn(t,1).length(),s=1/Bt.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),a=Math.sin(n),o=Math.cos(i),l=Math.sin(i),h=Math.cos(r),c=Math.sin(r);if("XYZ"===t.order){const t=s*h,n=s*c,i=a*h,r=a*c;e[0]=o*h,e[4]=-o*c,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-a*o,e[2]=r-t*l,e[6]=i+n*l,e[10]=s*o}else if("YXZ"===t.order){const t=o*h,n=o*c,i=l*h,r=l*c;e[0]=t+r*a,e[4]=i*a-n,e[8]=s*l,e[1]=s*c,e[5]=s*h,e[9]=-a,e[2]=n*a-i,e[6]=r+t*a,e[10]=s*o}else if("ZXY"===t.order){const t=o*h,n=o*c,i=l*h,r=l*c;e[0]=t-r*a,e[4]=-s*c,e[8]=i+n*a,e[1]=n+i*a,e[5]=s*h,e[9]=r-t*a,e[2]=-s*l,e[6]=a,e[10]=s*o}else if("ZYX"===t.order){const t=s*h,n=s*c,i=a*h,r=a*c;e[0]=o*h,e[4]=i*l-n,e[8]=t*l+r,e[1]=o*c,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=a*o,e[10]=s*o}else if("YZX"===t.order){const t=s*o,n=s*l,i=a*o,r=a*l;e[0]=o*h,e[4]=r-t*c,e[8]=i*c+n,e[1]=c,e[5]=s*h,e[9]=-a*h,e[2]=-l*h,e[6]=n*c+i,e[10]=t-r*c}else if("XZY"===t.order){const t=s*o,n=s*l,i=a*o,r=a*l;e[0]=o*h,e[4]=-c,e[8]=l*h,e[1]=t*c+r,e[5]=s*h,e[9]=n*c-i,e[2]=i*c-n,e[6]=a*h,e[10]=r*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Ht,t,Gt)}lookAt(t,e,n){const i=this.elements;return jt.subVectors(t,e),0===jt.lengthSq()&&(jt.z=1),jt.normalize(),Vt.crossVectors(n,jt),0===Vt.lengthSq()&&(1===Math.abs(n.z)?jt.x+=1e-4:jt.z+=1e-4,jt.normalize(),Vt.crossVectors(n,jt)),Vt.normalize(),Wt.crossVectors(jt,Vt),i[0]=Vt.x,i[4]=Wt.x,i[8]=jt.x,i[1]=Vt.y,i[5]=Wt.y,i[9]=jt.y,i[2]=Vt.z,i[6]=Wt.z,i[10]=jt.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[4],o=n[8],l=n[12],h=n[1],c=n[5],u=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],v=n[3],x=n[7],y=n[11],_=n[15],M=i[0],b=i[4],w=i[8],S=i[12],E=i[1],T=i[5],L=i[9],C=i[13],A=i[2],R=i[6],P=i[10],D=i[14],I=i[3],N=i[7],z=i[11],F=i[15];return r[0]=s*M+a*E+o*A+l*I,r[4]=s*b+a*T+o*R+l*N,r[8]=s*w+a*L+o*P+l*z,r[12]=s*S+a*C+o*D+l*F,r[1]=h*M+c*E+u*A+d*I,r[5]=h*b+c*T+u*R+d*N,r[9]=h*w+c*L+u*P+d*z,r[13]=h*S+c*C+u*D+d*F,r[2]=p*M+f*E+m*A+g*I,r[6]=p*b+f*T+m*R+g*N,r[10]=p*w+f*L+m*P+g*z,r[14]=p*S+f*C+m*D+g*F,r[3]=v*M+x*E+y*A+_*I,r[7]=v*b+x*T+y*R+_*N,r[11]=v*w+x*L+y*P+_*z,r[15]=v*S+x*C+y*D+_*F,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],a=t[5],o=t[9],l=t[13],h=t[2],c=t[6],u=t[10],d=t[14];return t[3]*(+r*o*c-i*l*c-r*a*u+n*l*u+i*a*d-n*o*d)+t[7]*(+e*o*d-e*l*u+r*s*u-i*s*d+i*l*h-r*o*h)+t[11]*(+e*l*c-e*a*d-r*s*c+n*s*d+r*a*h-n*l*h)+t[15]*(-i*a*h-e*o*c+e*a*u+i*s*c-n*s*u+n*o*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8],c=t[9],u=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],v=c*m*l-f*u*l+f*o*d-a*m*d-c*o*g+a*u*g,x=p*u*l-h*m*l-p*o*d+s*m*d+h*o*g-s*u*g,y=h*f*l-p*c*l+p*a*d-s*f*d-h*a*g+s*c*g,_=p*c*o-h*f*o-p*a*u+s*f*u+h*a*m-s*c*m,M=e*v+n*x+i*y+r*_;if(0===M)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/M;return t[0]=v*b,t[1]=(f*u*r-c*m*r-f*i*d+n*m*d+c*i*g-n*u*g)*b,t[2]=(a*m*r-f*o*r+f*i*l-n*m*l-a*i*g+n*o*g)*b,t[3]=(c*o*r-a*u*r-c*i*l+n*u*l+a*i*d-n*o*d)*b,t[4]=x*b,t[5]=(h*m*r-p*u*r+p*i*d-e*m*d-h*i*g+e*u*g)*b,t[6]=(p*o*r-s*m*r-p*i*l+e*m*l+s*i*g-e*o*g)*b,t[7]=(s*u*r-h*o*r+h*i*l-e*u*l-s*i*d+e*o*d)*b,t[8]=y*b,t[9]=(p*c*r-h*f*r-p*n*d+e*f*d+h*n*g-e*c*g)*b,t[10]=(s*f*r-p*a*r+p*n*l-e*f*l-s*n*g+e*a*g)*b,t[11]=(h*a*r-s*c*r-h*n*l+e*c*l+s*n*d-e*a*d)*b,t[12]=_*b,t[13]=(h*f*i-p*c*i+p*n*u-e*f*u-h*n*m+e*c*m)*b,t[14]=(p*a*i-s*f*i-p*n*o+e*f*o+s*n*m-e*a*m)*b,t[15]=(s*c*i-h*a*i+h*n*o-e*c*o-s*n*u+e*a*u)*b,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,a=t.y,o=t.z,l=r*s,h=r*a;return this.set(l*s+n,l*a-i*o,l*o+i*a,0,l*a+i*o,h*a+n,h*o-i*s,0,l*o-i*a,h*o+i*s,r*o*o+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,s){return this.set(1,n,r,0,t,1,s,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,a=e._z,o=e._w,l=r+r,h=s+s,c=a+a,u=r*l,d=r*h,p=r*c,f=s*h,m=s*c,g=a*c,v=o*l,x=o*h,y=o*c,_=n.x,M=n.y,b=n.z;return i[0]=(1-(f+g))*_,i[1]=(d+y)*_,i[2]=(p-x)*_,i[3]=0,i[4]=(d-y)*M,i[5]=(1-(u+g))*M,i[6]=(m+v)*M,i[7]=0,i[8]=(p+x)*b,i[9]=(m-v)*b,i[10]=(1-(u+f))*b,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=Bt.set(i[0],i[1],i[2]).length();const s=Bt.set(i[4],i[5],i[6]).length(),a=Bt.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],kt.copy(this);const o=1/r,l=1/s,h=1/a;return kt.elements[0]*=o,kt.elements[1]*=o,kt.elements[2]*=o,kt.elements[4]*=l,kt.elements[5]*=l,kt.elements[6]*=l,kt.elements[8]*=h,kt.elements[9]*=h,kt.elements[10]*=h,e.setFromRotationMatrix(kt),n.x=r,n.y=s,n.z=a,this}makePerspective(t,e,n,i,r,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,o=2*r/(e-t),l=2*r/(n-i),h=(e+t)/(e-t),c=(n+i)/(n-i),u=-(s+r)/(s-r),d=-2*s*r/(s-r);return a[0]=o,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=l,a[9]=c,a[13]=0,a[2]=0,a[6]=0,a[10]=u,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,i,r,s){const a=this.elements,o=1/(e-t),l=1/(n-i),h=1/(s-r),c=(e+t)*o,u=(n+i)*l,d=(s+r)*h;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-c,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-u,a[2]=0,a[6]=0,a[10]=-2*h,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}Ut.prototype.isMatrix4=!0;const Bt=new lt,kt=new Ut,Ht=new lt(0,0,0),Gt=new lt(1,1,1),Vt=new lt,Wt=new lt,jt=new lt;function Xt(){let t=null,e=!1,n=null,i=null;function r(e,s){n(e,s),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function qt(t,e){const n=e.isWebGL2,i=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),i.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=i.get(e);n&&(t.deleteBuffer(n.buffer),i.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){const t=i.get(e);return void((!t||t.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=i.get(e);void 0===s?i.set(e,function(e,i){const r=e.array,s=e.usage,a=t.createBuffer();t.bindBuffer(i,a),t.bufferData(i,r,s),e.onUploadCallback();let o=t.FLOAT;return r instanceof Float32Array?o=t.FLOAT:r instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):r instanceof Uint16Array?e.isFloat16BufferAttribute?n?o=t.HALF_FLOAT:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):o=t.UNSIGNED_SHORT:r instanceof Int16Array?o=t.SHORT:r instanceof Uint32Array?o=t.UNSIGNED_INT:r instanceof Int32Array?o=t.INT:r instanceof Int8Array?o=t.BYTE:(r instanceof Uint8Array||r instanceof Uint8ClampedArray)&&(o=t.UNSIGNED_BYTE),{buffer:a,type:o,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version}}(e,r)):s.version<e.version&&(!function(e,i,r){const s=i.array,a=i.updateRange;t.bindBuffer(r,e),-1===a.count?t.bufferSubData(r,0,s):(n?t.bufferSubData(r,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):t.bufferSubData(r,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,e,r),s.version=e.version)}}}const Yt={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Zt={h:0,s:0,l:0},Jt={h:0,s:0,l:0};function Qt(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function Kt(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function $t(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class te{constructor(t,e,n){return void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){var i;if(t=(t%(i=1)+i)%i,e=Y(e,0,1),n=Y(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=Qt(r,i,t+1/3),this.g=Qt(r,i,t),this.b=Qt(r,i,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const i=n[1],r=n[2];switch(i){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){const n=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,r=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(n,i,r)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Yt[t.toLowerCase()];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Kt(t.r),this.g=Kt(t.g),this.b=Kt(t.b),this}copyLinearToSRGB(t){return this.r=$t(t.r),this.g=$t(t.g),this.b=$t(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,i=this.b,r=Math.max(e,n,i),s=Math.min(e,n,i);let a,o;const l=(s+r)/2;if(s===r)a=0,o=0;else{const t=r-s;switch(o=l<=.5?t/(r+s):t/(2-r-s),r){case e:a=(n-i)/t+(n<i?6:0);break;case n:a=(i-e)/t+2;break;case i:a=(e-n)/t+4}a/=6}return t.h=a,t.s=o,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL(Zt),Zt.h+=t,Zt.s+=e,Zt.l+=n,this.setHSL(Zt.h,Zt.s,Zt.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Zt),t.getHSL(Jt);const n=Z(Zt.h,Jt.h,e),i=Z(Zt.s,Jt.s,e),r=Z(Zt.l,Jt.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}te.NAMES=Yt,te.prototype.isColor=!0,te.prototype.r=1,te.prototype.g=1,te.prototype.b=1;const ee=new lt,ne=new $;class ie{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=G,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),r=new te),e[n++]=r.r,e[n++]=r.g,e[n++]=r.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),r=new $),e[n++]=r.x,e[n++]=r.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),r=new lt),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),r=new st),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z,e[n++]=r.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)ne.fromBufferAttribute(this,e),ne.applyMatrix3(t),this.setXY(e,ne.x,ne.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)ee.fromBufferAttribute(this,e),ee.applyMatrix3(t),this.setXYZ(e,ee.x,ee.y,ee.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)ee.x=this.getX(e),ee.y=this.getY(e),ee.z=this.getZ(e),ee.applyMatrix4(t),this.setXYZ(e,ee.x,ee.y,ee.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)ee.x=this.getX(e),ee.y=this.getY(e),ee.z=this.getZ(e),ee.applyNormalMatrix(t),this.setXYZ(e,ee.x,ee.y,ee.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)ee.x=this.getX(e),ee.y=this.getY(e),ee.z=this.getZ(e),ee.transformDirection(t),this.setXYZ(e,ee.x,ee.y,ee.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==G&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}ie.prototype.isBufferAttribute=!0;class re extends ie{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class se extends ie{constructor(t,e,n){super(new Uint32Array(t),e,n)}}(class extends ie{constructor(t,e,n){super(new Uint16Array(t),e,n)}}).prototype.isFloat16BufferAttribute=!0;class ae extends ie{constructor(t,e,n){super(new Float32Array(t),e,n)}}const oe=new Ut,le=new ot;class he{constructor(t=0,e=0,n=0,i=he.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],s=i[4],a=i[8],o=i[1],l=i[5],h=i[9],c=i[2],u=i[6],d=i[10];switch(e){case"XYZ":this._y=Math.asin(Y(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,d),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Y(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-c,r),this._z=0);break;case"ZXY":this._x=Math.asin(Y(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-c,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,r));break;case"ZYX":this._y=Math.asin(-Y(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,r)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(Y(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-c,r)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-Y(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-h,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return oe.makeRotationFromQuaternion(t),this.setFromRotationMatrix(oe,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return le.setFromEuler(this),this.setFromQuaternion(le,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new lt(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}he.prototype.isEuler=!0,he.DefaultOrder="XYZ",he.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class ce{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}let ue=0;const de=new lt,pe=new ot,fe=new Ut,me=new lt,ge=new lt,ve=new lt,xe=new ot,ye=new lt(1,0,0),_e=new lt(0,1,0),Me=new lt(0,0,1),be={type:"added"},we={type:"removed"};class Se extends d{constructor(){super(),Object.defineProperty(this,"id",{value:ue++}),this.uuid=q(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Se.DefaultUp.clone();const t=new lt,e=new he,n=new ot,i=new lt(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Ut},normalMatrix:{value:new tt}}),this.matrix=new Ut,this.matrixWorld=new Ut,this.matrixAutoUpdate=Se.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new ce,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return pe.setFromAxisAngle(t,e),this.quaternion.multiply(pe),this}rotateOnWorldAxis(t,e){return pe.setFromAxisAngle(t,e),this.quaternion.premultiply(pe),this}rotateX(t){return this.rotateOnAxis(ye,t)}rotateY(t){return this.rotateOnAxis(_e,t)}rotateZ(t){return this.rotateOnAxis(Me,t)}translateOnAxis(t,e){return de.copy(t).applyQuaternion(this.quaternion),this.position.add(de.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ye,t)}translateY(t){return this.translateOnAxis(_e,t)}translateZ(t){return this.translateOnAxis(Me,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(fe.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?me.copy(t):me.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),ge.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?fe.lookAt(ge,me,this.up):fe.lookAt(me,ge,this.up),this.quaternion.setFromRotationMatrix(fe),i&&(fe.extractRotation(i.matrixWorld),pe.setFromRotationMatrix(fe),this.quaternion.premultiply(pe.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(be)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(we)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(we)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),fe.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),fe.multiply(t.parent.matrixWorld)),t.applyMatrix4(fe),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ge,t,ve),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ge,xe,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const i=n[e];r(t.shapes,i)}else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];i.animations.push(r(t.animations,n))}}if(e){const e=s(t.geometries),i=s(t.materials),r=s(t.textures),a=s(t.images),o=s(t.shapes),l=s(t.skeletons),h=s(t.animations);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),a.length>0&&(n.images=a),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),h.length>0&&(n.animations=h)}return n.object=i,n;function s(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}function Ee(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,i=t.length;n<i;++n)t[n]>e&&(e=t[n]);return e}Se.DefaultUp=new lt(0,1,0),Se.DefaultMatrixAutoUpdate=!0,Se.prototype.isObject3D=!0;let Te=0;const Le=new Ut,Ce=new Se,Ae=new lt,Re=new ut,Pe=new ut,De=new lt;class Ie extends d{constructor(){super(),Object.defineProperty(this,"id",{value:Te++}),this.uuid=q(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Ee(t)>65535?se:re)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new tt).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Le.makeRotationFromQuaternion(t),this.applyMatrix4(Le),this}rotateX(t){return Le.makeRotationX(t),this.applyMatrix4(Le),this}rotateY(t){return Le.makeRotationY(t),this.applyMatrix4(Le),this}rotateZ(t){return Le.makeRotationZ(t),this.applyMatrix4(Le),this}translate(t,e,n){return Le.makeTranslation(t,e,n),this.applyMatrix4(Le),this}scale(t,e,n){return Le.makeScale(t,e,n),this.applyMatrix4(Le),this}lookAt(t){return Ce.lookAt(t),Ce.updateMatrix(),this.applyMatrix4(Ce.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ae).negate(),this.translate(Ae.x,Ae.y,Ae.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new ae(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new ut);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new lt(-1/0,-1/0,-1/0),new lt(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Re.setFromBufferAttribute(n),this.morphTargetsRelative?(De.addVectors(this.boundingBox.min,Re.min),this.boundingBox.expandByPoint(De),De.addVectors(this.boundingBox.max,Re.max),this.boundingBox.expandByPoint(De)):(this.boundingBox.expandByPoint(Re.min),this.boundingBox.expandByPoint(Re.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Rt);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new lt,1/0);if(t){const n=this.boundingSphere.center;if(Re.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Pe.setFromBufferAttribute(n),this.morphTargetsRelative?(De.addVectors(Re.min,Pe.min),Re.expandByPoint(De),De.addVectors(Re.max,Pe.max),Re.expandByPoint(De)):(Re.expandByPoint(Pe.min),Re.expandByPoint(Pe.max))}Re.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)De.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(De));if(e)for(let r=0,s=e.length;r<s;r++){const s=e[r],a=this.morphTargetsRelative;for(let e=0,r=s.count;e<r;e++)De.fromBufferAttribute(s,e),a&&(Ae.fromBufferAttribute(t,e),De.add(Ae)),i=Math.max(i,n.distanceToSquared(De))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,r=e.normal.array,s=e.uv.array,a=i.length/3;void 0===e.tangent&&this.setAttribute("tangent",new ie(new Float32Array(4*a),4));const o=e.tangent.array,l=[],h=[];for(let t=0;t<a;t++)l[t]=new lt,h[t]=new lt;const c=new lt,u=new lt,d=new lt,p=new $,f=new $,m=new $,g=new lt,v=new lt;function x(t,e,n){c.fromArray(i,3*t),u.fromArray(i,3*e),d.fromArray(i,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),u.sub(c),d.sub(c),f.sub(p),m.sub(p);const r=1/(f.x*m.y-m.x*f.y);isFinite(r)&&(g.copy(u).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(r),v.copy(d).multiplyScalar(f.x).addScaledVector(u,-m.x).multiplyScalar(r),l[t].add(g),l[e].add(g),l[n].add(g),h[t].add(v),h[e].add(v),h[n].add(v))}let y=this.groups;0===y.length&&(y=[{start:0,count:n.length}]);for(let t=0,e=y.length;t<e;++t){const e=y[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)x(n[t+0],n[t+1],n[t+2])}const _=new lt,M=new lt,b=new lt,w=new lt;function S(t){b.fromArray(r,3*t),w.copy(b);const e=l[t];_.copy(e),_.sub(b.multiplyScalar(b.dot(e))).normalize(),M.crossVectors(w,e);const n=M.dot(h[t])<0?-1:1;o[4*t]=_.x,o[4*t+1]=_.y,o[4*t+2]=_.z,o[4*t+3]=n}for(let t=0,e=y.length;t<e;++t){const e=y[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)S(n[t+0]),S(n[t+1]),S(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new ie(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new lt,r=new lt,s=new lt,a=new lt,o=new lt,l=new lt,h=new lt,c=new lt;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),f=t.getX(u+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),h.subVectors(s,r),c.subVectors(i,r),h.cross(c),a.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),a.add(h),o.add(h),l.add(h),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,a=e.count;t<a;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),h.subVectors(s,r),c.subVectors(i,r),h.cross(c),n.setXYZ(t+0,h.x,h.y,h.z),n.setXYZ(t+1,h.x,h.y,h.z),n.setXYZ(t+2,h.x,h.y,h.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(void 0===t.attributes[i])continue;const r=n[i].array,s=t.attributes[i],a=s.array,o=s.itemSize*e,l=Math.min(a.length,r.length-o);for(let t=0,e=o;t<l;t++,e++)r[e]=a[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)De.fromBufferAttribute(t,e),De.normalize(),t.setXYZ(e,De.x,De.y,De.z)}toNonIndexed(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,s=new n.constructor(e.length*i);let a=0,o=0;for(let r=0,l=e.length;r<l;r++){a=t.isInterleavedBufferAttribute?e[r]*t.data.stride+t.offset:e[r]*i;for(let t=0;t<i;t++)s[o++]=n[a++]}return new ie(s,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ie,n=this.index.array,i=this.attributes;for(const r in i){const s=t(i[r],n);e.setAttribute(r,s)}const r=this.morphAttributes;for(const i in r){const s=[],a=r[i];for(let e=0,i=a.length;e<i;e++){const i=t(a[e],n);s.push(i)}e.morphAttributes[i]=s}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,n=s.length;t<n;t++){const n=s[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const i=n[e];t.data.attributes[e]=i.toJSON(t.data)}const i={};let r=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],s=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];s.push(i.toJSON(t.data))}s.length>0&&(i[e]=s,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new Ie).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const i=t.attributes;for(const t in i){const n=i[t];this.setAttribute(t,n.clone(e))}const r=t.morphAttributes;for(const t in r){const n=[],i=r[t];for(let t=0,r=i.length;t<r;t++)n.push(i[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}Ie.prototype.isBufferGeometry=!0;class Ne extends Ie{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const a=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const o=[],l=[],h=[],c=[];let u=0,d=0;function p(t,e,n,i,r,s,p,f,m,g,v){const x=s/m,y=p/g,_=s/2,M=p/2,b=f/2,w=m+1,S=g+1;let E=0,T=0;const L=new lt;for(let s=0;s<S;s++){const a=s*y-M;for(let o=0;o<w;o++){const u=o*x-_;L[t]=u*i,L[e]=a*r,L[n]=b,l.push(L.x,L.y,L.z),L[t]=0,L[e]=0,L[n]=f>0?1:-1,h.push(L.x,L.y,L.z),c.push(o/m),c.push(1-s/g),E+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=u+e+w*t,i=u+e+w*(t+1),r=u+(e+1)+w*(t+1),s=u+(e+1)+w*t;o.push(n,i,s),o.push(i,r,s),T+=6}a.addGroup(d,T,v),d+=T,u+=E}p("z","y","x",-1,-1,n,e,t,s,r,0),p("z","y","x",1,-1,n,e,-t,s,r,1),p("x","z","y",1,1,t,n,e,i,s,2),p("x","z","y",1,-1,t,n,-e,i,s,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(o),this.setAttribute("position",new ae(l,3)),this.setAttribute("normal",new ae(h,3)),this.setAttribute("uv",new ae(c,2))}static fromJSON(t){return new Ne(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}class ze extends Ie{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,a=Math.floor(n),o=Math.floor(i),l=a+1,h=o+1,c=t/a,u=e/o,d=[],p=[],f=[],m=[];for(let t=0;t<h;t++){const e=t*u-s;for(let n=0;n<l;n++){const i=n*c-r;p.push(i,-e,0),f.push(0,0,1),m.push(n/a),m.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<a;e++){const n=e+l*t,i=e+l*(t+1),r=e+1+l*(t+1),s=e+1+l*t;d.push(n,i,s),d.push(i,r,s)}this.setIndex(d),this.setAttribute("position",new ae(p,3)),this.setAttribute("normal",new ae(f,3)),this.setAttribute("uv",new ae(m,2))}static fromJSON(t){return new ze(t.width,t.height,t.widthSegments,t.heightSegments)}}let Fe=0;class Oe extends d{constructor(){super(),Object.defineProperty(this,"id",{value:Fe++}),this.uuid=q(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.format=I,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=g,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=k,this.stencilZFail=k,this.stencilZPass=k,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheenTint&&this.sheenTint.isColor&&(n.sheenTint=this.sheenTint.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(n.specularTint=this.specularTint.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(n.specularTintMap=this.specularTintMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationTint&&(n.attenuationTint=this.attenuationTint.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==I&&(n.format=this.format),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}function Ue(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[n][i]=r.clone():Array.isArray(r)?e[n][i]=r.slice():e[n][i]=r}}return e}function Be(t){const e={};for(let n=0;n<t.length;n++){const i=Ue(t[n]);for(const t in i)e[t]=i[t]}return e}Oe.prototype.isMaterial=!0;const ke={clone:Ue,merge:Be};class He extends Oe{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Ue(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}He.prototype.isShaderMaterial=!0;const Ge=new lt,Ve=new lt,We=new lt,je=new lt,Xe=new lt,qe=new lt,Ye=new lt;class Ze{constructor(t=new lt,e=new lt(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Ge)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Ge.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Ge.copy(this.direction).multiplyScalar(e).add(this.origin),Ge.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){Ve.copy(t).add(e).multiplyScalar(.5),We.copy(e).sub(t).normalize(),je.copy(this.origin).sub(Ve);const r=.5*t.distanceTo(e),s=-this.direction.dot(We),a=je.dot(this.direction),o=-je.dot(We),l=je.lengthSq(),h=Math.abs(1-s*s);let c,u,d,p;if(h>0)if(c=s*o-a,u=s*a-o,p=r*h,c>=0)if(u>=-p)if(u<=p){const t=1/h;c*=t,u*=t,d=c*(c+s*u+2*a)+u*(s*c+u+2*o)+l}else u=r,c=Math.max(0,-(s*u+a)),d=-c*c+u*(u+2*o)+l;else u=-r,c=Math.max(0,-(s*u+a)),d=-c*c+u*(u+2*o)+l;else u<=-p?(c=Math.max(0,-(-s*r+a)),u=c>0?-r:Math.min(Math.max(-r,-o),r),d=-c*c+u*(u+2*o)+l):u<=p?(c=0,u=Math.min(Math.max(-r,-o),r),d=u*(u+2*o)+l):(c=Math.max(0,-(s*r+a)),u=c>0?r:Math.min(Math.max(-r,-o),r),d=-c*c+u*(u+2*o)+l);else u=s>0?-r:r,c=Math.max(0,-(s*u+a)),d=-c*c+u*(u+2*o)+l;return n&&n.copy(this.direction).multiplyScalar(c).add(this.origin),i&&i.copy(We).multiplyScalar(u).add(Ve),d}intersectSphere(t,e){Ge.subVectors(t.center,this.origin);const n=Ge.dot(this.direction),i=Ge.dot(Ge)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),a=n-s,o=n+s;return a<0&&o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,a,o;const l=1/this.direction.x,h=1/this.direction.y,c=1/this.direction.z,u=this.origin;return l>=0?(n=(t.min.x-u.x)*l,i=(t.max.x-u.x)*l):(n=(t.max.x-u.x)*l,i=(t.min.x-u.x)*l),h>=0?(r=(t.min.y-u.y)*h,s=(t.max.y-u.y)*h):(r=(t.max.y-u.y)*h,s=(t.min.y-u.y)*h),n>s||r>i?null:((r>n||n!=n)&&(n=r),(s<i||i!=i)&&(i=s),c>=0?(a=(t.min.z-u.z)*c,o=(t.max.z-u.z)*c):(a=(t.max.z-u.z)*c,o=(t.min.z-u.z)*c),n>o||a>i?null:((a>n||n!=n)&&(n=a),(o<i||i!=i)&&(i=o),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,Ge)}intersectTriangle(t,e,n,i,r){Xe.subVectors(e,t),qe.subVectors(n,t),Ye.crossVectors(Xe,qe);let s,a=this.direction.dot(Ye);if(a>0){if(i)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}je.subVectors(this.origin,t);const o=s*this.direction.dot(qe.crossVectors(je,qe));if(o<0)return null;const l=s*this.direction.dot(Xe.cross(je));if(l<0)return null;if(o+l>a)return null;const h=-s*je.dot(Ye);return h<0?null:this.at(h/a,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}const Je=new lt,Qe=new lt,Ke=new lt,$e=new lt,tn=new lt,en=new lt,nn=new lt,rn=new lt,sn=new lt,an=new lt;class on{constructor(t=new lt,e=new lt,n=new lt){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),Je.subVectors(t,e),i.cross(Je);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){Je.subVectors(i,e),Qe.subVectors(n,e),Ke.subVectors(t,e);const s=Je.dot(Je),a=Je.dot(Qe),o=Je.dot(Ke),l=Qe.dot(Qe),h=Qe.dot(Ke),c=s*l-a*a;if(0===c)return r.set(-2,-1,-1);const u=1/c,d=(l*o-a*h)*u,p=(s*h-a*o)*u;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,$e),$e.x>=0&&$e.y>=0&&$e.x+$e.y<=1}static getUV(t,e,n,i,r,s,a,o){return this.getBarycoord(t,e,n,i,$e),o.set(0,0),o.addScaledVector(r,$e.x),o.addScaledVector(s,$e.y),o.addScaledVector(a,$e.z),o}static isFrontFacing(t,e,n,i){return Je.subVectors(n,e),Qe.subVectors(t,e),Je.cross(Qe).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Je.subVectors(this.c,this.b),Qe.subVectors(this.a,this.b),.5*Je.cross(Qe).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return on.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return on.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return on.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return on.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return on.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let s,a;tn.subVectors(i,n),en.subVectors(r,n),rn.subVectors(t,n);const o=tn.dot(rn),l=en.dot(rn);if(o<=0&&l<=0)return e.copy(n);sn.subVectors(t,i);const h=tn.dot(sn),c=en.dot(sn);if(h>=0&&c<=h)return e.copy(i);const u=o*c-h*l;if(u<=0&&o>=0&&h<=0)return s=o/(o-h),e.copy(n).addScaledVector(tn,s);an.subVectors(t,r);const d=tn.dot(an),p=en.dot(an);if(p>=0&&d<=p)return e.copy(r);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0)return a=l/(l-p),e.copy(n).addScaledVector(en,a);const m=h*p-d*c;if(m<=0&&c-h>=0&&d-p>=0)return nn.subVectors(r,i),a=(c-h)/(c-h+(d-p)),e.copy(i).addScaledVector(nn,a);const g=1/(m+f+u);return s=f*g,a=u*g,e.copy(n).addScaledVector(tn,s).addScaledVector(en,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}class ln extends Oe{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new te(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}ln.prototype.isMeshBasicMaterial=!0;const hn=new Ut,cn=new Ze,un=new Rt,dn=new lt,pn=new lt,fn=new lt,mn=new lt,gn=new lt,vn=new lt,xn=new lt,yn=new lt,_n=new lt,Mn=new $,bn=new $,wn=new $,Sn=new lt,En=new lt;class Tn extends Se{constructor(t=new Ie,e=new ln){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0===i)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),un.copy(n.boundingSphere),un.applyMatrix4(r),!1===t.ray.intersectsSphere(un))return;if(hn.copy(r).invert(),cn.copy(t.ray).applyMatrix4(hn),null!==n.boundingBox&&!1===cn.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const r=n.index,a=n.attributes.position,o=n.morphAttributes.position,l=n.morphTargetsRelative,h=n.attributes.uv,c=n.attributes.uv2,u=n.groups,d=n.drawRange;if(null!==r)if(Array.isArray(i))for(let n=0,p=u.length;n<p;n++){const p=u[n],f=i[p.materialIndex];for(let n=Math.max(p.start,d.start),i=Math.min(p.start+p.count,d.start+d.count);n<i;n+=3){const i=r.getX(n),u=r.getX(n+1),d=r.getX(n+2);s=Ln(this,f,t,cn,a,o,l,h,c,i,u,d),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=p.materialIndex,e.push(s))}}else{for(let n=Math.max(0,d.start),u=Math.min(r.count,d.start+d.count);n<u;n+=3){const u=r.getX(n),d=r.getX(n+1),p=r.getX(n+2);s=Ln(this,i,t,cn,a,o,l,h,c,u,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}else if(void 0!==a)if(Array.isArray(i))for(let n=0,r=u.length;n<r;n++){const r=u[n],p=i[r.materialIndex];for(let n=Math.max(r.start,d.start),i=Math.min(r.start+r.count,d.start+d.count);n<i;n+=3){s=Ln(this,p,t,cn,a,o,l,h,c,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=r.materialIndex,e.push(s))}}else{for(let n=Math.max(0,d.start),r=Math.min(a.count,d.start+d.count);n<r;n+=3){s=Ln(this,i,t,cn,a,o,l,h,c,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function Ln(t,e,n,i,r,s,a,o,l,h,c,u){dn.fromBufferAttribute(r,h),pn.fromBufferAttribute(r,c),fn.fromBufferAttribute(r,u);const d=t.morphTargetInfluences;if(s&&d){xn.set(0,0,0),yn.set(0,0,0),_n.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(mn.fromBufferAttribute(n,h),gn.fromBufferAttribute(n,c),vn.fromBufferAttribute(n,u),a?(xn.addScaledVector(mn,e),yn.addScaledVector(gn,e),_n.addScaledVector(vn,e)):(xn.addScaledVector(mn.sub(dn),e),yn.addScaledVector(gn.sub(pn),e),_n.addScaledVector(vn.sub(fn),e)))}dn.add(xn),pn.add(yn),fn.add(_n)}t.isSkinnedMesh&&(t.boneTransform(h,dn),t.boneTransform(c,pn),t.boneTransform(u,fn));const p=function(t,e,n,i,r,s,a,o){let l;if(l=1===e.side?i.intersectTriangle(a,s,r,!0,o):i.intersectTriangle(r,s,a,2!==e.side,o),null===l)return null;En.copy(o),En.applyMatrix4(t.matrixWorld);const h=n.ray.origin.distanceTo(En);return h<n.near||h>n.far?null:{distance:h,point:En.clone(),object:t}}(t,e,n,i,dn,pn,fn,Sn);if(p){o&&(Mn.fromBufferAttribute(o,h),bn.fromBufferAttribute(o,c),wn.fromBufferAttribute(o,u),p.uv=on.getUV(Sn,dn,pn,fn,Mn,bn,wn,new $)),l&&(Mn.fromBufferAttribute(l,h),bn.fromBufferAttribute(l,c),wn.fromBufferAttribute(l,u),p.uv2=on.getUV(Sn,dn,pn,fn,Mn,bn,wn,new $));const t={a:h,b:c,c:u,normal:new lt,materialIndex:0};on.getNormal(dn,pn,fn,t.normal),p.face=t}return p}Tn.prototype.isMesh=!0;const Cn={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float NoH ) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float NoV, float NoL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n}\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in GeometricContext geometry ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = transmission.a;\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},An={common:{diffuse:{value:new te(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new tt},uv2Transform:{value:new tt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new $(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new te(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new te(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new tt}},sprite:{diffuse:{value:new te(16777215)},opacity:{value:1},center:{value:new $(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new tt}}},Rn={basic:{uniforms:Be([An.common,An.specularmap,An.envmap,An.aomap,An.lightmap,An.fog]),vertexShader:Cn.meshbasic_vert,fragmentShader:Cn.meshbasic_frag},lambert:{uniforms:Be([An.common,An.specularmap,An.envmap,An.aomap,An.lightmap,An.emissivemap,An.fog,An.lights,{emissive:{value:new te(0)}}]),vertexShader:Cn.meshlambert_vert,fragmentShader:Cn.meshlambert_frag},phong:{uniforms:Be([An.common,An.specularmap,An.envmap,An.aomap,An.lightmap,An.emissivemap,An.bumpmap,An.normalmap,An.displacementmap,An.fog,An.lights,{emissive:{value:new te(0)},specular:{value:new te(1118481)},shininess:{value:30}}]),vertexShader:Cn.meshphong_vert,fragmentShader:Cn.meshphong_frag},standard:{uniforms:Be([An.common,An.envmap,An.aomap,An.lightmap,An.emissivemap,An.bumpmap,An.normalmap,An.displacementmap,An.roughnessmap,An.metalnessmap,An.fog,An.lights,{emissive:{value:new te(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Cn.meshphysical_vert,fragmentShader:Cn.meshphysical_frag},toon:{uniforms:Be([An.common,An.aomap,An.lightmap,An.emissivemap,An.bumpmap,An.normalmap,An.displacementmap,An.gradientmap,An.fog,An.lights,{emissive:{value:new te(0)}}]),vertexShader:Cn.meshtoon_vert,fragmentShader:Cn.meshtoon_frag},matcap:{uniforms:Be([An.common,An.bumpmap,An.normalmap,An.displacementmap,An.fog,{matcap:{value:null}}]),vertexShader:Cn.meshmatcap_vert,fragmentShader:Cn.meshmatcap_frag},points:{uniforms:Be([An.points,An.fog]),vertexShader:Cn.points_vert,fragmentShader:Cn.points_frag},dashed:{uniforms:Be([An.common,An.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Cn.linedashed_vert,fragmentShader:Cn.linedashed_frag},depth:{uniforms:Be([An.common,An.displacementmap]),vertexShader:Cn.depth_vert,fragmentShader:Cn.depth_frag},normal:{uniforms:Be([An.common,An.bumpmap,An.normalmap,An.displacementmap,{opacity:{value:1}}]),vertexShader:Cn.meshnormal_vert,fragmentShader:Cn.meshnormal_frag},sprite:{uniforms:Be([An.sprite,An.fog]),vertexShader:Cn.sprite_vert,fragmentShader:Cn.sprite_frag},background:{uniforms:{uvTransform:{value:new tt},t2D:{value:null}},vertexShader:Cn.background_vert,fragmentShader:Cn.background_frag},cube:{uniforms:Be([An.envmap,{opacity:{value:1}}]),vertexShader:Cn.cube_vert,fragmentShader:Cn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Cn.equirect_vert,fragmentShader:Cn.equirect_frag},distanceRGBA:{uniforms:Be([An.common,An.displacementmap,{referencePosition:{value:new lt},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Cn.distanceRGBA_vert,fragmentShader:Cn.distanceRGBA_frag},shadow:{uniforms:Be([An.lights,An.fog,{color:{value:new te(0)},opacity:{value:1}}]),vertexShader:Cn.shadow_vert,fragmentShader:Cn.shadow_frag}};function Pn(t,e,n,i,r){const s=new te(0);let a,o,l=0,h=null,c=0,u=null;function d(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,r)}return{getClearColor:function(){return s},setClearColor:function(t,e=1){s.set(t),l=e,d(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(t){l=t,d(s,l)},render:function(n,r){let p=!1,f=!0===r.isScene?r.background:null;f&&f.isTexture&&(f=e.get(f));const m=t.xr,g=m.getSession&&m.getSession();g&&"additive"===g.environmentBlendMode&&(f=null),null===f?d(s,l):f&&f.isColor&&(d(f,1),p=!0),(t.autoClear||p)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),f&&(f.isCubeTexture||f.mapping===y)?(void 0===o&&(o=new Tn(new Ne(1,1,1),new He({name:"BackgroundCubeMaterial",uniforms:Ue(Rn.cube.uniforms),vertexShader:Rn.cube.vertexShader,fragmentShader:Rn.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),o.geometry.deleteAttribute("uv"),o.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(o.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(o)),o.material.uniforms.envMap.value=f,o.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,h===f&&c===f.version&&u===t.toneMapping||(o.material.needsUpdate=!0,h=f,c=f.version,u=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null)):f&&f.isTexture&&(void 0===a&&(a=new Tn(new ze(2,2),new He({name:"BackgroundMaterial",uniforms:Ue(Rn.background.uniforms),vertexShader:Rn.background.vertexShader,fragmentShader:Rn.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),a.material.uniforms.uvTransform.value.copy(f.matrix),h===f&&c===f.version&&u===t.toneMapping||(a.material.needsUpdate=!0,h=f,c=f.version,u=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null))}}}function Dn(t,e,n,i){const r=t.getParameter(t.MAX_VERTEX_ATTRIBS),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),a=i.isWebGL2||null!==s,o={},l=d(null);let h=l;function c(e){return i.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function u(e){return i.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],i=[];for(let t=0;t<r;t++)e[t]=0,n[t]=0,i[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function p(){const t=h.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){m(t,0)}function m(n,r){const s=h.newAttributes,a=h.enabledAttributes,o=h.attributeDivisors;if(s[n]=1,0===a[n]&&(t.enableVertexAttribArray(n),a[n]=1),o[n]!==r){(i.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,r),o[n]=r}}function g(){const e=h.newAttributes,n=h.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function v(e,n,r,s,a,o){!0!==i.isWebGL2||r!==t.INT&&r!==t.UNSIGNED_INT?t.vertexAttribPointer(e,n,r,s,a,o):t.vertexAttribIPointer(e,n,r,a,o)}function x(){y(),h!==l&&(h=l,c(h.object))}function y(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,u,x,y){let _=!1;if(a){const e=function(e,n,r){const a=!0===r.wireframe;let l=o[e.id];void 0===l&&(l={},o[e.id]=l);let h=l[n.id];void 0===h&&(h={},l[n.id]=h);let c=h[a];void 0===c&&(c=d(i.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),h[a]=c);return c}(x,u,l);h!==e&&(h=e,c(h.object)),_=function(t,e){const n=h.attributes,i=t.attributes;let r=0;for(const t in i){const e=n[t],s=i[t];if(void 0===e)return!0;if(e.attribute!==s)return!0;if(e.data!==s.data)return!0;r++}return h.attributesNum!==r||h.index!==e}(x,y),_&&function(t,e){const n={},i=t.attributes;let r=0;for(const t in i){const e=i[t],s={};s.attribute=e,e.data&&(s.data=e.data),n[t]=s,r++}h.attributes=n,h.attributesNum=r,h.index=e}(x,y)}else{const t=!0===l.wireframe;h.geometry===x.id&&h.program===u.id&&h.wireframe===t||(h.geometry=x.id,h.program=u.id,h.wireframe=t,_=!0)}!0===r.isInstancedMesh&&(_=!0),null!==y&&n.update(y,t.ELEMENT_ARRAY_BUFFER),_&&(!function(r,s,a,o){if(!1===i.isWebGL2&&(r.isInstancedMesh||o.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();const l=o.attributes,h=a.getAttributes(),c=s.defaultAttributeValues;for(const e in h){const i=h[e];if(i.location>=0){let s=l[e];if(void 0===s&&("instanceMatrix"===e&&r.instanceMatrix&&(s=r.instanceMatrix),"instanceColor"===e&&r.instanceColor&&(s=r.instanceColor)),void 0!==s){const e=s.normalized,a=s.itemSize,l=n.get(s);if(void 0===l)continue;const h=l.buffer,c=l.type,u=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,l=n.stride,d=s.offset;if(n&&n.isInstancedInterleavedBuffer){for(let t=0;t<i.locationSize;t++)m(i.location+t,n.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let t=0;t<i.locationSize;t++)f(i.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<i.locationSize;t++)v(i.location+t,a/i.locationSize,c,e,l*u,(d+a/i.locationSize*t)*u)}else{if(s.isInstancedBufferAttribute){for(let t=0;t<i.locationSize;t++)m(i.location+t,s.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let t=0;t<i.locationSize;t++)f(i.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<i.locationSize;t++)v(i.location+t,a/i.locationSize,c,e,a*u,a/i.locationSize*t*u)}}else if(void 0!==c){const n=c[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(i.location,n);break;case 3:t.vertexAttrib3fv(i.location,n);break;case 4:t.vertexAttrib4fv(i.location,n);break;default:t.vertexAttrib1fv(i.location,n)}}}}g()}(r,l,u,x),null!==y&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n.get(y).buffer))},reset:x,resetDefaultState:y,dispose:function(){x();for(const t in o){const e=o[t];for(const t in e){const n=e[t];for(const t in n)u(n[t].object),delete n[t];delete e[t]}delete o[t]}},releaseStatesOfGeometry:function(t){if(void 0===o[t.id])return;const e=o[t.id];for(const t in e){const n=e[t];for(const t in n)u(n[t].object),delete n[t];delete e[t]}delete o[t.id]},releaseStatesOfProgram:function(t){for(const e in o){const n=o[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)u(i[t].object),delete i[t];delete n[t.id]}},initAttributes:p,enableAttribute:f,disableUnusedAttributes:g}}function In(t,e,n,i){const r=i.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,i){t.drawArrays(s,e,i),n.update(i,s,1)},this.renderInstances=function(i,a,o){if(0===o)return;let l,h;if(r)l=t,h="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),h="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[h](s,i,a,o),n.update(a,s,o)}}function Nn(t,e,n){let i;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const o=r(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=s||e.has("WEBGL_draw_buffers"),h=!0===n.logarithmicDepthBuffer,c=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),u=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),d=t.getParameter(t.MAX_TEXTURE_SIZE),p=t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),f=t.getParameter(t.MAX_VERTEX_ATTRIBS),m=t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),g=t.getParameter(t.MAX_VARYING_VECTORS),v=t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),x=u>0,y=s||e.has("OES_texture_float");return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");i=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:r,precision:a,logarithmicDepthBuffer:h,maxTextures:c,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:v,vertexTextures:x,floatFragmentTextures:y,floatVertexTextures:x&&y,maxSamples:s?t.getParameter(t.MAX_SAMPLES):0}}function zn(t){const e=this;let n=null,i=0,r=!1,s=!1;const a=new Nt,o=new tt,l={value:null,needsUpdate:!1};function h(){l.value!==n&&(l.value=n,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function c(t,n,i,r){const s=null!==t?t.length:0;let h=null;if(0!==s){if(h=l.value,!0!==r||null===h){const e=i+4*s,r=n.matrixWorldInverse;o.getNormalMatrix(r),(null===h||h.length<e)&&(h=new Float32Array(e));for(let e=0,n=i;e!==s;++e,n+=4)a.copy(t[e]).applyMatrix4(r,o),a.normal.toArray(h,n),h[n+3]=a.constant}l.value=h,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,h}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const a=0!==t.length||e||0!==i||r;return r=e,n=c(t,s,0),i=t.length,a},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1,h()},this.setState=function(e,a,o){const u=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!r||null===u||0===u.length||s&&!p)s?c(null):h();else{const t=s?0:i,e=4*t;let r=f.clippingState||null;l.value=r,r=c(u,a,e,o);for(let t=0;t!==e;++t)r[t]=n[t];f.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}Rn.physical={uniforms:Be([Rn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new $(1,1)},clearcoatNormalMap:{value:null},sheenTint:{value:new te(0)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new $},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new te(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new te(1,1,1)},specularTintMap:{value:null}}]),vertexShader:Cn.meshphysical_vert,fragmentShader:Cn.meshphysical_frag};class Fn extends Se{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Ut,this.projectionMatrix=new Ut,this.projectionMatrixInverse=new Ut}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}Fn.prototype.isCamera=!0;class On extends Fn{constructor(t=50,e=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*X*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*j*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*X*Math.atan(Math.tan(.5*j*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*j*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,a=s.fullHeight;r+=s.offsetX*i/t,e-=s.offsetY*n/a,i*=s.width/t,n*=s.height/a}const a=this.filmOffset;0!==a&&(r+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}On.prototype.isPerspectiveCamera=!0;const Un=90;class Bn extends Se{constructor(t,e,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new On(Un,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new lt(1,0,0)),this.add(i);const r=new On(Un,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new lt(-1,0,0)),this.add(r);const s=new On(Un,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new lt(0,1,0)),this.add(s);const a=new On(Un,1,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new lt(0,-1,0)),this.add(a);const o=new On(Un,1,t,e);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new lt(0,0,1)),this.add(o);const l=new On(Un,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new lt(0,0,-1)),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,s,a,o,l]=this.children,h=t.xr.enabled,c=t.getRenderTarget();t.xr.enabled=!1;const u=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,o),n.texture.generateMipmaps=u,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(c),t.xr.enabled=h}}class kn extends it{constructor(t,e,n,i,r,s,a,o,l,h){super(t=void 0!==t?t:[],e=void 0!==e?e:v,n,i,r,s,a=void 0!==a?a:D,o,l,h),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}kn.prototype.isCubeTexture=!0;class Hn extends at{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new kn(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:S,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=I,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},i=new Ne(5,5,5),r=new He({name:"CubemapFromEquirect",uniforms:Ue(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:1,blending:0});r.uniforms.tEquirect.value=e;const s=new Tn(i,r),a=e.minFilter;e.minFilter===E&&(e.minFilter=S);return new Bn(1,10,this).update(t,s),e.minFilter=a,s.geometry.dispose(),s.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,n,i);t.setRenderTarget(r)}}function Gn(t){let e=new WeakMap;function n(t,e){return 303===e?t.mapping=v:304===e&&(t.mapping=x),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){const s=r.mapping;if(303===s||304===s){if(e.has(r)){return n(e.get(r).texture,r.mapping)}{const s=r.image;if(s&&s.height>0){const a=t.getRenderTarget(),o=new Hn(s.height/2);return o.fromEquirectangularTexture(t,r),e.set(r,o),t.setRenderTarget(a),r.addEventListener("dispose",i),n(o.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}Hn.prototype.isWebGLCubeRenderTarget=!0;class Vn extends Fn{constructor(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,a=i+e,o=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,s=r+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(r,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}Vn.prototype.isOrthographicCamera=!0;class Wn extends He{constructor(t){super(t),this.type="RawShaderMaterial"}}Wn.prototype.isRawShaderMaterial=!0;const jn=Math.pow(2,8),Xn=[.125,.215,.35,.446,.526,.582],qn=5+Xn.length,Yn=20,Zn={[F]:0,[O]:1,[B]:2,3004:3,3005:4,3006:5,[U]:6},Jn=new Vn,{_lodPlanes:Qn,_sizeLods:Kn,_sigmas:$n}=oi(),ti=new te;let ei=null;const ni=(1+Math.sqrt(5))/2,ii=1/ni,ri=[new lt(1,1,1),new lt(-1,1,1),new lt(1,1,-1),new lt(-1,1,-1),new lt(0,ni,ii),new lt(0,ni,-ii),new lt(ii,0,ni),new lt(-ii,0,ni),new lt(ni,ii,0),new lt(-ni,ii,0)];class si{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const e=new Float32Array(t),n=new lt(0,1,0);return new Wn({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:Zn[3e3]},outputEncoding:{value:Zn[3e3]}},vertexShader:di(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${pi()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}(Yn),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){ei=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=ui(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=ci(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<Qn.length;t++)Qn[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(ei),t.scissorTest=!1,hi(t,0,0,t.width,t.height)}_fromTexture(t){ei=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:w,minFilter:w,generateMipmaps:!1,type:T,format:1023,encoding:ai(t)?t.encoding:B,depthBuffer:!1},n=li(e);return n.depthBuffer=!t,this._pingPongRenderTarget=li(e),n}_compileMaterial(t){const e=new Tn(Qn[0],t);this._renderer.compile(e,Jn)}_sceneToCubeUV(t,e,n,i){const r=new On(90,1,e,n),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,h=o.outputEncoding,c=o.toneMapping;o.getClearColor(ti),o.toneMapping=0,o.outputEncoding=F,o.autoClear=!1;const u=new ln({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),d=new Tn(new Ne,u);let p=!1;const f=t.background;f?f.isColor&&(u.color.copy(f),t.background=null,p=!0):(u.color.copy(ti),p=!0);for(let e=0;e<6;e++){const n=e%3;0==n?(r.up.set(0,s[e],0),r.lookAt(a[e],0,0)):1==n?(r.up.set(0,0,s[e]),r.lookAt(0,a[e],0)):(r.up.set(0,s[e],0),r.lookAt(0,0,a[e])),hi(i,n*jn,e>2?jn:0,jn,jn),o.setRenderTarget(i),p&&o.render(d,r),o.render(t,r)}d.geometry.dispose(),d.material.dispose(),o.toneMapping=c,o.outputEncoding=h,o.autoClear=l,t.background=f}_textureToCubeUV(t,e){const n=this._renderer;t.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=ui()):null==this._equirectShader&&(this._equirectShader=ci());const i=t.isCubeTexture?this._cubemapShader:this._equirectShader,r=new Tn(Qn[0],i),s=i.uniforms;s.envMap.value=t,t.isCubeTexture||s.texelSize.value.set(1/t.image.width,1/t.image.height),s.inputEncoding.value=Zn[t.encoding],s.outputEncoding.value=Zn[e.texture.encoding],hi(e,0,0,3*jn,2*jn),n.setRenderTarget(e),n.render(r,Jn)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<qn;e++){const n=Math.sqrt($n[e]*$n[e]-$n[e-1]*$n[e-1]),i=ri[(e-1)%ri.length];this._blur(t,e-1,e,n,i)}e.autoClear=n}_blur(t,e,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,i,"latitudinal",r),this._halfBlur(s,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,s,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const h=new Tn(Qn[i],l),c=l.uniforms,u=Kn[n]-1,d=isFinite(r)?Math.PI/(2*u):2*Math.PI/39,p=r/d,f=isFinite(r)?1+Math.floor(3*p):Yn;f>Yn&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<Yn;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0==t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;c.envMap.value=t.texture,c.samples.value=f,c.weights.value=m,c.latitudinal.value="latitudinal"===s,a&&(c.poleAxis.value=a),c.dTheta.value=d,c.mipInt.value=8-n,c.inputEncoding.value=Zn[t.texture.encoding],c.outputEncoding.value=Zn[t.texture.encoding];const v=Kn[i];hi(e,3*Math.max(0,jn-2*v),(0===i?0:2*jn)+2*v*(i>4?i-8+4:0),3*v,2*v),o.setRenderTarget(e),o.render(h,Jn)}}function ai(t){return void 0!==t&&t.type===T&&(t.encoding===F||t.encoding===O||t.encoding===U)}function oi(){const t=[],e=[],n=[];let i=8;for(let r=0;r<qn;r++){const s=Math.pow(2,i);e.push(s);let a=1/s;r>4?a=Xn[r-8+4-1]:0==r&&(a=0),n.push(a);const o=1/(s-1),l=-o/2,h=1+o/2,c=[l,l,h,l,h,h,l,l,h,h,l,h],u=6,d=6,p=3,f=2,m=1,g=new Float32Array(p*d*u),v=new Float32Array(f*d*u),x=new Float32Array(m*d*u);for(let t=0;t<u;t++){const e=t%3*2/3-1,n=t>2?0:-1,i=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];g.set(i,p*d*t),v.set(c,f*d*t);const r=[t,t,t,t,t,t];x.set(r,m*d*t)}const y=new Ie;y.setAttribute("position",new ie(g,p)),y.setAttribute("uv",new ie(v,f)),y.setAttribute("faceIndex",new ie(x,m)),t.push(y),i>4&&i--}return{_lodPlanes:t,_sizeLods:e,_sigmas:n}}function li(t){const e=new at(3*jn,3*jn,t);return e.texture.mapping=y,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function hi(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function ci(){const t=new $(1,1);return new Wn({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:t},inputEncoding:{value:Zn[3e3]},outputEncoding:{value:Zn[3e3]}},vertexShader:di(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${pi()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}function ui(){return new Wn({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Zn[3e3]},outputEncoding:{value:Zn[3e3]}},vertexShader:di(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${pi()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}function di(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function pi(){return"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"}function fi(t){let e=new WeakMap,n=null;function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){const s=r.mapping,a=303===s||304===s,o=s===v||s===x;if(a||o){if(e.has(r))return e.get(r).texture;{const s=r.image;if(a&&s&&s.height>0||o&&s&&function(t){let e=0;const n=6;for(let i=0;i<n;i++)void 0!==t[i]&&e++;return e===n}(s)){const s=t.getRenderTarget();null===n&&(n=new si(t));const o=a?n.fromEquirectangular(r):n.fromCubemap(r);return e.set(r,o),t.setRenderTarget(s),r.addEventListener("dispose",i),o.texture}return null}}}return r},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function mi(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function gi(t,e,n,i){const r={},s=new WeakMap;function a(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);o.removeEventListener("dispose",a),delete r[o.id];const l=s.get(o);l&&(e.remove(l),s.delete(o)),i.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(t){const n=[],i=t.index,r=t.attributes.position;let a=0;if(null!==i){const t=i.array;a=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],s=t[e+2];n.push(i,r,r,s,s,i)}}else{const t=r.array;a=r.version;for(let e=0,i=t.length/3-1;e<i;e+=3){const t=e+0,i=e+1,r=e+2;n.push(t,i,i,r,r,t)}}const o=new(Ee(n)>65535?se:re)(n,1);o.version=a;const l=s.get(t);l&&e.remove(l),s.set(t,o)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",a),r[e.id]=!0,n.memory.geometries++),e},update:function(n){const i=n.attributes;for(const n in i)e.update(i[n],t.ARRAY_BUFFER);const r=n.morphAttributes;for(const n in r){const i=r[n];for(let n=0,r=i.length;n<r;n++)e.update(i[n],t.ARRAY_BUFFER)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&o(t)}else o(t);return s.get(t)}}}function vi(t,e,n,i){const r=i.isWebGL2;let s,a,o;this.setMode=function(t){s=t},this.setIndex=function(t){a=t.type,o=t.bytesPerElement},this.render=function(e,i){t.drawElements(s,i,a,e*o),n.update(i,s,1)},this.renderInstances=function(i,l,h){if(0===h)return;let c,u;if(r)c=t,u="drawElementsInstanced";else if(c=e.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===c)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[u](s,l,a,i*o,h),n.update(l,s,h)}}function xi(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(n,i,r){switch(e.calls++,i){case t.TRIANGLES:e.triangles+=r*(n/3);break;case t.LINES:e.lines+=r*(n/2);break;case t.LINE_STRIP:e.lines+=r*(n-1);break;case t.LINE_LOOP:e.lines+=r*n;break;case t.POINTS:e.points+=r*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function yi(t,e){return t[0]-e[0]}function _i(t,e){return Math.abs(e[1])-Math.abs(t[1])}function Mi(t){const e={},n=new Float32Array(8),i=[];for(let t=0;t<8;t++)i[t]=[t,0];return{update:function(r,s,a,o){const l=r.morphTargetInfluences,h=void 0===l?0:l.length;let c=e[s.id];if(void 0===c||c.length!==h){c=[];for(let t=0;t<h;t++)c[t]=[t,0];e[s.id]=c}for(let t=0;t<h;t++){const e=c[t];e[0]=t,e[1]=l[t]}c.sort(_i);for(let t=0;t<8;t++)t<h&&c[t][1]?(i[t][0]=c[t][0],i[t][1]=c[t][1]):(i[t][0]=Number.MAX_SAFE_INTEGER,i[t][1]=0);i.sort(yi);const u=s.morphAttributes.position,d=s.morphAttributes.normal;let p=0;for(let t=0;t<8;t++){const e=i[t],r=e[0],a=e[1];r!==Number.MAX_SAFE_INTEGER&&a?(u&&s.getAttribute("morphTarget"+t)!==u[r]&&s.setAttribute("morphTarget"+t,u[r]),d&&s.getAttribute("morphNormal"+t)!==d[r]&&s.setAttribute("morphNormal"+t,d[r]),n[t]=a,p+=a):(u&&!0===s.hasAttribute("morphTarget"+t)&&s.deleteAttribute("morphTarget"+t),d&&!0===s.hasAttribute("morphNormal"+t)&&s.deleteAttribute("morphNormal"+t),n[t]=0)}const f=s.morphTargetsRelative?1:1-p;o.getUniforms().setValue(t,"morphTargetBaseInfluence",f),o.getUniforms().setValue(t,"morphTargetInfluences",n)}}}class bi extends at{constructor(t,e,n){super(t,e,n),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}function wi(t,e,n,i){let r=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(a){const o=i.render.frame,l=a.geometry,h=e.get(a,l);return r.get(h)!==o&&(e.update(h),r.set(h,o)),a.isInstancedMesh&&(!1===a.hasEventListener("dispose",s)&&a.addEventListener("dispose",s),n.update(a.instanceMatrix,t.ARRAY_BUFFER),null!==a.instanceColor&&n.update(a.instanceColor,t.ARRAY_BUFFER)),h},dispose:function(){r=new WeakMap}}}bi.prototype.isWebGLMultisampleRenderTarget=!0;class Si extends it{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=w,this.minFilter=w,this.wrapR=M,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Si.prototype.isDataTexture2DArray=!0;class Ei extends it{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=w,this.minFilter=w,this.wrapR=M,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Ei.prototype.isDataTexture3D=!0;const Ti=new it,Li=new Si,Ci=new Ei,Ai=new kn,Ri=[],Pi=[],Di=new Float32Array(16),Ii=new Float32Array(9),Ni=new Float32Array(4);function zi(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let s=Ri[r];if(void 0===s&&(s=new Float32Array(r),Ri[r]=s),0!==e){i.toArray(s,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(s,r)}return s}function Fi(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function Oi(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function Ui(t,e){let n=Pi[e];void 0===n&&(n=new Int32Array(e),Pi[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function Bi(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function ki(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Fi(n,e))return;t.uniform2fv(this.addr,e),Oi(n,e)}}function Hi(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(Fi(n,e))return;t.uniform3fv(this.addr,e),Oi(n,e)}}function Gi(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Fi(n,e))return;t.uniform4fv(this.addr,e),Oi(n,e)}}function Vi(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(Fi(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),Oi(n,e)}else{if(Fi(n,i))return;Ni.set(i),t.uniformMatrix2fv(this.addr,!1,Ni),Oi(n,i)}}function Wi(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(Fi(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),Oi(n,e)}else{if(Fi(n,i))return;Ii.set(i),t.uniformMatrix3fv(this.addr,!1,Ii),Oi(n,i)}}function ji(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(Fi(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),Oi(n,e)}else{if(Fi(n,i))return;Di.set(i),t.uniformMatrix4fv(this.addr,!1,Di),Oi(n,i)}}function Xi(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function qi(t,e){const n=this.cache;Fi(n,e)||(t.uniform2iv(this.addr,e),Oi(n,e))}function Yi(t,e){const n=this.cache;Fi(n,e)||(t.uniform3iv(this.addr,e),Oi(n,e))}function Zi(t,e){const n=this.cache;Fi(n,e)||(t.uniform4iv(this.addr,e),Oi(n,e))}function Ji(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function Qi(t,e){const n=this.cache;Fi(n,e)||(t.uniform2uiv(this.addr,e),Oi(n,e))}function Ki(t,e){const n=this.cache;Fi(n,e)||(t.uniform3uiv(this.addr,e),Oi(n,e))}function $i(t,e){const n=this.cache;Fi(n,e)||(t.uniform4uiv(this.addr,e),Oi(n,e))}function tr(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(e||Ti,r)}function er(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||Ci,r)}function nr(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTextureCube(e||Ai,r)}function ir(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||Li,r)}function rr(t,e){t.uniform1fv(this.addr,e)}function sr(t,e){const n=zi(e,this.size,2);t.uniform2fv(this.addr,n)}function ar(t,e){const n=zi(e,this.size,3);t.uniform3fv(this.addr,n)}function or(t,e){const n=zi(e,this.size,4);t.uniform4fv(this.addr,n)}function lr(t,e){const n=zi(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function hr(t,e){const n=zi(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function cr(t,e){const n=zi(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function ur(t,e){t.uniform1iv(this.addr,e)}function dr(t,e){t.uniform2iv(this.addr,e)}function pr(t,e){t.uniform3iv(this.addr,e)}function fr(t,e){t.uniform4iv(this.addr,e)}function mr(t,e){t.uniform1uiv(this.addr,e)}function gr(t,e){t.uniform2uiv(this.addr,e)}function vr(t,e){t.uniform3uiv(this.addr,e)}function xr(t,e){t.uniform4uiv(this.addr,e)}function yr(t,e,n){const i=e.length,r=Ui(n,i);t.uniform1iv(this.addr,r);for(let t=0;t!==i;++t)n.safeSetTexture2D(e[t]||Ti,r[t])}function _r(t,e,n){const i=e.length,r=Ui(n,i);t.uniform1iv(this.addr,r);for(let t=0;t!==i;++t)n.safeSetTextureCube(e[t]||Ai,r[t])}function Mr(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return Bi;case 35664:return ki;case 35665:return Hi;case 35666:return Gi;case 35674:return Vi;case 35675:return Wi;case 35676:return ji;case 5124:case 35670:return Xi;case 35667:case 35671:return qi;case 35668:case 35672:return Yi;case 35669:case 35673:return Zi;case 5125:return Ji;case 36294:return Qi;case 36295:return Ki;case 36296:return $i;case 35678:case 36198:case 36298:case 36306:case 35682:return tr;case 35679:case 36299:case 36307:return er;case 35680:case 36300:case 36308:case 36293:return nr;case 36289:case 36303:case 36311:case 36292:return ir}}(e.type)}function br(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return rr;case 35664:return sr;case 35665:return ar;case 35666:return or;case 35674:return lr;case 35675:return hr;case 35676:return cr;case 5124:case 35670:return ur;case 35667:case 35671:return dr;case 35668:case 35672:return pr;case 35669:case 35673:return fr;case 5125:return mr;case 36294:return gr;case 36295:return vr;case 36296:return xr;case 35678:case 36198:case 36298:case 36306:case 35682:return yr;case 35680:case 36300:case 36308:case 36293:return _r}}(e.type)}function wr(t){this.id=t,this.seq=[],this.map={}}br.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),Oi(e,t)},wr.prototype.setValue=function(t,e,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const s=i[r];s.setValue(t,e[s.id],n)}};const Sr=/(\w+)(\])?(\[|\.)?/g;function Er(t,e){t.seq.push(e),t.map[e.id]=e}function Tr(t,e,n){const i=t.name,r=i.length;for(Sr.lastIndex=0;;){const s=Sr.exec(i),a=Sr.lastIndex;let o=s[1];const l="]"===s[2],h=s[3];if(l&&(o|=0),void 0===h||"["===h&&a+2===r){Er(n,void 0===h?new Mr(o,t,e):new br(o,t,e));break}{let t=n.map[o];void 0===t&&(t=new wr(o),Er(n,t)),n=t}}}function Lr(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);Tr(n,t.getUniformLocation(e,n.name),this)}}function Cr(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}Lr.prototype.setValue=function(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)},Lr.prototype.setOptional=function(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)},Lr.upload=function(t,e,n,i){for(let r=0,s=e.length;r!==s;++r){const s=e[r],a=n[s.id];!1!==a.needsUpdate&&s.setValue(t,a.value,i)}},Lr.seqWithValue=function(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n};let Ar=0;function Rr(t){switch(t){case F:return["Linear","( value )"];case O:return["sRGB","( value )"];case B:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case U:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function Pr(t,e,n){const i=t.getShaderParameter(e,t.COMPILE_STATUS),r=t.getShaderInfoLog(e).trim();return i&&""===r?"":n.toUpperCase()+"\n\n"+r+"\n\n"+function(t){const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join("\n")}(t.getShaderSource(e))}function Dr(t,e){const n=Rr(e);return"vec4 "+t+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function Ir(t,e){const n=Rr(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function Nr(t,e){let n;switch(e){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function zr(t){return""!==t}function Fr(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Or(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Ur=/^[ \t]*#include +<([\w\d./]+)>/gm;function Br(t){return t.replace(Ur,kr)}function kr(t,e){const n=Cn[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return Br(n)}const Hr=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Gr=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Vr(t){return t.replace(Gr,jr).replace(Hr,Wr)}function Wr(t,e,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),jr(t,e,n,i)}function jr(t,e,n,i){let r="";for(let t=parseInt(e);t<parseInt(n);t++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return r}function Xr(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function qr(t,e,n,i){const r=t.getContext(),s=n.defines;let a=n.vertexShader,o=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(n),h=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case v:case x:e="ENVMAP_TYPE_CUBE";break;case y:case 307:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),c=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case x:case 307:e="ENVMAP_MODE_REFRACTION"}return e}(n),u=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(n),d=t.gammaFactor>0?t.gammaFactor:1,p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(zr).join("\n")}(n),f=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(s),m=r.createProgram();let g,_,M=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[f].filter(zr).join("\n"),g.length>0&&(g+="\n"),_=[p,f].filter(zr).join("\n"),_.length>0&&(_+="\n")):(g=[Xr(n),"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularTintMap?"#define USE_SPECULARTINTMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(zr).join("\n"),_=[p,Xr(n),"#define SHADER_NAME "+n.shaderName,f,"#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularTintMap?"#define USE_SPECULARTINTMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheenTint?"#define USE_SHEEN":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?Cn.tonemapping_pars_fragment:"",0!==n.toneMapping?Nr("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.format===D?"#define OPAQUE":"",Cn.encodings_pars_fragment,n.map?Dr("mapTexelToLinear",n.mapEncoding):"",n.matcap?Dr("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?Dr("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?Dr("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.specularTintMap?Dr("specularTintMapTexelToLinear",n.specularTintMapEncoding):"",n.lightMap?Dr("lightMapTexelToLinear",n.lightMapEncoding):"",Ir("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(zr).join("\n")),a=Br(a),a=Fr(a,n),a=Or(a,n),o=Br(o),o=Fr(o,n),o=Or(o,n),a=Vr(a),o=Vr(o),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(M="#version 300 es\n",g=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,_=["#define varying in",n.glslVersion===V?"":"out highp vec4 pc_fragColor;",n.glslVersion===V?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+_);const b=M+g+a,w=M+_+o,S=Cr(r,r.VERTEX_SHADER,b),E=Cr(r,r.FRAGMENT_SHADER,w);if(r.attachShader(m,S),r.attachShader(m,E),void 0!==n.index0AttributeName?r.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),t.debug.checkShaderErrors){const t=r.getProgramInfoLog(m).trim(),e=r.getShaderInfoLog(S).trim(),n=r.getShaderInfoLog(E).trim();let i=!0,s=!0;if(!1===r.getProgramParameter(m,r.LINK_STATUS)){i=!1;const e=Pr(r,S,"vertex"),n=Pr(r,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(m,r.VALIDATE_STATUS)+"\n\nProgram Info Log: "+t+"\n"+e+"\n"+n)}else""!==t?console.warn("THREE.WebGLProgram: Program Info Log:",t):""!==e&&""!==n||(s=!1);s&&(this.diagnostics={runnable:i,programLog:t,vertexShader:{log:e,prefix:g},fragmentShader:{log:n,prefix:_}})}let T,L;return r.deleteShader(S),r.deleteShader(E),this.getUniforms=function(){return void 0===T&&(T=new Lr(r,m)),T},this.getAttributes=function(){return void 0===L&&(L=function(t,e){const n={},i=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r),s=i.name;let a=1;i.type===t.FLOAT_MAT2&&(a=2),i.type===t.FLOAT_MAT3&&(a=3),i.type===t.FLOAT_MAT4&&(a=4),n[s]={type:i.type,location:t.getAttribLocation(e,s),locationSize:a}}return n}(r,m)),L},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=Ar++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=E,this}function Yr(t,e,n,i,r,s,a){const o=[],l=r.isWebGL2,h=r.logarithmicDepthBuffer,c=r.floatVertexTextures,u=r.maxVertexUniforms,d=r.vertexTextures;let p=r.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheenTint","transmission","transmissionMap","thicknessMap"];function g(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=F,e}return{getParameters:function(s,o,m,v,x){const _=v.fog,M=s.isMeshStandardMaterial?v.environment:null,b=(s.isMeshStandardMaterial?n:e).get(s.envMap||M),w=f[s.type],S=x.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(c)return 1024;{const t=u,n=Math.floor((t-20)/4),i=Math.min(n,e.length);return i<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+i+"."),0):i}}(x):0;let E,T;if(null!==s.precision&&(p=r.getMaxPrecision(s.precision),p!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",p,"instead.")),w){const t=Rn[w];E=t.vertexShader,T=t.fragmentShader}else E=s.vertexShader,T=s.fragmentShader;const L=t.getRenderTarget(),C=s.alphaTest>0,A=s.clearcoat>0;return{isWebGL2:l,shaderID:w,shaderName:s.type,vertexShader:E,fragmentShader:T,defines:s.defines,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:p,instancing:!0===x.isInstancedMesh,instancingColor:!0===x.isInstancedMesh&&null!==x.instanceColor,supportsVertexTextures:d,outputEncoding:null!==L?g(L.texture):t.outputEncoding,map:!!s.map,mapEncoding:g(s.map),matcap:!!s.matcap,matcapEncoding:g(s.matcap),envMap:!!b,envMapMode:b&&b.mapping,envMapEncoding:g(b),envMapCubeUV:!!b&&(b.mapping===y||307===b.mapping),lightMap:!!s.lightMap,lightMapEncoding:g(s.lightMap),aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,emissiveMapEncoding:g(s.emissiveMap),bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:1===s.normalMapType,tangentSpaceNormalMap:0===s.normalMapType,clearcoat:A,clearcoatMap:A&&!!s.clearcoatMap,clearcoatRoughnessMap:A&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:A&&!!s.clearcoatNormalMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularTintMap:!!s.specularTintMap,specularTintMapEncoding:g(s.specularTintMap),alphaMap:!!s.alphaMap,alphaTest:C,gradientMap:!!s.gradientMap,sheenTint:!!s.sheenTint&&(s.sheenTint.r>0||s.sheenTint.g>0||s.sheenTint.b>0),transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!x.geometry&&!!x.geometry.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!x.geometry&&!!x.geometry.attributes.color&&4===x.geometry.attributes.color.itemSize,vertexUvs:!!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatMap||s.clearcoatRoughnessMap||s.clearcoatNormalMap||s.displacementMap||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularTintMap),uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularTintMap||!s.displacementMap),fog:!!_,useFog:s.fog,fogExp2:_&&_.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:h,skinning:!0===x.isSkinnedMesh&&S>0,maxBones:S,useVertexTexture:c,morphTargets:!!x.geometry&&!!x.geometry.morphAttributes.position,morphNormals:!!x.geometry&&!!x.geometry.morphAttributes.normal,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:s.format,dithering:s.dithering,shadowMapEnabled:t.shadowMap.enabled&&m.length>0,shadowMapType:t.shadowMap.type,toneMapping:s.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:2===s.side,flipSided:1===s.side,depthPacking:void 0!==s.depthPacking&&s.depthPacking,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:l||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:l||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:l||i.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.fragmentShader),n.push(e.vertexShader)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);if(!1===e.isRawShaderMaterial){for(let t=0;t<m.length;t++)n.push(e[m[t]]);n.push(t.outputEncoding),n.push(t.gammaFactor)}return n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=f[t.type];let n;if(e){const t=Rn[e];n=ke.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let i;for(let t=0,e=o.length;t<e;t++){const e=o[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new qr(t,n,e,s),o.push(i)),i},releaseProgram:function(t){if(0==--t.usedTimes){const e=o.indexOf(t);o[e]=o[o.length-1],o.pop(),t.destroy()}},programs:o}}function Zr(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function Jr(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Qr(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Kr(t){const e=[];let n=0;const i=[],r=[],s=[],a={id:-1};function o(i,r,s,o,l,h){let c=e[n];const u=t.get(s);return void 0===c?(c={id:i.id,object:i,geometry:r,material:s,program:u.program||a,groupOrder:o,renderOrder:i.renderOrder,z:l,group:h},e[n]=c):(c.id=i.id,c.object=i,c.geometry=r,c.material=s,c.program=u.program||a,c.groupOrder=o,c.renderOrder=i.renderOrder,c.z=l,c.group=h),n++,c}return{opaque:i,transmissive:r,transparent:s,init:function(){n=0,i.length=0,r.length=0,s.length=0},push:function(t,e,n,a,l,h){const c=o(t,e,n,a,l,h);n.transmission>0?r.push(c):!0===n.transparent?s.push(c):i.push(c)},unshift:function(t,e,n,a,l,h){const c=o(t,e,n,a,l,h);n.transmission>0?r.unshift(c):!0===n.transparent?s.unshift(c):i.unshift(c)},finish:function(){for(let t=n,i=e.length;t<i;t++){const n=e[t];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(t,e){i.length>1&&i.sort(t||Jr),r.length>1&&r.sort(e||Qr),s.length>1&&s.sort(e||Qr)}}}function $r(t){let e=new WeakMap;return{get:function(n,i){let r;return!1===e.has(n)?(r=new Kr(t),e.set(n,[r])):i>=e.get(n).length?(r=new Kr(t),e.get(n).push(r)):r=e.get(n)[i],r},dispose:function(){e=new WeakMap}}}function ts(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new lt,color:new te};break;case"SpotLight":n={position:new lt,direction:new lt,color:new te,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new lt,color:new te,distance:0,decay:0};break;case"HemisphereLight":n={direction:new lt,skyColor:new te,groundColor:new te};break;case"RectAreaLight":n={color:new te,position:new lt,halfWidth:new lt,halfHeight:new lt}}return t[e.id]=n,n}}}let es=0;function ns(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function is(t,e){const n=new ts,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new $};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new $,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)r.probe.push(new lt);const s=new lt,a=new Ut,o=new Ut;return{setup:function(s,a){let o=0,l=0,h=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let c=0,u=0,d=0,p=0,f=0,m=0,g=0,v=0;s.sort(ns);const x=!0!==a?Math.PI:1;for(let t=0,e=s.length;t<e;t++){const e=s[t],a=e.color,y=e.intensity,_=e.distance,M=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=a.r*y*x,l+=a.g*y*x,h+=a.b*y*x;else if(e.isLightProbe)for(let t=0;t<9;t++)r.probe[t].addScaledVector(e.sh.coefficients[t],y);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*x),e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.directionalShadow[c]=n,r.directionalShadowMap[c]=M,r.directionalShadowMatrix[c]=e.shadow.matrix,m++}r.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(a).multiplyScalar(y*x),t.distance=_,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.spotShadow[d]=n,r.spotShadowMap[d]=M,r.spotShadowMatrix[d]=e.shadow.matrix,v++}r.spot[d]=t,d++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(a).multiplyScalar(y),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),r.rectArea[p]=t,p++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*x),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,r.pointShadow[u]=n,r.pointShadowMap[u]=M,r.pointShadowMatrix[u]=e.shadow.matrix,g++}r.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(y*x),t.groundColor.copy(e.groundColor).multiplyScalar(y*x),r.hemi[f]=t,f++}}p>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=An.LTC_FLOAT_1,r.rectAreaLTC2=An.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=An.LTC_HALF_1,r.rectAreaLTC2=An.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=o,r.ambient[1]=l,r.ambient[2]=h;const y=r.hash;y.directionalLength===c&&y.pointLength===u&&y.spotLength===d&&y.rectAreaLength===p&&y.hemiLength===f&&y.numDirectionalShadows===m&&y.numPointShadows===g&&y.numSpotShadows===v||(r.directional.length=c,r.spot.length=d,r.rectArea.length=p,r.point.length=u,r.hemi.length=f,r.directionalShadow.length=m,r.directionalShadowMap.length=m,r.pointShadow.length=g,r.pointShadowMap.length=g,r.spotShadow.length=v,r.spotShadowMap.length=v,r.directionalShadowMatrix.length=m,r.pointShadowMatrix.length=g,r.spotShadowMatrix.length=v,y.directionalLength=c,y.pointLength=u,y.spotLength=d,y.rectAreaLength=p,y.hemiLength=f,y.numDirectionalShadows=m,y.numPointShadows=g,y.numSpotShadows=v,r.version=es++)},setupView:function(t,e){let n=0,i=0,l=0,h=0,c=0;const u=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),n++}else if(d.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const t=r.rectArea[h];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),o.identity(),a.copy(d.matrixWorld),a.premultiply(u),o.extractRotation(a),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),h++}else if(d.isPointLight){const t=r.point[i];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),i++}else if(d.isHemisphereLight){const t=r.hemi[c];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(u),t.direction.normalize(),c++}}},state:r}}function rs(t,e){const n=new is(t,e),i=[],r=[];return{init:function(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function(t){n.setup(i,t)},setupLightsView:function(t){n.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){r.push(t)}}}function ss(t,e){let n=new WeakMap;return{get:function(i,r=0){let s;return!1===n.has(i)?(s=new rs(t,e),n.set(i,[s])):r>=n.get(i).length?(s=new rs(t,e),n.get(i).push(s)):s=n.get(i)[r],s},dispose:function(){n=new WeakMap}}}class as extends Oe{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}as.prototype.isMeshDepthMaterial=!0;class os extends Oe{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new lt,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}os.prototype.isMeshDistanceMaterial=!0;function ls(t,e,n){let i=new Ot;const r=new $,s=new $,a=new st,o=new as({depthPacking:3201}),l=new os,h={},c=n.maxTextureSize,u={0:1,1:0,2:2},d=new He({uniforms:{shadow_pass:{value:null},resolution:{value:new $},radius:{value:4},samples:{value:8}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new Ie;f.setAttribute("position",new ie(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new Tn(f,d),g=this;function v(n,i){const r=e.update(m);d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,d.uniforms.samples.value=n.blurSamples,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,r,d,m,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,p.uniforms.samples.value=n.blurSamples,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,r,p,m,null)}function x(e,n,i,r,s,a,c){let d=null;const p=!0===r.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(d=void 0!==p?p:!0===r.isPointLight?l:o,t.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length||i.displacementMap&&0!==i.displacementScale||i.alphaMap&&i.alphaTest>0){const t=d.uuid,e=i.uuid;let n=h[t];void 0===n&&(n={},h[t]=n);let r=n[e];void 0===r&&(r=d.clone(),n[e]=r),d=r}return d.visible=i.visible,d.wireframe=i.wireframe,d.side=3===c?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:u[i.side],d.alphaMap=i.alphaMap,d.alphaTest=i.alphaTest,d.clipShadows=i.clipShadows,d.clippingPlanes=i.clippingPlanes,d.clipIntersection=i.clipIntersection,d.displacementMap=i.displacementMap,d.displacementScale=i.displacementScale,d.displacementBias=i.displacementBias,d.wireframeLinewidth=i.wireframeLinewidth,d.linewidth=i.linewidth,!0===r.isPointLight&&!0===d.isMeshDistanceMaterial&&(d.referencePosition.setFromMatrixPosition(r.matrixWorld),d.nearDistance=s,d.farDistance=a),d}function y(n,r,s,a,o){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===o)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const i=e.update(n),r=n.material;if(Array.isArray(r)){const e=i.groups;for(let l=0,h=e.length;l<h;l++){const h=e[l],c=r[h.materialIndex];if(c&&c.visible){const e=x(n,0,c,a,s.near,s.far,o);t.renderBufferDirect(s,null,i,e,n,h)}}}else if(r.visible){const e=x(n,0,r,a,s.near,s.far,o);t.renderBufferDirect(s,null,i,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)y(l[t],r,s,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(e,n,o){if(!1===g.enabled)return;if(!1===g.autoUpdate&&!1===g.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),h=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,h=e.length;l<h;l++){const h=e[l],u=h.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",h,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;r.copy(u.mapSize);const p=u.getFrameExtents();if(r.multiply(p),s.copy(u.mapSize),(r.x>c||r.y>c)&&(r.x>c&&(s.x=Math.floor(c/p.x),r.x=s.x*p.x,u.mapSize.x=s.x),r.y>c&&(s.y=Math.floor(c/p.y),r.y=s.y*p.y,u.mapSize.y=s.y)),null===u.map&&!u.isPointLightShadow&&3===this.type){const t={minFilter:S,magFilter:S,format:I};u.map=new at(r.x,r.y,t),u.map.texture.name=h.name+".shadowMap",u.mapPass=new at(r.x,r.y,t),u.camera.updateProjectionMatrix()}if(null===u.map){const t={minFilter:w,magFilter:w,format:I};u.map=new at(r.x,r.y,t),u.map.texture.name=h.name+".shadowMap",u.camera.updateProjectionMatrix()}t.setRenderTarget(u.map),t.clear();const f=u.getViewportCount();for(let t=0;t<f;t++){const e=u.getViewport(t);a.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(a),u.updateMatrices(h,t),i=u.getFrustum(),y(n,o,u.camera,h,this.type)}u.isPointLightShadow||3!==this.type||v(u,o),u.needsUpdate=!1}g.needsUpdate=!1,t.setRenderTarget(l,h,u)}}function hs(t,e,n){const i=n.isWebGL2;const r=new function(){let e=!1;const n=new st;let i=null;const r=new st(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,a,o){!0===o&&(e*=a,i*=a,s*=a),n.set(e,i,s,a),!1===r.equals(n)&&(t.clearColor(e,i,s,a),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,i=null,r=null;return{setTest:function(e){e?U(t.DEPTH_TEST):B(t.DEPTH_TEST)},setMask:function(i){n===i||e||(t.depthMask(i),n=i)},setFunc:function(e){if(i!==e){if(e)switch(e){case 0:t.depthFunc(t.NEVER);break;case 1:t.depthFunc(t.ALWAYS);break;case 2:t.depthFunc(t.LESS);break;case 3:t.depthFunc(t.LEQUAL);break;case 4:t.depthFunc(t.EQUAL);break;case 5:t.depthFunc(t.GEQUAL);break;case 6:t.depthFunc(t.GREATER);break;case 7:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.LEQUAL)}else t.depthFunc(t.LEQUAL);i=e}},setLocked:function(t){e=t},setClear:function(e){r!==e&&(t.clearDepth(e),r=e)},reset:function(){e=!1,n=null,i=null,r=null}}},a=new function(){let e=!1,n=null,i=null,r=null,s=null,a=null,o=null,l=null,h=null;return{setTest:function(n){e||(n?U(t.STENCIL_TEST):B(t.STENCIL_TEST))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,a){i===e&&r===n&&s===a||(t.stencilFunc(e,n,a),i=e,r=n,s=a)},setOp:function(e,n,i){a===e&&o===n&&l===i||(t.stencilOp(e,n,i),a=e,o=n,l=i)},setLocked:function(t){e=t},setClear:function(e){h!==e&&(t.clearStencil(e),h=e)},reset:function(){e=!1,n=null,i=null,r=null,s=null,a=null,o=null,l=null,h=null}}};let o={},l=null,h={},c=null,u=!1,d=null,p=null,f=null,m=null,v=null,x=null,y=null,_=!1,M=null,b=null,w=null,S=null,E=null;const T=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let L=!1,C=0;const A=t.getParameter(t.VERSION);-1!==A.indexOf("WebGL")?(C=parseFloat(/^WebGL (\d)/.exec(A)[1]),L=C>=1):-1!==A.indexOf("OpenGL ES")&&(C=parseFloat(/^OpenGL ES (\d)/.exec(A)[1]),L=C>=2);let R=null,P={};const D=t.getParameter(t.SCISSOR_BOX),I=t.getParameter(t.VIEWPORT),N=(new st).fromArray(D),z=(new st).fromArray(I);function F(e,n,i){const r=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(e,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let e=0;e<i;e++)t.texImage2D(n+e,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,r);return s}const O={};function U(e){!0!==o[e]&&(t.enable(e),o[e]=!0)}function B(e){!1!==o[e]&&(t.disable(e),o[e]=!1)}O[t.TEXTURE_2D]=F(t.TEXTURE_2D,t.TEXTURE_2D,1),O[t.TEXTURE_CUBE_MAP]=F(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),r.setClear(0,0,0,1),s.setClear(1),a.setClear(0),U(t.DEPTH_TEST),s.setFunc(3),V(!1),W(1),U(t.CULL_FACE),G(0);const k={[g]:t.FUNC_ADD,101:t.FUNC_SUBTRACT,102:t.FUNC_REVERSE_SUBTRACT};if(i)k[103]=t.MIN,k[104]=t.MAX;else{const t=e.get("EXT_blend_minmax");null!==t&&(k[103]=t.MIN_EXT,k[104]=t.MAX_EXT)}const H={200:t.ZERO,201:t.ONE,202:t.SRC_COLOR,204:t.SRC_ALPHA,210:t.SRC_ALPHA_SATURATE,208:t.DST_COLOR,206:t.DST_ALPHA,203:t.ONE_MINUS_SRC_COLOR,205:t.ONE_MINUS_SRC_ALPHA,209:t.ONE_MINUS_DST_COLOR,207:t.ONE_MINUS_DST_ALPHA};function G(e,n,i,r,s,a,o,l){if(0!==e){if(!1===u&&(U(t.BLEND),u=!0),5===e)s=s||n,a=a||i,o=o||r,n===p&&s===v||(t.blendEquationSeparate(k[n],k[s]),p=n,v=s),i===f&&r===m&&a===x&&o===y||(t.blendFuncSeparate(H[i],H[r],H[a],H[o]),f=i,m=r,x=a,y=o),d=e,_=null;else if(e!==d||l!==_){if(p===g&&v===g||(t.blendEquation(t.FUNC_ADD),p=g,v=g),l)switch(e){case 1:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.ONE,t.ONE);break;case 3:t.blendFuncSeparate(t.ZERO,t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ONE_MINUS_SRC_ALPHA);break;case 4:t.blendFuncSeparate(t.ZERO,t.SRC_COLOR,t.ZERO,t.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.SRC_ALPHA,t.ONE);break;case 3:t.blendFunc(t.ZERO,t.ONE_MINUS_SRC_COLOR);break;case 4:t.blendFunc(t.ZERO,t.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}f=null,m=null,x=null,y=null,d=e,_=l}}else!0===u&&(B(t.BLEND),u=!1)}function V(e){M!==e&&(e?t.frontFace(t.CW):t.frontFace(t.CCW),M=e)}function W(e){0!==e?(U(t.CULL_FACE),e!==b&&(1===e?t.cullFace(t.BACK):2===e?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):B(t.CULL_FACE),b=e}function j(e,n,i){e?(U(t.POLYGON_OFFSET_FILL),S===n&&E===i||(t.polygonOffset(n,i),S=n,E=i)):B(t.POLYGON_OFFSET_FILL)}function X(e){void 0===e&&(e=t.TEXTURE0+T-1),R!==e&&(t.activeTexture(e),R=e)}return{buffers:{color:r,depth:s,stencil:a},enable:U,disable:B,bindFramebuffer:function(e,n){return null===n&&null!==l&&(n=l),h[e]!==n&&(t.bindFramebuffer(e,n),h[e]=n,i&&(e===t.DRAW_FRAMEBUFFER&&(h[t.FRAMEBUFFER]=n),e===t.FRAMEBUFFER&&(h[t.DRAW_FRAMEBUFFER]=n)),!0)},bindXRFramebuffer:function(e){e!==l&&(t.bindFramebuffer(t.FRAMEBUFFER,e),l=e)},useProgram:function(e){return c!==e&&(t.useProgram(e),c=e,!0)},setBlending:G,setMaterial:function(e,n){2===e.side?B(t.CULL_FACE):U(t.CULL_FACE);let i=1===e.side;n&&(i=!i),V(i),1===e.blending&&!1===e.transparent?G(0):G(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),s.setFunc(e.depthFunc),s.setTest(e.depthTest),s.setMask(e.depthWrite),r.setMask(e.colorWrite);const o=e.stencilWrite;a.setTest(o),o&&(a.setMask(e.stencilWriteMask),a.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),a.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),j(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?U(t.SAMPLE_ALPHA_TO_COVERAGE):B(t.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:V,setCullFace:W,setLineWidth:function(e){e!==w&&(L&&t.lineWidth(e),w=e)},setPolygonOffset:j,setScissorTest:function(e){e?U(t.SCISSOR_TEST):B(t.SCISSOR_TEST)},activeTexture:X,bindTexture:function(e,n){null===R&&X();let i=P[R];void 0===i&&(i={type:void 0,texture:void 0},P[R]=i),i.type===e&&i.texture===n||(t.bindTexture(e,n||O[e]),i.type=e,i.texture=n)},unbindTexture:function(){const e=P[R];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===N.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),N.copy(e))},viewport:function(e){!1===z.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),z.copy(e))},reset:function(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),!0===i&&(t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),o={},R=null,P={},l=null,h={},c=null,u=!1,d=null,p=null,f=null,m=null,v=null,x=null,y=null,_=!1,M=null,b=null,w=null,S=null,E=null,N.set(0,0,t.canvas.width,t.canvas.height),z.set(0,0,t.canvas.width,t.canvas.height),r.reset(),s.reset(),a.reset()}}}function cs(t,e,n,i,r,s,a){const o=r.isWebGL2,l=r.maxTextures,h=r.maxCubemapSize,c=r.maxTextureSize,u=r.maxSamples,d=new WeakMap;let p,f=!1;try{f="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function m(t,e){return f?new OffscreenCanvas(t,e):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(t,e,n,i){let r=1;if((t.width>i||t.height>i)&&(r=i/Math.max(t.width,t.height)),r<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const i=e?K:Math.floor,s=i(r*t.width),a=i(r*t.height);void 0===p&&(p=m(s,a));const o=n?m(s,a):p;o.width=s,o.height=a;return o.getContext("2d").drawImage(t,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+a+")."),o}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function v(t){return Q(t.width)&&Q(t.height)}function x(t,e){return t.generateMipmaps&&e&&t.minFilter!==w&&t.minFilter!==S}function y(e,n,r,s,a=1){t.generateMipmap(e);i.get(n).__maxMipLevel=Math.log2(Math.max(r,s,a))}function T(n,i,r){if(!1===o)return i;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let s=i;return i===t.RED&&(r===t.FLOAT&&(s=t.R32F),r===t.HALF_FLOAT&&(s=t.R16F),r===t.UNSIGNED_BYTE&&(s=t.R8)),i===t.RGB&&(r===t.FLOAT&&(s=t.RGB32F),r===t.HALF_FLOAT&&(s=t.RGB16F),r===t.UNSIGNED_BYTE&&(s=t.RGB8)),i===t.RGBA&&(r===t.FLOAT&&(s=t.RGBA32F),r===t.HALF_FLOAT&&(s=t.RGBA16F),r===t.UNSIGNED_BYTE&&(s=t.RGBA8)),s!==t.R16F&&s!==t.R32F&&s!==t.RGBA16F&&s!==t.RGBA32F||e.get("EXT_color_buffer_float"),s}function F(e){return e===w||1004===e||1005===e?t.NEAREST:t.LINEAR}function O(e){const n=e.target;n.removeEventListener("dispose",O),function(e){const n=i.get(e);if(void 0===n.__webglInit)return;t.deleteTexture(n.__webglTexture),i.remove(e)}(n),n.isVideoTexture&&d.delete(n),a.memory.textures--}function U(e){const n=e.target;n.removeEventListener("dispose",U),function(e){const n=e.texture,r=i.get(e),s=i.get(n);if(!e)return;void 0!==s.__webglTexture&&(t.deleteTexture(s.__webglTexture),a.memory.textures--);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(r.__webglFramebuffer[e]),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer[e]);else t.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&t.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer&&t.deleteRenderbuffer(r.__webglColorRenderbuffer),r.__webglDepthRenderbuffer&&t.deleteRenderbuffer(r.__webglDepthRenderbuffer);if(e.isWebGLMultipleRenderTargets)for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);r.__webglTexture&&(t.deleteTexture(r.__webglTexture),a.memory.textures--),i.remove(n[e])}i.remove(n),i.remove(e)}(n)}let B=0;function k(e,r){const s=i.get(e);if(e.isVideoTexture&&function(t){const e=a.render.frame;d.get(t)!==e&&(d.set(t,e),t.update())}(e),e.version>0&&s.__version!==e.version){const t=e.image;if(void 0===t)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==t.complete)return void X(s,e,r);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(t.TEXTURE0+r),n.bindTexture(t.TEXTURE_2D,s.__webglTexture)}function H(e,r){const a=i.get(e);e.version>0&&a.__version!==e.version?function(e,i,r){if(6!==i.image.length)return;j(e,i),n.activeTexture(t.TEXTURE0+r),n.bindTexture(t.TEXTURE_CUBE_MAP,e.__webglTexture),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,i.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,i.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,t.NONE);const a=i&&(i.isCompressedTexture||i.image[0].isCompressedTexture),l=i.image[0]&&i.image[0].isDataTexture,c=[];for(let t=0;t<6;t++)c[t]=a||l?l?i.image[t].image:i.image[t]:g(i.image[t],!1,!0,h);const u=c[0],d=v(u)||o,p=s.convert(i.format),f=s.convert(i.type),m=T(i.internalFormat,p,f);let _;if(W(t.TEXTURE_CUBE_MAP,i,d),a){for(let e=0;e<6;e++){_=c[e].mipmaps;for(let r=0;r<_.length;r++){const s=_[r];i.format!==I&&i.format!==D?null!==p?n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r,m,s.width,s.height,0,s.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r,m,s.width,s.height,0,p,f,s.data)}}e.__maxMipLevel=_.length-1}else{_=i.mipmaps;for(let e=0;e<6;e++)if(l){n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,m,c[e].width,c[e].height,0,p,f,c[e].data);for(let i=0;i<_.length;i++){const r=_[i].image[e].image;n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,m,r.width,r.height,0,p,f,r.data)}}else{n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,m,p,f,c[e]);for(let i=0;i<_.length;i++){const r=_[i];n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,m,p,f,r.image[e])}}e.__maxMipLevel=_.length}x(i,d)&&y(t.TEXTURE_CUBE_MAP,i,u.width,u.height);e.__version=i.version,i.onUpdate&&i.onUpdate(i)}(a,e,r):(n.activeTexture(t.TEXTURE0+r),n.bindTexture(t.TEXTURE_CUBE_MAP,a.__webglTexture))}const G={[_]:t.REPEAT,[M]:t.CLAMP_TO_EDGE,[b]:t.MIRRORED_REPEAT},V={[w]:t.NEAREST,1004:t.NEAREST_MIPMAP_NEAREST,1005:t.NEAREST_MIPMAP_LINEAR,[S]:t.LINEAR,1007:t.LINEAR_MIPMAP_NEAREST,[E]:t.LINEAR_MIPMAP_LINEAR};function W(n,s,a){if(a?(t.texParameteri(n,t.TEXTURE_WRAP_S,G[s.wrapS]),t.texParameteri(n,t.TEXTURE_WRAP_T,G[s.wrapT]),n!==t.TEXTURE_3D&&n!==t.TEXTURE_2D_ARRAY||t.texParameteri(n,t.TEXTURE_WRAP_R,G[s.wrapR]),t.texParameteri(n,t.TEXTURE_MAG_FILTER,V[s.magFilter]),t.texParameteri(n,t.TEXTURE_MIN_FILTER,V[s.minFilter])):(t.texParameteri(n,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(n,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),n!==t.TEXTURE_3D&&n!==t.TEXTURE_2D_ARRAY||t.texParameteri(n,t.TEXTURE_WRAP_R,t.CLAMP_TO_EDGE),s.wrapS===M&&s.wrapT===M||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,t.TEXTURE_MAG_FILTER,F(s.magFilter)),t.texParameteri(n,t.TEXTURE_MIN_FILTER,F(s.minFilter)),s.minFilter!==w&&s.minFilter!==S&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const a=e.get("EXT_texture_filter_anisotropic");if(s.type===A&&!1===e.has("OES_texture_float_linear"))return;if(!1===o&&s.type===R&&!1===e.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||i.get(s).__currentAnisotropy)&&(t.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),i.get(s).__currentAnisotropy=s.anisotropy)}}function j(e,n){void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",O),e.__webglTexture=t.createTexture(),a.memory.textures++)}function X(e,i,r){let a=t.TEXTURE_2D;i.isDataTexture2DArray&&(a=t.TEXTURE_2D_ARRAY),i.isDataTexture3D&&(a=t.TEXTURE_3D),j(e,i),n.activeTexture(t.TEXTURE0+r),n.bindTexture(a,e.__webglTexture),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,i.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,i.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,t.NONE);const l=function(t){return!o&&(t.wrapS!==M||t.wrapT!==M||t.minFilter!==w&&t.minFilter!==S)}(i)&&!1===v(i.image),h=g(i.image,l,!1,c),u=v(h)||o,d=s.convert(i.format);let p,f=s.convert(i.type),m=T(i.internalFormat,d,f);W(a,i,u);const _=i.mipmaps;if(i.isDepthTexture)m=t.DEPTH_COMPONENT,o?m=i.type===A?t.DEPTH_COMPONENT32F:i.type===C?t.DEPTH_COMPONENT24:i.type===P?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT16:i.type===A&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),i.format===N&&m===t.DEPTH_COMPONENT&&i.type!==L&&i.type!==C&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),i.type=L,f=s.convert(i.type)),i.format===z&&m===t.DEPTH_COMPONENT&&(m=t.DEPTH_STENCIL,i.type!==P&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),i.type=P,f=s.convert(i.type))),n.texImage2D(t.TEXTURE_2D,0,m,h.width,h.height,0,d,f,null);else if(i.isDataTexture)if(_.length>0&&u){for(let e=0,i=_.length;e<i;e++)p=_[e],n.texImage2D(t.TEXTURE_2D,e,m,p.width,p.height,0,d,f,p.data);i.generateMipmaps=!1,e.__maxMipLevel=_.length-1}else n.texImage2D(t.TEXTURE_2D,0,m,h.width,h.height,0,d,f,h.data),e.__maxMipLevel=0;else if(i.isCompressedTexture){for(let e=0,r=_.length;e<r;e++)p=_[e],i.format!==I&&i.format!==D?null!==d?n.compressedTexImage2D(t.TEXTURE_2D,e,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(t.TEXTURE_2D,e,m,p.width,p.height,0,d,f,p.data);e.__maxMipLevel=_.length-1}else if(i.isDataTexture2DArray)n.texImage3D(t.TEXTURE_2D_ARRAY,0,m,h.width,h.height,h.depth,0,d,f,h.data),e.__maxMipLevel=0;else if(i.isDataTexture3D)n.texImage3D(t.TEXTURE_3D,0,m,h.width,h.height,h.depth,0,d,f,h.data),e.__maxMipLevel=0;else if(_.length>0&&u){for(let e=0,i=_.length;e<i;e++)p=_[e],n.texImage2D(t.TEXTURE_2D,e,m,d,f,p);i.generateMipmaps=!1,e.__maxMipLevel=_.length-1}else n.texImage2D(t.TEXTURE_2D,0,m,d,f,h),e.__maxMipLevel=0;x(i,u)&&y(a,i,h.width,h.height),e.__version=i.version,i.onUpdate&&i.onUpdate(i)}function q(e,r,a,o,l){const h=s.convert(a.format),c=s.convert(a.type),u=T(a.internalFormat,h,c);l===t.TEXTURE_3D||l===t.TEXTURE_2D_ARRAY?n.texImage3D(l,0,u,r.width,r.height,r.depth,0,h,c,null):n.texImage2D(l,0,u,r.width,r.height,0,h,c,null),n.bindFramebuffer(t.FRAMEBUFFER,e),t.framebufferTexture2D(t.FRAMEBUFFER,o,l,i.get(a).__webglTexture,0),n.bindFramebuffer(t.FRAMEBUFFER,null)}function Y(e,n,i){if(t.bindRenderbuffer(t.RENDERBUFFER,e),n.depthBuffer&&!n.stencilBuffer){let r=t.DEPTH_COMPONENT16;if(i){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===A?r=t.DEPTH_COMPONENT32F:e.type===C&&(r=t.DEPTH_COMPONENT24));const i=J(n);t.renderbufferStorageMultisample(t.RENDERBUFFER,i,r,n.width,n.height)}else t.renderbufferStorage(t.RENDERBUFFER,r,n.width,n.height);t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,e)}else if(n.depthBuffer&&n.stencilBuffer){if(i){const e=J(n);t.renderbufferStorageMultisample(t.RENDERBUFFER,e,t.DEPTH24_STENCIL8,n.width,n.height)}else t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_STENCIL,n.width,n.height);t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture[0]:n.texture,r=s.convert(e.format),a=s.convert(e.type),o=T(e.internalFormat,r,a);if(i){const e=J(n);t.renderbufferStorageMultisample(t.RENDERBUFFER,e,o,n.width,n.height)}else t.renderbufferStorage(t.RENDERBUFFER,o,n.width,n.height)}t.bindRenderbuffer(t.RENDERBUFFER,null)}function Z(e){const r=i.get(e),s=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(t.FRAMEBUFFER,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),k(r.depthTexture,0);const s=i.get(r.depthTexture).__webglTexture;if(r.depthTexture.format===N)t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,s,0);else{if(r.depthTexture.format!==z)throw new Error("Unknown depthTexture format");t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,s,0)}}(r.__webglFramebuffer,e)}else if(s){r.__webglDepthbuffer=[];for(let i=0;i<6;i++)n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer[i]),r.__webglDepthbuffer[i]=t.createRenderbuffer(),Y(r.__webglDepthbuffer[i],e,!1)}else n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer),r.__webglDepthbuffer=t.createRenderbuffer(),Y(r.__webglDepthbuffer,e,!1);n.bindFramebuffer(t.FRAMEBUFFER,null)}function J(t){return o&&t.isWebGLMultisampleRenderTarget?Math.min(u,t.samples):0}let $=!1,tt=!1;this.allocateTextureUnit=function(){const t=B;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),B+=1,t},this.resetTextureUnits=function(){B=0},this.setTexture2D=k,this.setTexture2DArray=function(e,r){const s=i.get(e);e.version>0&&s.__version!==e.version?X(s,e,r):(n.activeTexture(t.TEXTURE0+r),n.bindTexture(t.TEXTURE_2D_ARRAY,s.__webglTexture))},this.setTexture3D=function(e,r){const s=i.get(e);e.version>0&&s.__version!==e.version?X(s,e,r):(n.activeTexture(t.TEXTURE0+r),n.bindTexture(t.TEXTURE_3D,s.__webglTexture))},this.setTextureCube=H,this.setupRenderTarget=function(e){const l=e.texture,h=i.get(e),c=i.get(l);e.addEventListener("dispose",U),!0!==e.isWebGLMultipleRenderTargets&&(c.__webglTexture=t.createTexture(),c.__version=l.version,a.memory.textures++);const u=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=!0===e.isWebGLMultisampleRenderTarget,f=l.isDataTexture3D||l.isDataTexture2DArray,m=v(e)||o;if(!o||l.format!==D||l.type!==A&&l.type!==R||(l.format=I,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),u){h.__webglFramebuffer=[];for(let e=0;e<6;e++)h.__webglFramebuffer[e]=t.createFramebuffer()}else if(h.__webglFramebuffer=t.createFramebuffer(),d)if(r.drawBuffers){const n=e.texture;for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);void 0===r.__webglTexture&&(r.__webglTexture=t.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(p)if(o){h.__webglMultisampledFramebuffer=t.createFramebuffer(),h.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,h.__webglColorRenderbuffer);const i=s.convert(l.format),r=s.convert(l.type),a=T(l.internalFormat,i,r),o=J(e);t.renderbufferStorageMultisample(t.RENDERBUFFER,o,a,e.width,e.height),n.bindFramebuffer(t.FRAMEBUFFER,h.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,h.__webglColorRenderbuffer),t.bindRenderbuffer(t.RENDERBUFFER,null),e.depthBuffer&&(h.__webglDepthRenderbuffer=t.createRenderbuffer(),Y(h.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(t.FRAMEBUFFER,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(u){n.bindTexture(t.TEXTURE_CUBE_MAP,c.__webglTexture),W(t.TEXTURE_CUBE_MAP,l,m);for(let n=0;n<6;n++)q(h.__webglFramebuffer[n],e,l,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+n);x(l,m)&&y(t.TEXTURE_CUBE_MAP,l,e.width,e.height),n.unbindTexture()}else if(d){const r=e.texture;for(let s=0,a=r.length;s<a;s++){const a=r[s],o=i.get(a);n.bindTexture(t.TEXTURE_2D,o.__webglTexture),W(t.TEXTURE_2D,a,m),q(h.__webglFramebuffer,e,a,t.COLOR_ATTACHMENT0+s,t.TEXTURE_2D),x(a,m)&&y(t.TEXTURE_2D,a,e.width,e.height)}n.unbindTexture()}else{let i=t.TEXTURE_2D;if(f)if(o){i=l.isDataTexture3D?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY}else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");n.bindTexture(i,c.__webglTexture),W(i,l,m),q(h.__webglFramebuffer,e,l,t.COLOR_ATTACHMENT0,i),x(l,m)&&y(i,l,e.width,e.height,e.depth),n.unbindTexture()}e.depthBuffer&&Z(e)},this.updateRenderTargetMipmap=function(e){const r=v(e)||o,s=!0===e.isWebGLMultipleRenderTargets?e.texture:[e.texture];for(let a=0,o=s.length;a<o;a++){const o=s[a];if(x(o,r)){const r=e.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:t.TEXTURE_2D,s=i.get(o).__webglTexture;n.bindTexture(r,s),y(r,o,e.width,e.height),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.isWebGLMultisampleRenderTarget)if(o){const r=e.width,s=e.height;let a=t.COLOR_BUFFER_BIT;e.depthBuffer&&(a|=t.DEPTH_BUFFER_BIT),e.stencilBuffer&&(a|=t.STENCIL_BUFFER_BIT);const o=i.get(e);n.bindFramebuffer(t.READ_FRAMEBUFFER,o.__webglMultisampledFramebuffer),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,o.__webglFramebuffer),t.blitFramebuffer(0,0,r,s,0,0,r,s,a,t.NEAREST),n.bindFramebuffer(t.READ_FRAMEBUFFER,null),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,o.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===$&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),$=!0),t=t.texture),k(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===tt&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),tt=!0),t=t.texture),H(t,e)}}function us(t,e,n){const i=n.isWebGL2;return{convert:function(n){let r;if(n===T)return t.UNSIGNED_BYTE;if(1017===n)return t.UNSIGNED_SHORT_4_4_4_4;if(1018===n)return t.UNSIGNED_SHORT_5_5_5_1;if(1019===n)return t.UNSIGNED_SHORT_5_6_5;if(1010===n)return t.BYTE;if(1011===n)return t.SHORT;if(n===L)return t.UNSIGNED_SHORT;if(1013===n)return t.INT;if(n===C)return t.UNSIGNED_INT;if(n===A)return t.FLOAT;if(n===R)return i?t.HALF_FLOAT:(r=e.get("OES_texture_half_float"),null!==r?r.HALF_FLOAT_OES:null);if(1021===n)return t.ALPHA;if(n===D)return t.RGB;if(n===I)return t.RGBA;if(1024===n)return t.LUMINANCE;if(1025===n)return t.LUMINANCE_ALPHA;if(n===N)return t.DEPTH_COMPONENT;if(n===z)return t.DEPTH_STENCIL;if(1028===n)return t.RED;if(1029===n)return t.RED_INTEGER;if(1030===n)return t.RG;if(1031===n)return t.RG_INTEGER;if(1032===n)return t.RGB_INTEGER;if(1033===n)return t.RGBA_INTEGER;if(33776===n||33777===n||33778===n||33779===n){if(r=e.get("WEBGL_compressed_texture_s3tc"),null===r)return null;if(33776===n)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===n)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===n)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===n)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===n||35841===n||35842===n||35843===n){if(r=e.get("WEBGL_compressed_texture_pvrtc"),null===r)return null;if(35840===n)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===n)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===n)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===n)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===n)return r=e.get("WEBGL_compressed_texture_etc1"),null!==r?r.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===n||37496===n)&&(r=e.get("WEBGL_compressed_texture_etc"),null!==r)){if(37492===n)return r.COMPRESSED_RGB8_ETC2;if(37496===n)return r.COMPRESSED_RGBA8_ETC2_EAC}return 37808===n||37809===n||37810===n||37811===n||37812===n||37813===n||37814===n||37815===n||37816===n||37817===n||37818===n||37819===n||37820===n||37821===n||37840===n||37841===n||37842===n||37843===n||37844===n||37845===n||37846===n||37847===n||37848===n||37849===n||37850===n||37851===n||37852===n||37853===n?(r=e.get("WEBGL_compressed_texture_astc"),null!==r?n:null):36492===n?(r=e.get("EXT_texture_compression_bptc"),null!==r?n:null):n===P?i?t.UNSIGNED_INT_24_8:(r=e.get("WEBGL_depth_texture"),null!==r?r.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}class ds extends On{constructor(t=[]){super(),this.cameras=t}}ds.prototype.isArrayCamera=!0;class ps extends Se{constructor(){super(),this.type="Group"}}ps.prototype.isGroup=!0;const fs={type:"move"};class ms{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new ps,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new ps,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new lt,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new lt),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new ps,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new lt,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new lt),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(null!==a&&(i=e.getPose(t.targetRaySpace,n),null!==i&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(fs))),l&&t.hand){s=!0;for(const i of t.hand.values()){const t=e.getJointPose(i,n);if(void 0===l.joints[i.jointName]){const t=new ps;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[i.jointName]=t,l.add(t)}const r=l.joints[i.jointName];null!==t&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.jointRadius=t.radius),r.visible=null!==t}const i=l.joints["index-finger-tip"],r=l.joints["thumb-tip"],a=i.position.distanceTo(r.position),o=.02,h=.005;l.inputState.pinching&&a>o+h?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&a<=o-h&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1));return null!==a&&(a.visible=null!==i),null!==o&&(o.visible=null!==r),null!==l&&(l.visible=null!==s),this}}class gs extends d{constructor(t,e){super();const n=this,i=t.state;let r=null,s=1,a=null,o="local-floor",l=null,h=null,c=null,u=null,d=null,p=!1,f=null,m=null,g=null,v=null,x=null,y=null;const _=[],M=new Map,b=new On;b.layers.enable(1),b.viewport=new st;const w=new On;w.layers.enable(2),w.viewport=new st;const S=[b,w],E=new ds;E.layers.enable(1),E.layers.enable(2);let T=null,L=null;function C(t){const e=M.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function A(){M.forEach((function(t,e){t.disconnect(e)})),M.clear(),T=null,L=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),c&&e.deleteFramebuffer(c),f&&e.deleteFramebuffer(f),m&&e.deleteRenderbuffer(m),g&&e.deleteRenderbuffer(g),c=null,f=null,m=null,g=null,d=null,u=null,h=null,r=null,z.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function R(t){const e=r.inputSources;for(let t=0;t<_.length;t++)M.set(e[t],_[t]);for(let e=0;e<t.removed.length;e++){const n=t.removed[e],i=M.get(n);i&&(i.dispatchEvent({type:"disconnected",data:n}),M.delete(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e],i=M.get(n);i&&i.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=_[t];return void 0===e&&(e=new ms,_[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=_[t];return void 0===e&&(e=new ms,_[t]=e),e.getGripSpace()},this.getHand=function(t){let e=_[t];return void 0===e&&(e=new ms,_[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){s=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return h},this.getFrame=function(){return v},this.getSession=function(){return r},this.setSession=async function(t){if(r=t,null!==r){r.addEventListener("select",C),r.addEventListener("selectstart",C),r.addEventListener("selectend",C),r.addEventListener("squeeze",C),r.addEventListener("squeezestart",C),r.addEventListener("squeezeend",C),r.addEventListener("end",A),r.addEventListener("inputsourceschange",R);const t=e.getContextAttributes();if(!0!==t.xrCompatible&&await e.makeXRCompatible(),void 0===r.renderState.layers){const n={antialias:t.antialias,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(r,e,n),r.updateRenderState({baseLayer:d})}else if(e instanceof WebGLRenderingContext){const n={antialias:!0,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(r,e,n),r.updateRenderState({layers:[d]})}else{p=t.antialias;let n=null;t.depth&&(y=e.DEPTH_BUFFER_BIT,t.stencil&&(y|=e.STENCIL_BUFFER_BIT),x=t.stencil?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,n=t.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24);const a={colorFormat:t.alpha?e.RGBA8:e.RGB8,depthFormat:n,scaleFactor:s};h=new XRWebGLBinding(r,e),u=h.createProjectionLayer(a),c=e.createFramebuffer(),r.updateRenderState({layers:[u]}),p&&(f=e.createFramebuffer(),m=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,m),e.renderbufferStorageMultisample(e.RENDERBUFFER,4,e.RGBA8,u.textureWidth,u.textureHeight),i.bindFramebuffer(e.FRAMEBUFFER,f),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,m),e.bindRenderbuffer(e.RENDERBUFFER,null),null!==n&&(g=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,g),e.renderbufferStorageMultisample(e.RENDERBUFFER,4,n,u.textureWidth,u.textureHeight),e.framebufferRenderbuffer(e.FRAMEBUFFER,x,e.RENDERBUFFER,g),e.bindRenderbuffer(e.RENDERBUFFER,null)),i.bindFramebuffer(e.FRAMEBUFFER,null))}a=await r.requestReferenceSpace(o),z.setContext(r),z.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const P=new lt,D=new lt;function I(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===r)return;E.near=w.near=b.near=t.near,E.far=w.far=b.far=t.far,T===E.near&&L===E.far||(r.updateRenderState({depthNear:E.near,depthFar:E.far}),T=E.near,L=E.far);const e=t.parent,n=E.cameras;I(E,e);for(let t=0;t<n.length;t++)I(n[t],e);E.matrixWorld.decompose(E.position,E.quaternion,E.scale),t.position.copy(E.position),t.quaternion.copy(E.quaternion),t.scale.copy(E.scale),t.matrix.copy(E.matrix),t.matrixWorld.copy(E.matrixWorld);const i=t.children;for(let t=0,e=i.length;t<e;t++)i[t].updateMatrixWorld(!0);2===n.length?function(t,e,n){P.setFromMatrixPosition(e.matrixWorld),D.setFromMatrixPosition(n.matrixWorld);const i=P.distanceTo(D),r=e.projectionMatrix.elements,s=n.projectionMatrix.elements,a=r[14]/(r[10]-1),o=r[14]/(r[10]+1),l=(r[9]+1)/r[5],h=(r[9]-1)/r[5],c=(r[8]-1)/r[0],u=(s[8]+1)/s[0],d=a*c,p=a*u,f=i/(-c+u),m=f*-c;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=a+f,v=o+f,x=d-m,y=p+(i-m),_=l*o/v*g,M=h*o/v*g;t.projectionMatrix.makePerspective(x,y,_,M,g,v)}(E,b,w):E.projectionMatrix.copy(b.projectionMatrix)},this.getCamera=function(){return E},this.getFoveation=function(){return null!==u?u.fixedFoveation:null!==d?d.fixedFoveation:void 0},this.setFoveation=function(t){null!==u&&(u.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)};let N=null;const z=new Xt;z.setAnimationLoop((function(t,n){if(l=n.getViewerPose(a),v=n,null!==l){const t=l.views;null!==d&&i.bindXRFramebuffer(d.framebuffer);let n=!1;t.length!==E.cameras.length&&(E.cameras.length=0,n=!0);for(let r=0;r<t.length;r++){const s=t[r];let a=null;if(null!==d)a=d.getViewport(s);else{const t=h.getViewSubImage(u,s);i.bindXRFramebuffer(c),void 0!==t.depthStencilTexture&&e.framebufferTexture2D(e.FRAMEBUFFER,x,e.TEXTURE_2D,t.depthStencilTexture,0),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t.colorTexture,0),a=t.viewport}const o=S[r];o.matrix.fromArray(s.transform.matrix),o.projectionMatrix.fromArray(s.projectionMatrix),o.viewport.set(a.x,a.y,a.width,a.height),0===r&&E.matrix.copy(o.matrix),!0===n&&E.cameras.push(o)}p&&(i.bindXRFramebuffer(f),null!==y&&e.clear(y))}const s=r.inputSources;for(let t=0;t<_.length;t++){const e=_[t],i=s[t];e.update(i,n,a)}if(N&&N(t,n),p){const t=u.textureWidth,n=u.textureHeight;i.bindFramebuffer(e.READ_FRAMEBUFFER,f),i.bindFramebuffer(e.DRAW_FRAMEBUFFER,c),e.invalidateFramebuffer(e.READ_FRAMEBUFFER,[x]),e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER,[x]),e.blitFramebuffer(0,0,t,n,0,0,t,n,e.COLOR_BUFFER_BIT,e.NEAREST),e.invalidateFramebuffer(e.READ_FRAMEBUFFER,[e.COLOR_ATTACHMENT0]),i.bindFramebuffer(e.READ_FRAMEBUFFER,null),i.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),i.bindFramebuffer(e.FRAMEBUFFER,f)}v=null})),this.setAnimationLoop=function(t){N=t},this.dispose=function(){}}}function vs(t){function e(e,n){e.opacity.value=n.opacity,n.color&&e.diffuse.value.copy(n.color),n.emissive&&e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.specularMap&&(e.specularMap.value=n.specularMap),n.alphaTest>0&&(e.alphaTest.value=n.alphaTest);const i=t.get(n).envMap;if(i){e.envMap.value=i,e.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,e.reflectivity.value=n.reflectivity,e.ior.value=n.ior,e.refractionRatio.value=n.refractionRatio;const r=t.get(i).__maxMipLevel;void 0!==r&&(e.maxMipLevel.value=r)}let r,s;n.lightMap&&(e.lightMap.value=n.lightMap,e.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(e.aoMap.value=n.aoMap,e.aoMapIntensity.value=n.aoMapIntensity),n.map?r=n.map:n.specularMap?r=n.specularMap:n.displacementMap?r=n.displacementMap:n.normalMap?r=n.normalMap:n.bumpMap?r=n.bumpMap:n.roughnessMap?r=n.roughnessMap:n.metalnessMap?r=n.metalnessMap:n.alphaMap?r=n.alphaMap:n.emissiveMap?r=n.emissiveMap:n.clearcoatMap?r=n.clearcoatMap:n.clearcoatNormalMap?r=n.clearcoatNormalMap:n.clearcoatRoughnessMap?r=n.clearcoatRoughnessMap:n.specularIntensityMap?r=n.specularIntensityMap:n.specularTintMap?r=n.specularTintMap:n.transmissionMap?r=n.transmissionMap:n.thicknessMap&&(r=n.thicknessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uvTransform.value.copy(r.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),e.uv2Transform.value.copy(s.matrix))}function n(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(e.emissiveMap.value=n.emissiveMap),n.bumpMap&&(e.bumpMap.value=n.bumpMap,e.bumpScale.value=n.bumpScale,1===n.side&&(e.bumpScale.value*=-1)),n.normalMap&&(e.normalMap.value=n.normalMap,e.normalScale.value.copy(n.normalScale),1===n.side&&e.normalScale.value.negate()),n.displacementMap&&(e.displacementMap.value=n.displacementMap,e.displacementScale.value=n.displacementScale,e.displacementBias.value=n.displacementBias);t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,i,r,s,a){i.isMeshBasicMaterial?e(t,i):i.isMeshLambertMaterial?(e(t,i),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,i)):i.isMeshToonMaterial?(e(t,i),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap);e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshPhongMaterial?(e(t,i),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshStandardMaterial?(e(t,i),i.isMeshPhysicalMaterial?function(t,e,i){n(t,e),t.ior.value=e.ior,e.sheenTint&&t.sheenTint.value.copy(e.sheenTint);e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,1===e.side&&t.clearcoatNormalScale.value.negate()));e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=i.texture,t.transmissionSamplerSize.value.set(i.width,i.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap),t.attenuationDistance.value=e.attenuationDistance,t.attenuationTint.value.copy(e.attenuationTint));t.specularIntensity.value=e.specularIntensity,t.specularTint.value.copy(e.specularTint),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap);e.specularTintMap&&(t.specularTintMap.value=e.specularTintMap)}(t,i,a):n(t,i)):i.isMeshMatcapMaterial?(e(t,i),function(t,e){e.matcap&&(t.matcap.value=e.matcap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDepthMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDistanceMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias);t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,i)):i.isMeshNormalMaterial?(e(t,i),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,i),i.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,i)):i.isPointsMaterial?function(t,e,n,i){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*i,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);e.alphaTest>0&&(t.alphaTest.value=e.alphaTest);let r;e.map?r=e.map:e.alphaMap&&(r=e.alphaMap);void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uvTransform.value.copy(r.matrix))}(t,i,r,s):i.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);e.alphaTest>0&&(t.alphaTest.value=e.alphaTest);let n;e.map?n=e.map:e.alphaMap&&(n=e.alphaMap);void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,i):i.isShadowMaterial?(t.color.value.copy(i.color),t.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function xs(t={}){const e=void 0!==t.canvas?t.canvas:function(){const t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,i=void 0!==t.alpha&&t.alpha,r=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,a=void 0!==t.antialias&&t.antialias,o=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,h=void 0!==t.powerPreference?t.powerPreference:"default",c=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let u=null,d=null;const p=[],f=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=F,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const m=this;let g=!1,v=0,x=0,y=null,_=-1,b=null;const S=new st,L=new st;let C=null,P=e.width,D=e.height,N=1,z=null,O=null;const U=new st(0,0,P,D),B=new st(0,0,P,D);let k=!1;const H=[],G=new Ot;let V=!1,W=!1,j=null;const X=new Ut,q=new lt,Y={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Z(){return null===y?N:1}let J,Q,K,$,tt,et,nt,it,rt,ot,ht,ct,ut,dt,pt,ft,mt,gt,vt,xt,yt,_t,Mt,bt=n;function wt(t,n){for(let i=0;i<t.length;i++){const r=t[i],s=e.getContext(r,n);if(null!==s)return s}return null}try{const t={alpha:i,depth:r,stencil:s,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:h,failIfMajorPerformanceCaveat:c};if(e.addEventListener("webglcontextlost",Tt,!1),e.addEventListener("webglcontextrestored",Lt,!1),null===bt){const e=["webgl2","webgl","experimental-webgl"];if(!0===m.isWebGL1Renderer&&e.shift(),bt=wt(e,t),null===bt)throw wt(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===bt.getShaderPrecisionFormat&&(bt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function St(){J=new mi(bt),Q=new Nn(bt,J,t),J.init(Q),_t=new us(bt,J,Q),K=new hs(bt,J,Q),H[0]=bt.BACK,$=new xi(bt),tt=new Zr,et=new cs(bt,J,K,tt,Q,_t,$),nt=new Gn(m),it=new fi(m),rt=new qt(bt,Q),Mt=new Dn(bt,J,rt,Q),ot=new gi(bt,rt,$,Mt),ht=new wi(bt,ot,rt,$),vt=new Mi(bt),ft=new zn(tt),ct=new Yr(m,nt,it,J,Q,Mt,ft),ut=new vs(tt),dt=new $r(tt),pt=new ss(J,Q),gt=new Pn(m,nt,K,ht,o),mt=new ls(m,ht,Q),xt=new In(bt,J,$,Q),yt=new vi(bt,J,$,Q),$.programs=ct.programs,m.capabilities=Q,m.extensions=J,m.properties=tt,m.renderLists=dt,m.shadowMap=mt,m.state=K,m.info=$}St();const Et=new gs(m,bt);function Tt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),g=!0}function Lt(){console.log("THREE.WebGLRenderer: Context Restored."),g=!1;const t=$.autoReset,e=mt.enabled,n=mt.autoUpdate,i=mt.needsUpdate,r=mt.type;St(),$.autoReset=t,mt.enabled=e,mt.autoUpdate=n,mt.needsUpdate=i,mt.type=r}function Ct(t){const e=t.target;e.removeEventListener("dispose",Ct),function(t){(function(t){const e=tt.get(t).programs;void 0!==e&&e.forEach((function(t){ct.releaseProgram(t)}))})(t),tt.remove(t)}(e)}this.xr=Et,this.getContext=function(){return bt},this.getContextAttributes=function(){return bt.getContextAttributes()},this.forceContextLoss=function(){const t=J.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=J.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return N},this.setPixelRatio=function(t){void 0!==t&&(N=t,this.setSize(P,D,!1))},this.getSize=function(t){return t.set(P,D)},this.setSize=function(t,n,i){Et.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(P=t,D=n,e.width=Math.floor(t*N),e.height=Math.floor(n*N),!1!==i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(P*N,D*N).floor()},this.setDrawingBufferSize=function(t,n,i){P=t,D=n,N=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(S)},this.getViewport=function(t){return t.copy(U)},this.setViewport=function(t,e,n,i){t.isVector4?U.set(t.x,t.y,t.z,t.w):U.set(t,e,n,i),K.viewport(S.copy(U).multiplyScalar(N).floor())},this.getScissor=function(t){return t.copy(B)},this.setScissor=function(t,e,n,i){t.isVector4?B.set(t.x,t.y,t.z,t.w):B.set(t,e,n,i),K.scissor(L.copy(B).multiplyScalar(N).floor())},this.getScissorTest=function(){return k},this.setScissorTest=function(t){K.setScissorTest(k=t)},this.setOpaqueSort=function(t){z=t},this.setTransparentSort=function(t){O=t},this.getClearColor=function(t){return t.copy(gt.getClearColor())},this.setClearColor=function(){gt.setClearColor.apply(gt,arguments)},this.getClearAlpha=function(){return gt.getClearAlpha()},this.setClearAlpha=function(){gt.setClearAlpha.apply(gt,arguments)},this.clear=function(t,e,n){let i=0;(void 0===t||t)&&(i|=bt.COLOR_BUFFER_BIT),(void 0===e||e)&&(i|=bt.DEPTH_BUFFER_BIT),(void 0===n||n)&&(i|=bt.STENCIL_BUFFER_BIT),bt.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Tt,!1),e.removeEventListener("webglcontextrestored",Lt,!1),dt.dispose(),pt.dispose(),tt.dispose(),nt.dispose(),it.dispose(),ht.dispose(),Mt.dispose(),Et.dispose(),Et.removeEventListener("sessionstart",Rt),Et.removeEventListener("sessionend",Pt),j&&(j.dispose(),j=null),Dt.stop()},this.renderBufferImmediate=function(t,e){Mt.initAttributes();const n=tt.get(t);t.hasPositions&&!n.position&&(n.position=bt.createBuffer()),t.hasNormals&&!n.normal&&(n.normal=bt.createBuffer()),t.hasUvs&&!n.uv&&(n.uv=bt.createBuffer()),t.hasColors&&!n.color&&(n.color=bt.createBuffer());const i=e.getAttributes();t.hasPositions&&(bt.bindBuffer(bt.ARRAY_BUFFER,n.position),bt.bufferData(bt.ARRAY_BUFFER,t.positionArray,bt.DYNAMIC_DRAW),Mt.enableAttribute(i.position.location),bt.vertexAttribPointer(i.position.location,3,bt.FLOAT,!1,0,0)),t.hasNormals&&(bt.bindBuffer(bt.ARRAY_BUFFER,n.normal),bt.bufferData(bt.ARRAY_BUFFER,t.normalArray,bt.DYNAMIC_DRAW),Mt.enableAttribute(i.normal.location),bt.vertexAttribPointer(i.normal.location,3,bt.FLOAT,!1,0,0)),t.hasUvs&&(bt.bindBuffer(bt.ARRAY_BUFFER,n.uv),bt.bufferData(bt.ARRAY_BUFFER,t.uvArray,bt.DYNAMIC_DRAW),Mt.enableAttribute(i.uv.location),bt.vertexAttribPointer(i.uv.location,2,bt.FLOAT,!1,0,0)),t.hasColors&&(bt.bindBuffer(bt.ARRAY_BUFFER,n.color),bt.bufferData(bt.ARRAY_BUFFER,t.colorArray,bt.DYNAMIC_DRAW),Mt.enableAttribute(i.color.location),bt.vertexAttribPointer(i.color.location,3,bt.FLOAT,!1,0,0)),Mt.disableUnusedAttributes(),bt.drawArrays(bt.TRIANGLES,0,t.count),t.count=0},this.renderBufferDirect=function(t,e,n,i,r,s){null===e&&(e=Y);const a=r.isMesh&&r.matrixWorld.determinant()<0,o=Ht(t,e,i,r);K.setMaterial(i,a);let l=n.index;const h=n.attributes.position;if(null===l){if(void 0===h||0===h.count)return}else if(0===l.count)return;let c,u=1;!0===i.wireframe&&(l=ot.getWireframeAttribute(n),u=2),void 0===n.morphAttributes.position&&void 0===n.morphAttributes.normal||vt.update(r,n,i,o),Mt.setup(r,i,o,n,l);let d=xt;null!==l&&(c=rt.get(l),d=yt,d.setIndex(c));const p=null!==l?l.count:h.count,f=n.drawRange.start*u,m=n.drawRange.count*u,g=null!==s?s.start*u:0,v=null!==s?s.count*u:1/0,x=Math.max(f,g),y=Math.min(p,f+m,g+v)-1,_=Math.max(0,y-x+1);if(0!==_){if(r.isMesh)!0===i.wireframe?(K.setLineWidth(i.wireframeLinewidth*Z()),d.setMode(bt.LINES)):d.setMode(bt.TRIANGLES);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),K.setLineWidth(t*Z()),r.isLineSegments?d.setMode(bt.LINES):r.isLineLoop?d.setMode(bt.LINE_LOOP):d.setMode(bt.LINE_STRIP)}else r.isPoints?d.setMode(bt.POINTS):r.isSprite&&d.setMode(bt.TRIANGLES);if(r.isInstancedMesh)d.renderInstances(x,_,r.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(x,_,t)}else d.render(x,_)}},this.compile=function(t,e){d=pt.get(t),d.init(),f.push(d),t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(d.pushLight(t),t.castShadow&&d.pushShadow(t))})),d.setupLights(m.physicallyCorrectLights),t.traverse((function(e){const n=e.material;if(n)if(Array.isArray(n))for(let i=0;i<n.length;i++){Bt(n[i],t,e)}else Bt(n,t,e)})),f.pop(),d=null};let At=null;function Rt(){Dt.stop()}function Pt(){Dt.start()}const Dt=new Xt;function It(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)d.pushLight(t),t.castShadow&&d.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||G.intersectsSprite(t)){i&&q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(X);const e=ht.update(t),r=t.material;r.visible&&u.push(t,e,r,n,q.z,null)}}else if(t.isImmediateRenderObject)i&&q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(X),u.push(t,null,t.material,n,q.z,null);else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==$.render.frame&&(t.skeleton.update(),t.skeleton.frame=$.render.frame),!t.frustumCulled||G.intersectsObject(t))){i&&q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(X);const e=ht.update(t),r=t.material;if(Array.isArray(r)){const i=e.groups;for(let s=0,a=i.length;s<a;s++){const a=i[s],o=r[a.materialIndex];o&&o.visible&&u.push(t,e,o,n,q.z,a)}}else r.visible&&u.push(t,e,r,n,q.z,null)}const r=t.children;for(let t=0,s=r.length;t<s;t++)It(r[t],e,n,i)}function Nt(t,e,n,i){const r=t.opaque,s=t.transmissive,o=t.transparent;d.setupLightsView(n),s.length>0&&function(t,e,n){if(null===j){const t=!0===a&&!0===Q.isWebGL2;j=new(t?bi:at)(1024,1024,{generateMipmaps:!0,type:null!==_t.convert(R)?R:T,minFilter:E,magFilter:w,wrapS:M,wrapT:M})}const i=m.getRenderTarget();m.setRenderTarget(j),m.clear();const r=m.toneMapping;m.toneMapping=0,zt(t,e,n),m.toneMapping=r,et.updateMultisampleRenderTarget(j),et.updateRenderTargetMipmap(j),m.setRenderTarget(i)}(r,e,n),i&&K.viewport(S.copy(i)),r.length>0&&zt(r,e,n),s.length>0&&zt(s,e,n),o.length>0&&zt(o,e,n)}function zt(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,s=t.length;r<s;r++){const s=t[r],a=s.object,o=s.geometry,l=null===i?s.material:i,h=s.group;a.layers.test(n.layers)&&Ft(a,e,n,o,l,h)}}function Ft(t,e,n,i,r,s){if(t.onBeforeRender(m,e,n,i,r,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){const i=Ht(n,e,r,t);K.setMaterial(r),Mt.reset(),function(t,e){t.render((function(t){m.renderBufferImmediate(t,e)}))}(t,i)}else!0===r.transparent&&2===r.side?(r.side=1,r.needsUpdate=!0,m.renderBufferDirect(n,e,i,r,t,s),r.side=0,r.needsUpdate=!0,m.renderBufferDirect(n,e,i,r,t,s),r.side=2):m.renderBufferDirect(n,e,i,r,t,s);t.onAfterRender(m,e,n,i,r,s)}function Bt(t,e,n){!0!==e.isScene&&(e=Y);const i=tt.get(t),r=d.state.lights,s=d.state.shadowsArray,a=r.state.version,o=ct.getParameters(t,r.state,s,e,n),l=ct.getProgramCacheKey(o);let h=i.programs;i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=(t.isMeshStandardMaterial?it:nt).get(t.envMap||i.environment),void 0===h&&(t.addEventListener("dispose",Ct),h=new Map,i.programs=h);let c=h.get(l);if(void 0!==c){if(i.currentProgram===c&&i.lightsStateVersion===a)return kt(t,o),c}else o.uniforms=ct.getUniforms(t),t.onBuild(o,m),t.onBeforeCompile(o,m),c=ct.acquireProgram(o,l),h.set(l,c),i.uniforms=o.uniforms;const u=i.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=ft.uniform),kt(t,o),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=a,i.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotShadowMatrix.value=r.state.spotShadowMatrix,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix);const p=c.getUniforms(),f=Lr.seqWithValue(p.seq,u);return i.currentProgram=c,i.uniformsList=f,c}function kt(t,e){const n=tt.get(t);n.outputEncoding=e.outputEncoding,n.instancing=e.instancing,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents}function Ht(t,e,n,i){!0!==e.isScene&&(e=Y),et.resetTextureUnits();const r=e.fog,s=n.isMeshStandardMaterial?e.environment:null,a=null===y?m.outputEncoding:y.texture.encoding,o=(n.isMeshStandardMaterial?it:nt).get(n.envMap||s),l=!0===n.vertexColors&&!!i.geometry&&!!i.geometry.attributes.color&&4===i.geometry.attributes.color.itemSize,h=!!i.geometry&&!!i.geometry.attributes.tangent,c=!!i.geometry&&!!i.geometry.morphAttributes.position,u=!!i.geometry&&!!i.geometry.morphAttributes.normal,p=tt.get(n),f=d.state.lights;if(!0===V&&(!0===W||t!==b)){const e=t===b&&n.id===_;ft.setState(n,t,e)}let g=!1;n.version===p.__version?p.needsLights&&p.lightsStateVersion!==f.state.version||p.outputEncoding!==a||i.isInstancedMesh&&!1===p.instancing?g=!0:i.isInstancedMesh||!0!==p.instancing?i.isSkinnedMesh&&!1===p.skinning?g=!0:i.isSkinnedMesh||!0!==p.skinning?p.envMap!==o||n.fog&&p.fog!==r?g=!0:void 0===p.numClippingPlanes||p.numClippingPlanes===ft.numPlanes&&p.numIntersection===ft.numIntersection?(p.vertexAlphas!==l||p.vertexTangents!==h||p.morphTargets!==c||p.morphNormals!==u)&&(g=!0):g=!0:g=!0:g=!0:(g=!0,p.__version=n.version);let v=p.currentProgram;!0===g&&(v=Bt(n,e,i));let x=!1,M=!1,w=!1;const S=v.getUniforms(),E=p.uniforms;if(K.useProgram(v.program)&&(x=!0,M=!0,w=!0),n.id!==_&&(_=n.id,M=!0),x||b!==t){if(S.setValue(bt,"projectionMatrix",t.projectionMatrix),Q.logarithmicDepthBuffer&&S.setValue(bt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),b!==t&&(b=t,M=!0,w=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const e=S.map.cameraPosition;void 0!==e&&e.setValue(bt,q.setFromMatrixPosition(t.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&S.setValue(bt,"isOrthographic",!0===t.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||i.isSkinnedMesh)&&S.setValue(bt,"viewMatrix",t.matrixWorldInverse)}if(i.isSkinnedMesh){S.setOptional(bt,i,"bindMatrix"),S.setOptional(bt,i,"bindMatrixInverse");const t=i.skeleton;t&&(Q.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),S.setValue(bt,"boneTexture",t.boneTexture,et),S.setValue(bt,"boneTextureSize",t.boneTextureSize)):S.setOptional(bt,t,"boneMatrices"))}return(M||p.receiveShadow!==i.receiveShadow)&&(p.receiveShadow=i.receiveShadow,S.setValue(bt,"receiveShadow",i.receiveShadow)),M&&(S.setValue(bt,"toneMappingExposure",m.toneMappingExposure),p.needsLights&&function(t,e){t.ambientLightColor.needsUpdate=e,t.lightProbe.needsUpdate=e,t.directionalLights.needsUpdate=e,t.directionalLightShadows.needsUpdate=e,t.pointLights.needsUpdate=e,t.pointLightShadows.needsUpdate=e,t.spotLights.needsUpdate=e,t.spotLightShadows.needsUpdate=e,t.rectAreaLights.needsUpdate=e,t.hemisphereLights.needsUpdate=e}(E,w),r&&n.fog&&ut.refreshFogUniforms(E,r),ut.refreshMaterialUniforms(E,n,N,D,j),Lr.upload(bt,p.uniformsList,E,et)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(Lr.upload(bt,p.uniformsList,E,et),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&S.setValue(bt,"center",i.center),S.setValue(bt,"modelViewMatrix",i.modelViewMatrix),S.setValue(bt,"normalMatrix",i.normalMatrix),S.setValue(bt,"modelMatrix",i.matrixWorld),v}Dt.setAnimationLoop((function(t){At&&At(t)})),"undefined"!=typeof window&&Dt.setContext(window),this.setAnimationLoop=function(t){At=t,Et.setAnimationLoop(t),null===t?Dt.stop():Dt.start()},Et.addEventListener("sessionstart",Rt),Et.addEventListener("sessionend",Pt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===g)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===Et.enabled&&!0===Et.isPresenting&&(!0===Et.cameraAutoUpdate&&Et.updateCamera(e),e=Et.getCamera()),!0===t.isScene&&t.onBeforeRender(m,t,e,y),d=pt.get(t,f.length),d.init(),f.push(d),X.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),G.setFromProjectionMatrix(X),W=this.localClippingEnabled,V=ft.init(this.clippingPlanes,W,e),u=dt.get(t,p.length),u.init(),p.push(u),It(t,e,0,m.sortObjects),u.finish(),!0===m.sortObjects&&u.sort(z,O),!0===V&&ft.beginShadows();const n=d.state.shadowsArray;if(mt.render(n,t,e),!0===V&&ft.endShadows(),!0===this.info.autoReset&&this.info.reset(),gt.render(u,t),d.setupLights(m.physicallyCorrectLights),e.isArrayCamera){const n=e.cameras;for(let e=0,i=n.length;e<i;e++){const i=n[e];Nt(u,t,i,i.viewport)}}else Nt(u,t,e);null!==y&&(et.updateMultisampleRenderTarget(y),et.updateRenderTargetMipmap(y)),!0===t.isScene&&t.onAfterRender(m,t,e),K.buffers.depth.setTest(!0),K.buffers.depth.setMask(!0),K.buffers.color.setMask(!0),K.setPolygonOffset(!1),Mt.resetDefaultState(),_=-1,b=null,f.pop(),d=f.length>0?f[f.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=function(){return v},this.getActiveMipmapLevel=function(){return x},this.getRenderTarget=function(){return y},this.setRenderTarget=function(t,e=0,n=0){y=t,v=e,x=n,t&&void 0===tt.get(t).__webglFramebuffer&&et.setupRenderTarget(t);let i=null,r=!1,s=!1;if(t){const n=t.texture;(n.isDataTexture3D||n.isDataTexture2DArray)&&(s=!0);const a=tt.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=a[e],r=!0):i=t.isWebGLMultisampleRenderTarget?tt.get(t).__webglMultisampledFramebuffer:a,S.copy(t.viewport),L.copy(t.scissor),C=t.scissorTest}else S.copy(U).multiplyScalar(N).floor(),L.copy(B).multiplyScalar(N).floor(),C=k;if(K.bindFramebuffer(bt.FRAMEBUFFER,i)&&Q.drawBuffers){let e=!1;if(t)if(t.isWebGLMultipleRenderTargets){const n=t.texture;if(H.length!==n.length||H[0]!==bt.COLOR_ATTACHMENT0){for(let t=0,e=n.length;t<e;t++)H[t]=bt.COLOR_ATTACHMENT0+t;H.length=n.length,e=!0}}else 1===H.length&&H[0]===bt.COLOR_ATTACHMENT0||(H[0]=bt.COLOR_ATTACHMENT0,H.length=1,e=!0);else 1===H.length&&H[0]===bt.BACK||(H[0]=bt.BACK,H.length=1,e=!0);e&&(Q.isWebGL2?bt.drawBuffers(H):J.get("WEBGL_draw_buffers").drawBuffersWEBGL(H))}if(K.viewport(S),K.scissor(L),K.setScissorTest(C),r){const i=tt.get(t.texture);bt.framebufferTexture2D(bt.FRAMEBUFFER,bt.COLOR_ATTACHMENT0,bt.TEXTURE_CUBE_MAP_POSITIVE_X+e,i.__webglTexture,n)}else if(s){const i=tt.get(t.texture),r=e||0;bt.framebufferTextureLayer(bt.FRAMEBUFFER,bt.COLOR_ATTACHMENT0,i.__webglTexture,n||0,r)}_=-1},this.readRenderTargetPixels=function(t,e,n,i,r,s,a){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=tt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){K.bindFramebuffer(bt.FRAMEBUFFER,o);try{const a=t.texture,o=a.format,l=a.type;if(o!==I&&_t.convert(o)!==bt.getParameter(bt.IMPLEMENTATION_COLOR_READ_FORMAT))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const h=l===R&&(J.has("EXT_color_buffer_half_float")||Q.isWebGL2&&J.has("EXT_color_buffer_float"));if(!(l===T||_t.convert(l)===bt.getParameter(bt.IMPLEMENTATION_COLOR_READ_TYPE)||l===A&&(Q.isWebGL2||J.has("OES_texture_float")||J.has("WEBGL_color_buffer_float"))||h))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");bt.checkFramebufferStatus(bt.FRAMEBUFFER)===bt.FRAMEBUFFER_COMPLETE?e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&bt.readPixels(e,n,i,r,_t.convert(o),_t.convert(l),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const t=null!==y?tt.get(y).__webglFramebuffer:null;K.bindFramebuffer(bt.FRAMEBUFFER,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){const i=Math.pow(2,-n),r=Math.floor(e.image.width*i),s=Math.floor(e.image.height*i);let a=_t.convert(e.format);Q.isWebGL2&&(a===bt.RGB&&(a=bt.RGB8),a===bt.RGBA&&(a=bt.RGBA8)),et.setTexture2D(e,0),bt.copyTexImage2D(bt.TEXTURE_2D,n,a,t.x,t.y,r,s,0),K.unbindTexture()},this.copyTextureToTexture=function(t,e,n,i=0){const r=e.image.width,s=e.image.height,a=_t.convert(n.format),o=_t.convert(n.type);et.setTexture2D(n,0),bt.pixelStorei(bt.UNPACK_FLIP_Y_WEBGL,n.flipY),bt.pixelStorei(bt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,n.premultiplyAlpha),bt.pixelStorei(bt.UNPACK_ALIGNMENT,n.unpackAlignment),e.isDataTexture?bt.texSubImage2D(bt.TEXTURE_2D,i,t.x,t.y,r,s,a,o,e.image.data):e.isCompressedTexture?bt.compressedTexSubImage2D(bt.TEXTURE_2D,i,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,a,e.mipmaps[0].data):bt.texSubImage2D(bt.TEXTURE_2D,i,t.x,t.y,a,o,e.image),0===i&&n.generateMipmaps&&bt.generateMipmap(bt.TEXTURE_2D),K.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,i,r=0){if(m.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=t.max.x-t.min.x+1,a=t.max.y-t.min.y+1,o=t.max.z-t.min.z+1,l=_t.convert(i.format),h=_t.convert(i.type);let c;if(i.isDataTexture3D)et.setTexture3D(i,0),c=bt.TEXTURE_3D;else{if(!i.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");et.setTexture2DArray(i,0),c=bt.TEXTURE_2D_ARRAY}bt.pixelStorei(bt.UNPACK_FLIP_Y_WEBGL,i.flipY),bt.pixelStorei(bt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i.premultiplyAlpha),bt.pixelStorei(bt.UNPACK_ALIGNMENT,i.unpackAlignment);const u=bt.getParameter(bt.UNPACK_ROW_LENGTH),d=bt.getParameter(bt.UNPACK_IMAGE_HEIGHT),p=bt.getParameter(bt.UNPACK_SKIP_PIXELS),f=bt.getParameter(bt.UNPACK_SKIP_ROWS),g=bt.getParameter(bt.UNPACK_SKIP_IMAGES),v=n.isCompressedTexture?n.mipmaps[0]:n.image;bt.pixelStorei(bt.UNPACK_ROW_LENGTH,v.width),bt.pixelStorei(bt.UNPACK_IMAGE_HEIGHT,v.height),bt.pixelStorei(bt.UNPACK_SKIP_PIXELS,t.min.x),bt.pixelStorei(bt.UNPACK_SKIP_ROWS,t.min.y),bt.pixelStorei(bt.UNPACK_SKIP_IMAGES,t.min.z),n.isDataTexture||n.isDataTexture3D?bt.texSubImage3D(c,r,e.x,e.y,e.z,s,a,o,l,h,v.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),bt.compressedTexSubImage3D(c,r,e.x,e.y,e.z,s,a,o,l,v.data)):bt.texSubImage3D(c,r,e.x,e.y,e.z,s,a,o,l,h,v),bt.pixelStorei(bt.UNPACK_ROW_LENGTH,u),bt.pixelStorei(bt.UNPACK_IMAGE_HEIGHT,d),bt.pixelStorei(bt.UNPACK_SKIP_PIXELS,p),bt.pixelStorei(bt.UNPACK_SKIP_ROWS,f),bt.pixelStorei(bt.UNPACK_SKIP_IMAGES,g),0===r&&i.generateMipmaps&&bt.generateMipmap(c),K.unbindTexture()},this.initTexture=function(t){et.setTexture2D(t,0),K.unbindTexture()},this.resetState=function(){v=0,x=0,y=null,K.reset(),Mt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class ys{constructor(t,e=25e-5){this.name="",this.color=new te(t),this.density=e}clone(){return new ys(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}ys.prototype.isFogExp2=!0;class _s extends Se{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}_s.prototype.isScene=!0;class Ms extends Oe{constructor(t){super(),this.type="LineBasicMaterial",this.color=new te(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}Ms.prototype.isLineBasicMaterial=!0;class bs extends Oe{constructor(t){super(),this.type="PointsMaterial",this.color=new te(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}bs.prototype.isPointsMaterial=!0;const ws=new Ut,Ss=new Ze,Es=new Rt,Ts=new lt;class Ls extends Se{constructor(t=new Ie,e=new bs){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Es.copy(n.boundingSphere),Es.applyMatrix4(i),Es.radius+=r,!1===t.ray.intersectsSphere(Es))return;ws.copy(i).invert(),Ss.copy(t.ray).applyMatrix4(ws);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a;if(n.isBufferGeometry){const r=n.index,a=n.attributes.position;if(null!==r){for(let n=Math.max(0,s.start),l=Math.min(r.count,s.start+s.count);n<l;n++){const s=r.getX(n);Ts.fromBufferAttribute(a,s),Cs(Ts,s,o,i,t,e,this)}}else{for(let n=Math.max(0,s.start),r=Math.min(a.count,s.start+s.count);n<r;n++)Ts.fromBufferAttribute(a,n),Cs(Ts,n,o,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function Cs(t,e,n,i,r,s,a){const o=Ss.distanceSqToPoint(t);if(o<n){const n=new lt;Ss.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:e,face:null,object:a})}}Ls.prototype.isPoints=!0;class As extends it{constructor(t=null,e=1,n=1,i,r,s,a,o,l=1003,h=1003,c,u){super(null,s,a,o,l,h,i,r,c,u),this.image={data:t,width:e,height:n},this.magFilter=l,this.minFilter=h,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}As.prototype.isDataTexture=!0;class Rs extends it{constructor(t,e,n,i,r,s,a,o,l){super(t,e,n,i,r,s,a,o,l),this.needsUpdate=!0}}Rs.prototype.isCanvasTexture=!0;class Ps extends Ie{constructor(t=1,e=32,n=16,i=0,r=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:s,thetaLength:a},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const o=Math.min(s+a,Math.PI);let l=0;const h=[],c=new lt,u=new lt,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],v=d/n;let x=0;0==d&&0==s?x=.5/e:d==n&&o==Math.PI&&(x=-.5/e);for(let n=0;n<=e;n++){const o=n/e;c.x=-t*Math.cos(i+o*r)*Math.sin(s+v*a),c.y=t*Math.cos(s+v*a),c.z=t*Math.sin(i+o*r)*Math.sin(s+v*a),p.push(c.x,c.y,c.z),u.copy(c).normalize(),f.push(u.x,u.y,u.z),m.push(o+x,1-v),g.push(l++)}h.push(g)}for(let t=0;t<n;t++)for(let i=0;i<e;i++){const e=h[t][i+1],r=h[t][i],a=h[t+1][i],l=h[t+1][i+1];(0!==t||s>0)&&d.push(e,r,l),(t!==n-1||o<Math.PI)&&d.push(r,a,l)}this.setIndex(d),this.setAttribute("position",new ae(p,3)),this.setAttribute("normal",new ae(f,3)),this.setAttribute("uv",new ae(m,2))}static fromJSON(t){return new Ps(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class Ds extends Ie{constructor(t=.5,e=1,n=8,i=1,r=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:s},n=Math.max(3,n);const a=[],o=[],l=[],h=[];let c=t;const u=(e-t)/(i=Math.max(1,i)),d=new lt,p=new $;for(let t=0;t<=i;t++){for(let t=0;t<=n;t++){const i=r+t/n*s;d.x=c*Math.cos(i),d.y=c*Math.sin(i),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,h.push(p.x,p.y)}c+=u}for(let t=0;t<i;t++){const e=t*(n+1);for(let t=0;t<n;t++){const i=t+e,r=i,s=i+n+1,o=i+n+2,l=i+1;a.push(r,s,l),a.push(s,o,l)}}this.setIndex(a),this.setAttribute("position",new ae(o,3)),this.setAttribute("normal",new ae(l,3)),this.setAttribute("uv",new ae(h,2))}static fromJSON(t){return new Ds(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class Is extends Ie{constructor(t=1,e=1,n=1,i=8,r=1,s=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:a,thetaLength:o};const l=this;i=Math.floor(i),r=Math.floor(r);const h=[],c=[],u=[],d=[];let p=0;const f=[],m=n/2;let g=0;function v(n){const r=p,s=new $,f=new lt;let v=0;const x=!0===n?t:e,y=!0===n?1:-1;for(let t=1;t<=i;t++)c.push(0,m*y,0),u.push(0,y,0),d.push(.5,.5),p++;const _=p;for(let t=0;t<=i;t++){const e=t/i*o+a,n=Math.cos(e),r=Math.sin(e);f.x=x*r,f.y=m*y,f.z=x*n,c.push(f.x,f.y,f.z),u.push(0,y,0),s.x=.5*n+.5,s.y=.5*r*y+.5,d.push(s.x,s.y),p++}for(let t=0;t<i;t++){const e=r+t,i=_+t;!0===n?h.push(i,i+1,e):h.push(i+1,i,e),v+=3}l.addGroup(g,v,!0===n?1:2),g+=v}!function(){const s=new lt,v=new lt;let x=0;const y=(e-t)/n;for(let l=0;l<=r;l++){const h=[],g=l/r,x=g*(e-t)+t;for(let t=0;t<=i;t++){const e=t/i,r=e*o+a,l=Math.sin(r),f=Math.cos(r);v.x=x*l,v.y=-g*n+m,v.z=x*f,c.push(v.x,v.y,v.z),s.set(l,y,f).normalize(),u.push(s.x,s.y,s.z),d.push(e,1-g),h.push(p++)}f.push(h)}for(let t=0;t<i;t++)for(let e=0;e<r;e++){const n=f[e][t],i=f[e+1][t],r=f[e+1][t+1],s=f[e][t+1];h.push(n,i,s),h.push(i,r,s),x+=6}l.addGroup(g,x,0),g+=x}(),!1===s&&(t>0&&v(!0),e>0&&v(!1)),this.setIndex(h),this.setAttribute("position",new ae(c,3)),this.setAttribute("normal",new ae(u,3)),this.setAttribute("uv",new ae(d,2))}static fromJSON(t){return new Is(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Ns extends Oe{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new te(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new te(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Ns.prototype.isMeshLambertMaterial=!0;class zs extends Oe{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new te(16777215),this.specular=new te(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new te(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new $(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}zs.prototype.isMeshPhongMaterial=!0;const Fs={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};const Os=new class{constructor(t,e,n){const i=this;let r,s=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){o++,!1===s&&void 0!==i.onStart&&i.onStart(t,a,o),s=!0},this.itemEnd=function(t){a++,void 0!==i.onProgress&&i.onProgress(t,a,o),a===o&&(s=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}}};class Us{constructor(t){this.manager=void 0!==t?t:Os,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(i,r){n.load(t,i,e,r)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}class Bs extends Us{constructor(t){super(t)}load(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=Fs.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;const a=document.createElementNS("http://www.w3.org/1999/xhtml","img");function o(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1),Fs.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(e){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(t),a.src=t,a}}class ks extends Us{constructor(t){super(t)}load(t,e,n,i){const r=new it,s=new Bs(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,(function(n){r.image=n;const i=t.search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/);r.format=i?D:I,r.needsUpdate=!0,void 0!==e&&e(r)}),n,i),r}}const Hs={};class Gs extends Us{constructor(t){super(t)}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=Fs.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;if(void 0!==Hs[t])return void Hs[t].push({onLoad:e,onProgress:n,onError:i});const a=t.match(/^data:(.*?)(;base64)?,(.*)$/);let o;if(a){const n=a[1],s=!!a[2];let o=a[3];o=decodeURIComponent(o),s&&(o=atob(o));try{let i;const s=(this.responseType||"").toLowerCase();switch(s){case"arraybuffer":case"blob":const t=new Uint8Array(o.length);for(let e=0;e<o.length;e++)t[e]=o.charCodeAt(e);i="blob"===s?new Blob([t.buffer],{type:n}):t.buffer;break;case"document":const e=new DOMParser;i=e.parseFromString(o,n);break;case"json":i=JSON.parse(o);break;default:i=o}setTimeout((function(){e&&e(i),r.manager.itemEnd(t)}),0)}catch(e){setTimeout((function(){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}),0)}}else{Hs[t]=[],Hs[t].push({onLoad:e,onProgress:n,onError:i}),o=new XMLHttpRequest,o.open("GET",t,!0),o.addEventListener("load",(function(e){const n=this.response,i=Hs[t];if(delete Hs[t],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Fs.add(t,n);for(let t=0,e=i.length;t<e;t++){const e=i[t];e.onLoad&&e.onLoad(n)}r.manager.itemEnd(t)}else{for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onError&&n.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}}),!1),o.addEventListener("progress",(function(e){const n=Hs[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onProgress&&i.onProgress(e)}}),!1),o.addEventListener("error",(function(e){const n=Hs[t];delete Hs[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}),!1),o.addEventListener("abort",(function(e){const n=Hs[t];delete Hs[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}),!1),void 0!==this.responseType&&(o.responseType=this.responseType),void 0!==this.withCredentials&&(o.withCredentials=this.withCredentials),o.overrideMimeType&&o.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const t in this.requestHeader)o.setRequestHeader(t,this.requestHeader[t]);o.send(null)}return r.manager.itemStart(t),o}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Vs extends Se{constructor(t,e=1){super(),this.type="Light",this.color=new te(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}Vs.prototype.isLight=!0;const Ws=new Ut,js=new lt,Xs=new lt;class qs extends class{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new $(512,512),this.map=null,this.mapPass=null,this.matrix=new Ut,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ot,this._frameExtents=new $(1,1),this._viewportCount=1,this._viewports=[new st(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;js.setFromMatrixPosition(t.matrixWorld),e.position.copy(js),Xs.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Xs),e.updateMatrixWorld(),Ws.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ws),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}{constructor(){super(new Vn(-5,5,5,-5,.5,500))}}qs.prototype.isDirectionalLightShadow=!0;class Ys extends Vs{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(Se.DefaultUp),this.updateMatrix(),this.target=new Se,this.shadow=new qs}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Ys.prototype.isDirectionalLight=!0;class Zs extends Vs{constructor(t,e){super(t,e),this.type="AmbientLight"}}Zs.prototype.isAmbientLight=!0;const Js=new Ut,Qs=new Ut;class Ks{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new On,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new On,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep;const n=t.projectionMatrix.clone(),i=e.eyeSep/2,r=i*e.near/e.focus,s=e.near*Math.tan(j*e.fov*.5)/e.zoom;let a,o;Qs.elements[12]=-i,Js.elements[12]=i,a=-s*e.aspect+r,o=s*e.aspect+r,n.elements[0]=2*e.near/(o-a),n.elements[8]=(o+a)/(o-a),this.cameraL.projectionMatrix.copy(n),a=-s*e.aspect-r,o=s*e.aspect-r,n.elements[0]=2*e.near/(o-a),n.elements[8]=(o+a)/(o-a),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Qs),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Js)}}class $s extends Ie{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}$s.prototype.isInstancedBufferGeometry=!0;class ta extends ie{constructor(t,e,n,i=1){"number"==typeof n&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}ta.prototype.isInstancedBufferAttribute=!0;class ea{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=G,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=q()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=q()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=q()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}ea.prototype.isInterleavedBuffer=!0;class na extends ea{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}na.prototype.isInstancedInterleavedBuffer=!0;const ia=new lt;class ra{constructor(t,e,n,i=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)ia.x=this.getX(e),ia.y=this.getY(e),ia.z=this.getZ(e),ia.applyMatrix4(t),this.setXYZ(e,ia.x,ia.y,ia.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)ia.x=this.getX(e),ia.y=this.getY(e),ia.z=this.getZ(e),ia.applyNormalMatrix(t),this.setXYZ(e,ia.x,ia.y,ia.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)ia.x=this.getX(e),ia.y=this.getY(e),ia.z=this.getZ(e),ia.transformDirection(t),this.setXYZ(e,ia.x,ia.y,ia.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new ie(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new ra(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}ra.prototype.isInterleavedBufferAttribute=!0;class sa{constructor(t,e,n=0,i=1/0){this.ray=new Ze(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new ce,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!1,n=[]){return oa(t,this,n,e),n.sort(aa),n}intersectObjects(t,e=!1,n=[]){for(let i=0,r=t.length;i<r;i++)oa(t[i],this,n,e);return n.sort(aa),n}}function aa(t,e){return t.distance-e.distance}function oa(t,e,n,i){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===i){const i=t.children;for(let t=0,r=i.length;t<r;t++)oa(i[t],e,n,!0)}}class la{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Y(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}const ha=new $;class ca{constructor(t=new $(1/0,1/0),e=new $(-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=ha.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ha.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}ca.prototype.isBox2=!0;const ua=new lt,da=new lt;Se.onUploadDropBuffer=function(){this.array=null},Se.DefaultUp.set(0,0,1),Se.prototype.addStatic=function(t){t.matrixAutoUpdate=!1,t.updateMatrix(),this.add(t)},Se.prototype.dropBuffers=function(t=!0){const e=this.geometry,n=e.attributes;for(const e in n)(t||"color"!==e)&&n[e].onUpload(Se.onUploadDropBuffer);e.index&&e.index.onUpload(Se.onUploadDropBuffer)};const pa={index:new re([0,2,1,0,3,2],1),position:new ae([0,0,0,0,1,0,1,1,0,1,0,0],3)},fa=new st,ma=new lt,ga=new lt,va=new lt;class xa{constructor(t){this.material=t,this.cache={}}getGeometry(t){let e=this.cache[t];return void 0===e&&(e=new ya(t,this.material.getAtlas()),this.cache[t]=e,e.isCached=!0),e}}class ya extends $s{constructor(t,e){super(),this.type="GlyphStringGeometry",this.width=0,this.setIndex(pa.index),this.setAttribute("position",pa.position),this.glyphAtlas=e;const n=new Float32Array(4*t.length),i=new na(n,4,1);this.instanceBuffer=i,this.setAttribute("instanceUvs",new ra(i,2,0)),this.setAttribute("instanceOffsets",new ra(i,1,2)),this.setAttribute("instanceWidths",new ra(i,1,3)),this.setString(t),this.computeBoundingSphere()}dispose(){this.isCached||(this.deleteAttribute("position"),this.setIndex(null),super.dispose())}setString(t){const e=this.getAttribute("instanceUvs"),n=this.getAttribute("instanceOffsets"),i=this.getAttribute("instanceWidths"),r=t.length,s=this.glyphAtlas;let a=0;for(let o=0;o<r;o++){if(0===t.charCodeAt(o))continue;const r=s.getGlyph(t[o]);e.setXY(o,r.column,r.row),i.setX(o,r.width),n.setX(o,a),a+=r.width}e.needsUpdate=!0,n.needsUpdate=!0,i.needsUpdate=!0,this.width=a,this.name=t,this.instanceCount=r}}class _a extends Tn{constructor(t,e,n){super(n,e),this.name=t,this.labelOrigin=new lt,this.labelOffset=new $,this.labelBox=new ca,this.lastFrame=0,this.updateLabelOffset()}getWidth(){return this.geometry.width*this.material.scaleFactor}getHeight(){return this.material.scaleFactor}updateLabelOffset(){this.labelOffset.set(this.getWidth(),this.getHeight(),0),this.material.rotateVector(this.labelOffset),this.material.rotateVector(this.labelOffset)}updateLabelBox(t){const e=this.material,n=e.toScreenSpace,i=this.labelOrigin;this.getWorldPosition(va),i.copy(va),i.project(t),i.multiply(n),e.rotateVector(i),ga.copy(i),ga.add(this.labelOffset),this.labelBox.setFromPoints([i,ga])}getDepth(t){return this.lastFrame<t.getLastFrame()&&(this.updateLabelBox(t.activeCamera),this.lastFrame=t.getLastFrame()),this.labelOrigin.z}checkOcclusion(t,e){if(!this.visible)return;const n=t.length;for(let i=e+1;i<n;i++){const e=t[i];if(e.visible&&this.labelBox.intersectsBox(e.labelBox))return void(this.visible=!1)}}raycast(t,e){if(!this.visible)return e;const n=t.ray,i=t.camera,r=this.material,s=r.toScreenSpace;return n.at(1,fa),fa.w=1,fa.applyMatrix4(i.matrixWorldInverse),fa.applyMatrix4(i.projectionMatrix),fa.multiplyScalar(1/fa.w),ma.copy(fa),ma.multiply(s),r.rotateVector(ma),this.updateLabelBox(i),this.labelBox.containsPoint(ma)&&e.push({object:this,distance:t.ray.origin.distanceTo(va)}),e}}class Ma extends _a{constructor(t,e,n){const i=n.glyphStringCache;let r=i.get(e);void 0===r&&(r=new xa(e),i.set(e,r));const s=r.getGeometry(t);super(t,e,s),s.instanceBuffer.onUpload(Se.onUploadDropBuffer)}}class ba extends _a{constructor(t,e){super(t,e,new ya(t,e.getAtlas()))}replaceString(t){t.length===this.name.length?(this.geometry.setString(t),this.updateLabelOffset()):console.warn("new string has invalid length",t,this.name.length,t.length)}}Se.onUploadDropBuffer=function(){this.array=null},Se.DefaultUp.set(0,0,1),Se.prototype.addStatic=function(t){t.matrixAutoUpdate=!1,t.updateMatrix(),this.add(t)},Se.prototype.dropBuffers=function(t=!0){const e=this.geometry,n=e.attributes;for(const e in n)(t||"color"!==e)&&n[e].onUpload(Se.onUploadDropBuffer);e.index&&e.index.onUpload(Se.onUploadDropBuffer)};const wa=new ut,Sa=new lt;class Ea extends $s{constructor(){super(),this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new ae([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new ae([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}}Object.assign(Ea.prototype,{isLineSegmentsGeometry:!0,applyMatrix4:function(t){const e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},setPositions:function(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const n=new na(e,6,1);return this.setAttribute("instanceStart",new ra(n,3,0)),this.setAttribute("instanceEnd",new ra(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this},setColors:function(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const n=new na(e,6,1);return this.setAttribute("instanceColorStart",new ra(n,3,0)),this.setAttribute("instanceColorEnd",new ra(n,3,3)),this},setHide:function(t){let e;return t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t)),this.setAttribute("instanceHideVertex",new ta(e,1,!1,1)),this},clearHide:function(){this.deleteAttribute("instanceHideVertex")},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new ut);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),wa.setFromBufferAttribute(e),this.boundingBox.union(wa))},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Rt),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let i=0;for(let r=0,s=t.count;r<s;r++)Sa.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(Sa)),Sa.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(Sa));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}});const Ta={anaglyphVertexShader:"varying vec2 vUv;\nvoid main() {\n\tvUv = vec2( uv.x, uv.y );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",anaglyphFragmentShader:"uniform sampler2D mapLeft;\nuniform sampler2D mapRight;\nvarying vec2 vUv;\nuniform mat3 colorMatrixLeft;\nuniform mat3 colorMatrixRight;\nfloat lin( float c ) {\n\treturn c <= 0.04045 ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec4 lin( vec4 c ) {\n\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );\n}\nfloat dev( float c ) {\n\treturn c <= 0.0031308 ? c * 12.92 : pow( c, 0.41666 ) * 1.055 - 0.055;\n}\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 colorL = lin( texture2D( mapLeft, uv ) );\n\tvec4 colorR = lin( texture2D( mapRight, uv ) );\n\tvec3 color = clamp(\n\t\t\tcolorMatrixLeft * colorL.rgb +\n\t\t\tcolorMatrixRight * colorR.rgb, 0., 1.\n\t);\n\tgl_FragColor = vec4(\n\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),\n\t\t\tmax( colorL.a, colorR.a )\n\t);\n}",cursorVertexShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying float height;\nvarying float fogDepth;\nvoid main() {\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n\theight = position.z;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tfogDepth = -mvPosition.z;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",cursorFragmentShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform float cursor;\nuniform float cursorWidth;\nuniform vec3 baseColor;\nuniform vec3 cursorColor;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nvarying float height;\nvarying vec3 vColor;\nvarying float fogDepth;\nvoid main() {\n\tfloat delta = abs( height - cursor );\n\tfloat ss = smoothstep( 0.0, cursorWidth, cursorWidth - delta );\n\tif ( delta < cursorWidth * 0.05 ) {\n\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t} else {\n\t\tgl_FragColor = vec4( mix( baseColor, cursorColor, ss ), 1.0 ) * vec4( vColor, 1.0 );\n\t}\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}",depthMapVertexShader:"uniform float minZ;\nuniform float scaleZ;\nvarying float vHeight;\nvoid main() {\n\tvHeight = ( position.z - minZ ) * scaleZ;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",depthMapFragmentShader:"const float PackUpscale = 256. / 255.;const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packFloatToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\n\treturn r * PackUpscale;\n}\nvarying float vHeight;\nvoid main() {\n\tgl_FragColor = packFloatToRGBA( vHeight );\n}",depthVertexShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nfloat unpackRGBAToFloat( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nuniform vec3 modelMin;\nuniform float scaleX;\nuniform float scaleY;\nuniform float rangeZ;\nuniform float depthScale;\nuniform sampler2D depthMap;\nuniform float datumShift;\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying float vDepth;\nvarying float fogDepth;\nvoid main() {\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n\tvec2 terrainCoords = vec2( ( position.x - modelMin.x ) * scaleX, ( position.y - modelMin.y ) * scaleY );\n\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, terrainCoords ) );\n\tterrainHeight = terrainHeight * rangeZ + modelMin.z + datumShift;\n\tvDepth = ( terrainHeight - position.z ) * depthScale;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tfogDepth = -mvPosition.z;\n\tgl_Position = projectionMatrix * mvPosition;\n}",depthFragmentShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform sampler2D cmap;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nvarying float vDepth;\nvarying vec3 vColor;\nvarying float fogDepth;\nvoid main() {\n\tgl_FragColor = texture2D( cmap, vec2( vDepth, 1.0 ) ) * vec4( vColor, 1.0 );\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}",depthCursorVertexShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nfloat unpackRGBAToFloat( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nuniform vec3 modelMin;\nuniform float scaleX;\nuniform float scaleY;\nuniform float rangeZ;\nuniform sampler2D depthMap;\nuniform float datumShift;\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying float vDepth;\nvarying float fogDepth;\nvoid main() {\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n\tvec2 terrainCoords = vec2( ( position.x - modelMin.x ) * scaleX, ( position.y - modelMin.y ) * scaleY );\n\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, terrainCoords ) );\n\tvDepth = terrainHeight * rangeZ + datumShift + modelMin.z - position.z;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tfogDepth = -mvPosition.z;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",depthCursorFragmentShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform float cursor;\nuniform float cursorWidth;\nuniform vec3 baseColor;\nuniform vec3 cursorColor;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nvarying float vDepth;\nvarying vec3 vColor;\nvarying float fogDepth;\nvoid main() {\n\tfloat delta = abs( vDepth - cursor );\n\tfloat ss = smoothstep( 0.0, cursorWidth, cursorWidth - delta );\n\tif ( delta < cursorWidth * 0.05 ) {\n\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t} else {\n\t\tgl_FragColor = vec4( mix( baseColor, cursorColor, ss ), 1.0 ) * vec4( vColor, 1.0 );\n\t}\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}",glyphVertexShader:"\nuniform float cellScale;\nuniform vec2 scale;\nuniform mat2 rotate;\nattribute vec2 instanceUvs;\nattribute float instanceOffsets;\nattribute float instanceWidths;\nvarying vec2 vUv;\nvarying float fogDepth;\nvoid main() {\n\tvUv = instanceUvs + vec2( position.x * cellScale * instanceWidths, position.y * cellScale );\n\tvec2 newPosition = vec2( position.x * instanceWidths, position.y );\n\tnewPosition.x += instanceOffsets;\n\tnewPosition = rotate * newPosition;\n\tvec4 offset = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tnewPosition *= scale;\n\tnewPosition.xy *= offset.w;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tfogDepth = -mvPosition.z;\n\tgl_Position = vec4( newPosition, 0.0, 0.0 ) + offset;\n}",glyphFragmentShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform sampler2D atlas;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nvarying float fogDepth;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( atlas, vUv );\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, 0.0 ), fogFactor );\n\t}\n}",heightVertexShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform sampler2D cmap;\nuniform float minZ;\nuniform float scaleZ;\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying float zMap;\nvarying float fogDepth;\nvarying vec3 vMvPosition;\nvoid main() {\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n\tzMap = ( position.z - minZ ) * scaleZ;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tvMvPosition = mvPosition.xyz;\n\tfogDepth = -mvPosition.z;\n\tgl_Position = projectionMatrix * mvPosition;\n}",heightFragmentShader:"#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform sampler2D cmap;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nuniform float distanceTransparency;\nvarying float fogDepth;\nvarying float zMap;\nvarying vec3 vColor;\nvarying vec3 vMvPosition;\nvoid main() {\n\tgl_FragColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) ) * vec4( vColor, 1.0 );\n\tif ( distanceTransparency > 0.0 ) {\n\t\tgl_FragColor.a = 1.0 - length( vMvPosition.xyz ) / distanceTransparency;\n\t}\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}",popupVertexShader:"\nuniform mat2 rotate;\nuniform vec2 scale;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvoid main() {\n\tvec2 newPosition = vec2( position.x, position.y );\n\tvColor = color;\n\tvUv = newPosition;\n\tnewPosition = rotate * newPosition;\n\tvec4 offset = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tnewPosition *= scale;\n\tnewPosition *= offset.w;\n\tgl_Position = vec4( newPosition, 0.0, 0.0 ) + offset;\n}",popupFragmentShader:"uniform sampler2D popupImage;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvoid main() {\n\tgl_FragColor = texture2D( popupImage, vUv ) * vec4( vColor, 1.0 );\n}",waterVertexShader:"attribute vec3 sinks;\nattribute float selection;\nvarying vec3 vPosition;\nvarying float vSelection;\nvarying vec3 vSink;\nvoid main() {\n\tvPosition = position;\n\tvSelection = selection;\n\tvSink = sinks;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",waterFragmentShader:"uniform float offset;\nvarying vec3 vPosition;\nvarying float vSelection;\nvarying vec3 vSink;\nvoid main() {\n\tgl_FragColor = vec4( 0.1, 0.1, sin( offset + distance( vPosition, vSink ) ) * 0.4 + 0.6, 0.0 );\n\tgl_FragColor = mix( gl_FragColor, vec4( 1.0, 0.0, 0.0, 1.0 ), vSelection );\n}",lineVertexShader:"#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nuniform float linewidth;\nuniform vec2 resolution;\nattribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nattribute float instanceHideVertex;\nvarying vec2 vUv;\nvarying float vHide;\n#ifdef CV_HEIGHT\n\tuniform sampler2D cmap;\n\tuniform float minZ;\n\tuniform float scaleZ;\n\tvarying float zMap;\n#endif\n#if defined( CV_DEPTH ) || defined( CV_DEPTH_CURSOR )\n\tconst float UnpackDownscale = 255. / 256.;\n\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\n\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\tfloat unpackRGBAToFloat( const in vec4 v ) {\n\t\treturn dot( v, UnpackFactors );\n\t}\n\tuniform vec3 modelMin;\n\tuniform float scaleX;\n\tuniform float scaleY;\n\tuniform float rangeZ;\n\tuniform float depthScale;\n\tuniform sampler2D depthMap;\n\tuniform float datumShift;\n\tvarying float height;\n#endif\n#ifdef CV_CURSOR\n\tvarying float height;\n#endif\n#ifdef USE_DASH\n\tuniform float dashScale;\n\tattribute float instanceDistanceStart;\n\tattribute float instanceDistanceEnd;\n\tvarying float vLineDistance;\n#endif\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\tfloat a = projectionMatrix[ 2 ][ 2 ];\tfloat b = projectionMatrix[ 3 ][ 2 ];\tfloat nearEstimate = - 0.5 * b / a;\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\n}\nvoid main() {\n\t#ifdef USE_COLOR\n\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\t#endif\n\t#ifdef USE_DASH\n\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t#endif\n\tfloat aspect = resolution.x / resolution.y;\n\tvUv = uv;\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\tif ( perspective ) {\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\t\t\ttrimSegment( start, end );\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\t\t\ttrimSegment( end, start );\n\t\t}\n\t}\n\tvec4 clipStart = projectionMatrix * start;\n\tvec4 clipEnd = projectionMatrix * end;\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\tvec2 dir = ndcEnd - ndcStart;\n\tdir.x *= aspect;\n\tdir = normalize( dir );\n\tvec2 offset = vec2( dir.y, - dir.x );\n\tdir.x /= aspect;\n\toffset.x /= aspect;\n\tif ( position.x < 0.0 ) offset *= - 1.0;\n\tif ( position.y < 0.0 ) {\n\t\toffset += - dir;\n\t} else if ( position.y > 1.0 ) {\n\t\toffset += dir;\n\t}\n\toffset *= linewidth;\n\toffset /= resolution.y;\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\toffset *= clip.w;\n\tclip.xy += offset;\n\t#ifdef CV_CURSOR\n\t\theight = instanceStart.z + ( instanceEnd.z - instanceStart.z) * position.y;\n\t#endif\n\t#ifdef CV_HEIGHT\n\t\tzMap = ( instanceStart.z + ( instanceEnd.z - instanceStart.z) * position.y - minZ ) * scaleZ;\n\t#endif\n\t#if defined( CV_DEPTH ) || defined( CV_DEPTH_CURSOR )\n\t\tvec3 realPosition = instanceStart + ( instanceEnd - instanceStart ) * position.y;\n\t\tvec2 terrainCoords = vec2( ( realPosition.x - modelMin.x ) * scaleX, ( realPosition.y - modelMin.y ) * scaleY );\n\t\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, terrainCoords ) );\n\t\tterrainHeight = terrainHeight * rangeZ + modelMin.z + datumShift;\n\t\theight = terrainHeight - realPosition.z;\n\t#endif\n\t#ifdef CV_DEPTH\n\t\theight *= depthScale;\n\t#endif\n\tvHide = instanceHideVertex;\n\tgl_Position = clip;\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",lineFragmentShader:"uniform vec3 diffuse;\nuniform float opacity;\n#ifdef CV_HEIGHT\n\tuniform sampler2D cmap;\n\tvarying float zMap;\n#endif\n#ifdef CV_DEPTH\n\tuniform sampler2D cmap;\n\tvarying float height;\n#endif\n#if defined( CV_CURSOR ) || defined( CV_DEPTH_CURSOR )\n\tuniform float cursor;\n\tuniform float cursorWidth;\n\tuniform vec3 baseColor;\n\tuniform vec3 cursorColor;\n\tvarying float height;\n#endif\n#ifdef USE_DASH\n\tuniform float dashSize;\n\tuniform float dashOffset;\n\tuniform float gapSize;\n#endif\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vUv;\nvarying float vHide;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( vHide > 0.0 ) discard;\n\t#ifdef USE_DASH\n\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard;\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard;\n\t#endif\n\tif ( abs( vUv.y ) > 1.0 ) {\n\t\tfloat a = vUv.x;\n\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\tfloat len2 = a * a + b * b;\n\t\tif ( len2 > 1.0 ) discard;\n\t}\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\t#ifdef CV_HEIGHT\n\t\tgl_FragColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) ) * vec4( vColor, 1.0 );\n\t#endif\n\t#ifdef CV_DEPTH\n\t\tgl_FragColor = texture2D( cmap, vec2( height, 1.0 ) ) * vec4( vColor, 1.0 );\n\t#endif\n\t#if defined( CV_CURSOR ) || defined( CV_DEPTH_CURSOR )\n\t\tfloat delta = abs( height - cursor );\n\t\tfloat ss = smoothstep( 0.0, cursorWidth, cursorWidth - delta );\n\t\tif ( delta < cursorWidth * 0.05 ) {\n\t\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t\t} else {\n\t\t\tgl_FragColor = vec4( mix( baseColor, cursorColor, ss ), 1.0 ) * vec4( vColor, 1.0 );\n\t\t}\n\t#endif\n\t#ifdef CV_BASIC\n\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",commonTerrainCodeColor:"if ( scale > 0.0 ) {\n\tfloat targetDistance = distance( target, vPosition );\n\tfloat f = abs( targetDistance - accuracy ) * scale;\n\tfloat c = smoothstep( 1.0, 6.0, f );\n\tdiffuseColor = mix( vec4( ringColor, 1.0 ), diffuseColor, c );\n}",commonTerrainCodePars:"uniform float scale;\nuniform float accuracy;\nuniform vec2 target;\nuniform vec3 ringColor;\nvarying vec2 vPosition;"},La=ke.merge([An.common,An.fog,{linewidth:{value:1},resolution:{value:new $(1,1)},dashScale:{value:1},dashSize:{value:1},dashOffset:{value:0},gapSize:{value:1},opacity:{value:1}}]);class Ca extends He{constructor(t,e,n={CV_BASIC:!0},i={}){super({type:"LineMaterial",uniforms:Object.assign(ke.clone(La),t.materials.commonUniforms,i),vertexShader:Ta.lineVertexShader,fragmentShader:Ta.lineFragmentShader,clipping:!0,defines:n}),this.dashed=!1,this.ctx=t,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}}}),this.onResize=t=>{const e=t.lineScale?t.lineScale:1;this.resolution=new $(t.width,t.height),this.linewidth=Math.max(1,Math.floor(t.width/1e3)*e)},this.setValues(e),this.resolution=new $(t.container.clientWidth,t.container.clientHeight),t.viewer.addEventListener("resized",this.onResize)}dispose(){this.ctx.viewer.removeEventListener("resized",this.onResize),super.dispose()}}Ca.prototype.isLineMaterial=!0;const Aa=new lt,Ra=new lt,Pa=new st,Da=new st,Ia=new st,Na=new lt,za=new Ut,Fa=new class{constructor(t=new lt,e=new lt){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){ua.subVectors(t,this.start),da.subVectors(this.end,this.start);const n=da.dot(da);let i=da.dot(ua)/n;return e&&(i=Y(i,0,1)),i}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}},Oa=new lt,Ua=new ut,Ba=new Rt,ka=new st;class Ha extends Tn{constructor(t=new Ea,e=new Ca({color:16777215*Math.random()})){super(t,e),this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let t=0,r=0,s=e.count;t<s;t++,r+=2)Aa.fromBufferAttribute(e,t),Ra.fromBufferAttribute(n,t),i[r]=0===r?0:i[r-1],i[r+1]=i[r]+Aa.distanceTo(Ra);const r=new na(i,2,1);return t.setAttribute("instanceDistanceStart",new ra(r,1,0)),t.setAttribute("instanceDistanceEnd",new ra(r,1,1)),this}raycast(t,e){null===t.camera&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');const n=void 0!==t.params.Line2&&t.params.Line2.threshold||0,i=t.ray,r=t.camera,s=r.projectionMatrix,a=this.matrixWorld,o=this.geometry,l=this.material,h=l.resolution,c=l.linewidth+n,u=o.attributes.instanceStart,d=o.attributes.instanceEnd,p=-r.near,f=2*Math.max(c/h.width,c/h.height);null===o.boundingSphere&&o.computeBoundingSphere(),Ba.copy(o.boundingSphere).applyMatrix4(a);const m=Math.max(r.near,Ba.distanceToPoint(i.origin));ka.set(0,0,-m,1).applyMatrix4(r.projectionMatrix),ka.multiplyScalar(1/ka.w),ka.applyMatrix4(r.projectionMatrixInverse);const g=.5*Math.abs(f/ka.w);if(Ba.radius+=g,!1===t.ray.intersectsSphere(Ba))return;null===o.boundingBox&&o.computeBoundingBox(),Ua.copy(o.boundingBox).applyMatrix4(a);const v=Math.max(r.near,Ua.distanceToPoint(i.origin));ka.set(0,0,-v,1).applyMatrix4(r.projectionMatrix),ka.multiplyScalar(1/ka.w),ka.applyMatrix4(r.projectionMatrixInverse);const x=.5*Math.abs(f/ka.w);if(Ua.max.x+=x,Ua.max.y+=x,Ua.max.z+=x,Ua.min.x-=x,Ua.min.y-=x,Ua.min.z-=x,!1!==t.ray.intersectsBox(Ua)){i.at(1,Ia),Ia.w=1,Ia.applyMatrix4(r.matrixWorldInverse),Ia.applyMatrix4(s),Ia.multiplyScalar(1/Ia.w),Ia.x*=h.x/2,Ia.y*=h.y/2,Ia.z=0,Na.copy(Ia),za.multiplyMatrices(r.matrixWorldInverse,a);for(let t=0,n=u.count;t<n;t++){if(Pa.fromBufferAttribute(u,t),Da.fromBufferAttribute(d,t),Pa.w=1,Da.w=1,Pa.applyMatrix4(za),Da.applyMatrix4(za),Pa.z>p&&Da.z>p)continue;if(Pa.z>p){const t=Pa.z-Da.z,e=(Pa.z-p)/t;Pa.lerp(Da,e)}else if(Da.z>p){const t=Da.z-Pa.z,e=(Da.z-p)/t;Da.lerp(Pa,e)}Pa.applyMatrix4(s),Da.applyMatrix4(s),Pa.multiplyScalar(1/Pa.w),Da.multiplyScalar(1/Da.w),Pa.x*=h.x/2,Pa.y*=h.y/2,Da.x*=h.x/2,Da.y*=h.y/2,Fa.start.copy(Pa),Fa.start.z=0,Fa.end.copy(Da),Fa.end.z=0;const n=Fa.closestPointToPointParameter(Na,!0);Fa.at(n,Oa);const r=Z(Pa.z,Da.z,n),o=r>=-1&&r<=1,l=Na.distanceTo(Oa)<4.5*c;if(o&&l){Fa.start.fromBufferAttribute(u,t),Fa.end.fromBufferAttribute(d,t),Fa.start.applyMatrix4(a),Fa.end.applyMatrix4(a);const n=new lt,r=new lt;i.distanceSqToSegment(Fa.start,Fa.end,r,n),e.push({point:r,pointOnLine:n,distance:i.origin.distanceTo(r),object:this,face:null,faceIndex:t,uv:null,uv2:null})}}}}}Ha.prototype.LineSegments2=!0;const Ga=new lt(1,0,0),Va=new lt;class Wa extends ps{constructor(t){const e=t.stdWidth,n=t.stdMargin,i=t.ctx,r=i.cfg,s=i.materials,a=r.themeColor("hud.ahi.sky"),o=r.themeColor("hud.ahi.earth");super(),this.name="CV.AHI",this.lastPitch=0;const l=new ps,h=t.getCommonRing(),c=.75*e,u=new Ps(c,31,31),d=new Ea,p=new Ea,f=u.getAttribute("position").count,m=new ae(new Float32Array(3*f),3);for(let t=0;t<f;t++)(t<f/2?a:o).toArray(m.array,3*t);u.setAttribute("color",m);let g=[];g.push(4-e,0,c),g.push(e-4,0,c),d.setPositions(g);const v=e/10,x=new lt(v,0,c+1),y=new lt(-v,0,c+1);g=[];for(let t=0;t<12;t++){const e=x.clone(),n=y.clone();t%3==0&&(e.x*=2,n.x*=2),e.applyAxisAngle(Ga,t*Math.PI/6),n.applyAxisAngle(Ga,t*Math.PI/6),g.push(e.x,e.y,e.z,n.x,n.y,n.z)}p.setPositions(g);const _=new Tn(h,s.getBezelMaterial()),M=new Tn(u,new zs({vertexColors:!0,specular:6710886,shininess:20})),b=new Ha(d,new Ca(i,{color:r.themeValue("hud.ahi.bar")})),w=new Ha(p,new Ca(i,{color:r.themeValue("hud.ahi.marks")}));M.rotateOnAxis(new lt(0,1,0),Math.PI/2),w.rotateOnAxis(new lt(1,0,0),Math.PI/2),_.rotateOnAxis(new lt(0,0,1),Math.PI/8),M.dropBuffers(),l.addStatic(M),l.addStatic(w),this.addStatic(_),this.addStatic(b),this.add(l);const S=e+n;this.translateX(-3*S),this.translateY(S),this.globe=l;const E=s.getGlyphMaterial(t.atlasSpec,0),T=new ba("-90°",E);return T.translateX(-T.getWidth()/2),T.translateY(e+5),this.addStatic(T),this.label=T,this}set(t){t.getWorldDirection(Va);const e=Math.PI/2-Va.angleTo(Se.DefaultUp);e!==this.lastPitch&&(this.globe.rotateOnAxis(Ga,e-this.lastPitch),this.lastPitch=e,this.label.replaceString(String(Math.round(J(e))+"°").padStart(4," ")))}}function ja(t,e){const n=e.container,i=e.getControls(),r=t.createHitRegion(2*t.stdWidth,2*t.stdWidth,(function(i){if(!e.HUD)return;const s=i.currentTarget;s.addEventListener("mouseleave",h),s.addEventListener("mousemove",p),s.addEventListener("mousedown",c),s.addEventListener("mouseup",u),s.addEventListener("dblclick",d);const o=n.getBoundingClientRect();a=o.top+r.offsetTop+t.stdWidth,r.style.cursor="pointer"})),s=t.stdWidth-10;let a,o,l=!1;function h(t){const e=t.currentTarget;l&&i.end(),e.removeEventListener("mouseleave",h),e.removeEventListener("mousemove",p),e.removeEventListener("mousedown",c),e.removeEventListener("mouseup",u),e.removeEventListener("dblclick",d),r.style.cursor="default",l=!1}function c(t){t.stopPropagation(),l=!0,o=Math.atan((t.clientY-a)/s)}function u(t){t.stopPropagation(),i.end(),l=!1}function d(t){t.stopPropagation(),e.polarAngle<1e-4?e.polarAngle=Math.PI/2:e.polarAngle=0}function p(t){if(t.stopPropagation(),t.preventDefault(),!l)return;const e=Math.atan((t.clientY-a)/s);i.rotateUp(o-e),o=e}r.style.right=3*t.stdMargin+2*t.stdWidth+"px",r.style.bottom=t.stdMargin+"px",n.appendChild(r),this.dispose=function(){n.removeChild(r)}}class Xa extends Tn{constructor(t,e){const n=t.stdWidth,i=t.stdMargin,r=t.ctx.materials,s=new lt(1,0,0),a=new Ds(1,40,36,1,Math.PI,Math.PI),o=r.colourCache.getColors("inclination"),l=[],h=a.getAttribute("position"),c=h.count,u=new ae(3*c,3),d=new lt;for(let t=0;t<c;t++){d.fromBufferAttribute(h,t).normalize();const e=Math.floor(254*Math.asin(Math.abs(d.dot(s)))/Math.PI);l.push(o[e])}a.setAttribute("color",u.copyColorsArray(l)),super(a,new ln({color:16777215,vertexColors:!0})),this.translateY(3*(n+i)+i+30),this.translateX(-45),this.dropBuffers(),this.name="CV.AngleScale";const p=r.getGlyphMaterial(t.atlasSpec,0),f=new Ma(e,p,t.ctx);f.translateX(-f.getWidth()/2),f.translateY(5),this.addStatic(f),this.visible=!1}}const qa=new lt,Ya=new lt(0,0,-1),Za=new he;class Ja extends ps{constructor(t){const e=t.stdWidth,n=t.stdMargin,i=t.ctx.cfg,r=t.ctx.materials;super(),this.name="CV.Compass";const s=t.getCommonRing(),a=new Tn(s,r.getBezelMaterial()),o=new Ds(.9*e,e,4,1,-Math.PI/32+Math.PI/2,Math.PI/16);o.translate(0,0,5);const l=new Tn(o,new ln({color:i.themeValue("hud.compass.top1")}));a.dropBuffers(),l.dropBuffers();const h=function(){const t=new Ie,n=new Ns({vertexColors:!0}),r=new Tn(t,n),s=[],a=[];h(i.themeColor("hud.compass.bottom1"),i.themeColor("hud.compass.bottom2"),Math.PI/4),h(i.themeColor("hud.compass.top1"),i.themeColor("hud.compass.top2"),0);const o=new ae(s.length,3),l=new ae(3*s.length,3);return t.setAttribute("position",o.copyArray(s)),t.setAttribute("color",l.copyColorsArray(a)),t.computeVertexNormals(),r;function h(t,n,i){const r=.9*e,o=.2*r,l=Math.PI/4,h=Math.PI/2;for(let e=0;e<4;e++){const c=e*Math.PI/2+i;s.push(Math.sin(c)*r,Math.cos(c)*r,0),s.push(0,0,2),s.push(Math.sin(c+l)*o,Math.cos(c+l)*o,0),a.push(t,t,t),s.push(Math.sin(c+l)*o,Math.cos(c+l)*o,0),s.push(0,0,2),s.push(Math.sin(c+h)*r,Math.cos(c+h)*r,0),a.push(n,n,n)}}}(),c=new ps;c.addStatic(a),c.addStatic(l),c.addStatic(h),this.add(c),this.rotaryGroup=c;const u=e+n;this.translateX(-u),this.translateY(u),this.lastRotation=0;const d=r.getGlyphMaterial(t.atlasSpec,0),p=new ba("000°",d);return p.translateX(-p.getWidth()/2),p.translateY(e+5),this.addStatic(p),void(this.label=p)}set(t){let e;if(t.getWorldDirection(qa),Math.abs(qa.z)<.999?e=Math.atan2(-qa.x,qa.y):(Za.setFromQuaternion(t.quaternion),e=Za.z),e===this.lastRotation)return;e<0&&(e=2*Math.PI+e);let n=Math.round(J(e));360===n&&(n=0);const i=n.toString().padStart(3,"0")+"°";this.label.replaceString(i),this.rotaryGroup.rotateOnAxis(Ya,e-this.lastRotation),this.lastRotation=e}}function Qa(t,e){const n=e.container,i=e.getControls(),r=new $,s=new $;let a=!1,o=0;const l=t.createHitRegion(2*t.stdWidth,2*t.stdWidth,(function(i){if(!e.HUD)return;const r=i.currentTarget;r.addEventListener("mouseleave",h),r.addEventListener("mousemove",p),r.addEventListener("mousedown",c),r.addEventListener("mouseup",u),r.addEventListener("dblclick",d);const a=n.getBoundingClientRect();s.set(a.left+l.offsetLeft+t.stdWidth,a.top+l.offsetTop+t.stdWidth),l.style.cursor="pointer"}));function h(t){const e=t.currentTarget;a&&i.end(),e.removeEventListener("mouseleave",h),e.removeEventListener("mousemove",p),e.removeEventListener("mousedown",c),e.removeEventListener("mouseup",u),e.removeEventListener("dblclick",d),l.style.cursor="default",a=!1}function c(t){t.stopPropagation(),a=!0,r.set(t.clientX,t.clientY).sub(s),o=r.angle()}function u(t){t.stopPropagation(),i.end(),a=!1}function d(t){t.stopPropagation(),r.x>r.y?r.x<-r.y?e.azimuthAngle=0:e.azimuthAngle=Math.PI/2:r.x>-r.y?e.azimuthAngle=Math.PI:e.azimuthAngle=3*Math.PI/2}function p(t){if(t.stopPropagation(),t.preventDefault(),!a)return;r.set(t.clientX,t.clientY).sub(s);const e=r.angle();i.rotateLeft(o-e),o=e}l.style.right=t.stdMargin+"px",l.style.bottom=t.stdMargin+"px",n.appendChild(l),this.dispose=function(){n.removeChild(l)}}class Ka extends ps{constructor(t,e,n,i){const r=t.ctx.materials,s=e.clientWidth,a=e.clientHeight,o=t.stdWidth,l=t.stdMargin,h=3*(o+l),c=(a-h)/2,u=o/2;super(),this.ctx=t.ctx,this.barHeight=c,this.barWidth=u,this.barOffset=h,this.offsetX=-u/2-5,this.offsetY=c/2,this.translateX(s/2-u/2-l),this.translateY(-a/2+c/2+h),this.scaleBar=new Tn(n,i),this.scaleBar.name="scale bar",this.textMaterial=r.getGlyphMaterial(t.atlasSpec,0),this.add(this.scaleBar),this.min=null,this.max=null,this.caption=null}setRange(t,e,n){const i=this.offsetX,r=this.offsetY,s=this.textMaterial;if(t!==this.min||e!==this.max){for(let t=this.children.length;t--;){const e=this.children[t];e.isRange&&this.remove(e)}const n=new Ma(Math.round(e)+" m",s,this.ctx),a=new Ma(Math.round(t)+" m",s,this.ctx);n.translateX(i-n.getWidth()),a.translateX(i-a.getWidth()),n.translateY(r-n.getHeight()),a.translateY(-r),n.isRange=!0,a.isRange=!0,this.addStatic(n),this.addStatic(a),this.min=t,this.max=e}return this.setCaption(n),this}setCaption(t){let e=this.caption;if(null!==e){if(e.name===t)return this;this.remove(e)}return e=new Ma(t,this.textMaterial,this.ctx),e.translateX(this.barWidth/2-e.getWidth()),e.translateY(this.offsetY+this.barWidth/2),this.addStatic(e),this.caption=e,this}dispose(){this.traverse((t=>{void 0!==t.geometry&&t.geometry.dispose()}))}}class $a extends Ka{constructor(t,e){const n=t.ctx,i=n.cfg,r=n.materials,s=new ze;super(t,e,s,new ln({color:6776679})),this.name="CV.CursorScale";const a=this.barWidth,o=this.barHeight;s.scale(a,o,1);const l=new Ea;l.setPositions([a/2,-o/2,10,-a/2,-o/2,10]);const h=new Ha(l,new Ca(n,{color:i.themeColor("hud.cursor")})),c={color:i.themeColorCSS("hud.cursor"),background:"#444444",font:"bold helvetica,sans-serif"},u=r.getGlyphMaterial(c,0),d=new ba("      ",u);d.translateY(-o/2-d.getHeight()/2),this.addStatic(h),h.addStatic(d),this.cursor=h,this.cursorLabel=d}setCursor(t,e){const n=this.cursor,i=this.cursorLabel;return n.position.setY(this.barHeight*t),n.updateMatrix(),i.replaceString(String(e+" m").padStart(6," ")),i.position.setX(this.offsetX-i.getWidth()),i.updateMatrix(),this}}function to(t,e,n){const i=e.container,s=t.createHitRegion(n.barWidth,n.barHeight,(function(t){if(!e.HUD)return;if(4!==e.shadingMode&&e.shadingMode!==r)return;const n=t.currentTarget;n.addEventListener("mouseleave",h),n.addEventListener("mousemove",d),n.addEventListener("mousedown",c),n.addEventListener("mouseup",u);const o=i.getBoundingClientRect();a=o.top+s.offsetTop,s.style.cursor="pointer"}));let a,o=!1;function l(t){const i=(n.barHeight-t+a)/n.barHeight,s=e.maxHeight-e.minHeight;e.shadingMode===r?e.cursorHeight=s-s*i:e.cursorHeight=s*i-s/2}function h(t){const e=t.currentTarget;e.removeEventListener("mouseleave",h),e.removeEventListener("mousemove",d),e.removeEventListener("mousedown",c),e.removeEventListener("mouseup",u),s.style.cursor="default",o=!1}function c(t){t.stopPropagation(),l(t.clientY),o=!0}function u(t){t.stopPropagation(),o=!1}function d(t){t.stopPropagation(),t.preventDefault(),o&&l(t.clientY)}s.style.right=t.stdMargin+"px",s.style.bottom=n.barOffset+"px",i.appendChild(s),this.hr=s}to.prototype.dispose=function(){const t=this.hr;t.parentNode.removeChild(t)};class eo extends Ka{constructor(t,e){const n=t.ctx.materials,i=new ze;super(t,e,i,n.getScaleMaterial()),this.name="CV.LinearScale",i.rotateZ(-Math.PI/2),i.scale(this.barWidth,this.barHeight,1)}}class no extends Tn{constructor(t,e,n,i){const r=t.ctx.cfg,s=t.ctx.materials,a=t.stdWidth,o=a+t.stdMargin,l=new Ds(a*(.9-.1*n),a*(1-.1*n)-(0===n?0:1),50),h=new ae(306,3);if(l.setAttribute("color",h),super(l,s.getPlainMaterial()),this.backgroundColor=r.themeColor("hud.progressBackground"),this.setColor=r.themeColor("hud.progress"),this.viewer=i,this.dropBuffers(!1),this.name="CV.ProgressDial",this.translateX(5*-o),this.translateY(o),this.rotateOnAxis(Se.DefaultUp,Math.PI/2),this.visible=!1,this.isVisible=!0,this.colorRange(0),e){const e=s.getGlyphMaterial(t.atlasSpec,0),n=new ba("----",e);n.translateY(n.getWidth()/2),n.translateX(-10),this.add(n),this.pcent=n}else this.pcent=null}colorRange(t){const e=this.geometry.getAttribute("color"),n=50-Math.round(t/2),i=e.count,r=this.setColor,s=this.backgroundColor;for(let t=i/2;t>=0;t--){const i=t>n?r:s;i.toArray(e.array,3*t),i.toArray(e.array,3*(t+51))}e.needsUpdate=!0}set(t){if(t===this.progress)return;this.progress=t;const e=2*Math.floor(Math.min(100,Math.round(t))/2),n=this.pcent;if(this.colorRange(e),null!==n){const e=Math.round(t)+"%";n.replaceString(e.padStart(4," ")),n.translateY(n.getWidth()/2-n.position.y)}this.viewer.renderView()}start(){this.colorRange(0),this.progress=0,this.visible=!0,null!==this.pcent&&this.pcent.replaceString("  0%"),this.viewer.renderView()}end(){const t=this;setTimeout((function(){t.visible=!1,t.viewer.renderView()}),500)}setVisibility(t){this.isVisible=t,this.visible=this.visible&&t}watch(t){t.addEventListener("progress",this.handleProgess.bind(this))}handleProgess(t){switch(t.name){case"start":this.start();break;case"set":this.set(t.progress);break;case"end":this.end()}}}class io extends Ie{constructor(t,e,n,i){super();const r=t.cfg,s=r.themeColor("hud.scale.bar1"),a=r.themeColor("hud.scale.bar2"),o=[],l=[];c(10*i,0),c(i,n+1);const h=new ae(3*l.length,3);function c(t,i){const r=e/t;for(let e=0;e<t;e++){const t=e*r,h=t+r,c=i,u=c+n;o.push(t,c,0,h,u,0,t,u,0,h,u,0,t,c,0,h,c,0);const d=e%2?s:a;l.push(d,d,d,d,d,d)}}this.setAttribute("position",new ae(o,3)),this.setAttribute("color",h.copyColorsArray(l))}}class ro extends ps{constructor(t,e,n,i){const r=t.ctx.materials;super(),this.name="CV.ScaleBar",this.hScale=n,this.scaleBars=[],this.currentLength=0,this.wScale=e.clientHeight/e.clientWidth,this.hudObject=t,this.position.set(-e.clientWidth/2+45,-e.clientHeight/2+10,0),this.scaleMax=e.clientWidth-(50+i);const s=r.getGlyphMaterial(t.atlasSpec,0),a=new ba("--------",s);a.translateX(0),a.translateY(10),this.add(a),this.label=a}setScale(t){const e=this.scaleBars,n=this,i=this.hudObject.ctx,r=this.scaleMax/(t*this.hScale);let s=Math.ceil(Math.log(r)/Math.LN10)-1;const a=r/Math.pow(10,s);let o,l=0;if(a<2?(l=10,s-=1):l=a<5?2:5,o=s>=3?l*Math.pow(10,s-3)+" km":l*Math.pow(10,s)+" m",t*=Math.pow(10,s),this.currentLength!==l){if(!e[l]){const t=function(t){const e=new io(i,t*n.hScale,4,t);return e.computeBoundingBox(),{mesh:new Tn(e,i.materials.getPlainMaterial()),topRight:e.boundingBox.max.x}}(l);e[l]=t,this.add(t.mesh)}this.currentLength>0&&(e[this.currentLength].mesh.visible=!1),e[l].mesh.visible=this.visible,this.currentLength=l}e[l].mesh.scale.x=t;const h=this.label;h.replaceString(o.padStart(8," "));const c=h.getWidth();return h.translateX(t*e[l].topRight-h.position.x-c),this}}function so(t){const e=t.cfg;this.stdWidth=e.themeValue("hud.widgetSize"),this.atlasSpec={color:e.themeColorCSS("hud.text"),font:e.themeValue("hud.font")},this.commonRing=null,this.ctx=t}function ao(t,e){const n=this,i=t.ctx.cfg,a=t.container,o=a.clientHeight/2,l=a.clientWidth/2;let h,c,u,d=0,p=null,f=null,m=null,g=null,v=!0,x=!1;const y=new Vn(-l,l,o,-o,1,1e3);y.position.z=600;const _=new _s;_.name="HUD";const M=new ps;M.position.set(l,-o,0),_.addStatic(M);let b=new so(t.ctx);const w=new Zs(8947848),S=new Ys(16777215);S.position.set(-1,1,1),_.addStatic(w),_.addStatic(S);const E=[new no(b,!0,0,t),new no(b,!1,1,t)],T=E[0];D(),M.addStatic(E[0]),M.addStatic(E[1]),t.addEventListener("newCave",P),t.addEventListener("change",N),t.addEventListener("resized",(function(){const e=t.container,n=e.clientWidth/2,i=e.clientHeight/2;y.left=-n,y.right=n,y.top=i,y.bottom=-i,y.updateProjectionMatrix(),M.position.set(n,-i,0),M.updateMatrix(),I()})),i.addEventListener("change",(function(){x&&P()})),i.addEventListener("colors",(function(){b=new so(t.ctx),D(),P()}));const L=t.getControls(),C=new Qa(b,t),A=new ja(b,t);function R(t){const e=i.i18n("hud."+t);return void 0===e?t:e}function P(){x=!0,I(),N({type:"change",name:"shadingMode"})}function D(){h&&M.remove(h),c&&M.remove(c),u&&M.remove(u),h=new Wa(b),c=new Ja(b),u=new Xa(b,R("inclination")),M.addStatic(h),M.addStatic(c),M.addStatic(u)}function I(){const e=t.container,i=t.minHeight!==1/0&&t.maxHeight!==-1/0;p&&(p.dispose(),_.remove(p)),i&&(p=new eo(b,e),_.addStatic(p)),f&&(f.dispose(),_.remove(f)),i&&(f=new $a(b,e),g&&g.dispose(),g=new to(b,t,f),_.addStatic(f)),m&&(_.remove(m),m=null),F(L.cameraManager.activeCamera),n.setVisibility(v)}function N(e){if("shadingMode"!==e.name||!v||!x)return;let n=!1,i=!1,a=!1;switch(t.shadingMode){case 1:i=!0,p.setRange(t.minHeight,t.maxHeight,R("height"));break;case 9:i=!0,p.setRange(t.maxHeight-t.minHeight,0,R("depth"));break;case s:i=!0,p.setRange(0,t.maxDistance,R("distance"));break;case 4:a=!0,f.setRange(t.minHeight,t.maxHeight,R("height")),z();break;case r:a=!0,f.setRange(t.maxHeight-t.minHeight,0,R("depth")),z();break;case 2:i=!0,p.setRange(t.minLegLength,t.maxLegLength,R("leg_length"));break;case 3:n=!0}u.visible=n,p.visible=i,f.visible=a,a?t.addEventListener("cursorChange",z):t.removeEventListener("cursorChange",z),t.renderView()}function z(){const e=t.cursorHeight,n=t.maxHeight-t.minHeight;let i=0,r=0;4===t.shadingMode?(i=(t.cursorHeight+n/2)/n,r=e+n/2+t.minHeight):(i=1-e/n,r=e),i=Math.max(Math.min(i,1),0),f.setCursor(i,Math.round(r))}function F(e){e.isOrthographicCamera?(null===m&&(m=new ro(b,t.container,d,4*(b.stdWidth+b.stdMargin)),_.addStatic(m)),m.visible=v,m.setScale(e.zoom)):null!==m&&m.visible&&(m.visible=!1)}this.setVisibility=function(e){c.visible=e,h.visible=e,T.setVisibility(e),m&&(m.visible=e),v=e,p&&(e?N({type:"change",name:"shadingMode"}):(p.visible=!1,f.visible=!1,u.visible=!1)),t.renderView()},this.getVisibility=function(){return v},this.getProgressDial=function(t){return E[t]},this.setScale=function(t){d=t},this.renderHUD=function(){const t=L.cameraManager.activeCamera;c.set(t),h.set(t),F(t),e.clearDepth(),e.render(_,y)},this.dispose=function(){A.dispose(),C.dispose(),g&&g.dispose()}}Object.assign(so.prototype,{stdMargin:5,createHitRegion:function(t,e,n){const i=document.createElement("div");return i.style.width=t+"px",i.style.height=e+"px",i.style.position="absolute",i.setAttribute("draggable","false"),i.addEventListener("dragstart",(function(t){t.preventDefault()})),i.addEventListener("mouseenter",n),i},getCommonRing:function(){let t=this.commonRing;return null===t&&(t=new Is(.9*this.stdWidth,this.stdWidth,3,32,1,!0),t.rotateX(Math.PI/2),this.commonRing=t),t}});class oo extends He{constructor(t){const e=t.survey,n=t.cfg,i=e.modelLimits;super({vertexShader:Ta.cursorVertexShader,fragmentShader:Ta.cursorFragmentShader,type:"CV.CursorMaterial",uniforms:Object.assign({uLight:{value:e.lightDirection},cursor:{value:0},cursorWidth:{value:5},baseColor:{value:n.themeColor("shading.cursorBase")},cursorColor:{value:n.themeColor("shading.cursor")}},t.materials.commonUniforms),defines:{USE_COLOR:!0}}),this.halfRange=(i.max.z-i.min.z)/2}setCursor(t){const e=Math.max(Math.min(t,this.halfRange),-this.halfRange);return this.uniforms.cursor.value=e,e}getCursor(){return this.uniforms.cursor.value}}class lo extends bs{constructor(t){const e=32,n=document.createElement("canvas");n||console.error("creating canvas for cluster marker failed"),n.width=64,n.height=64;const i=n.getContext("2d");i||console.error("cannot obtain 2D canvas"),i.fillStyle="rgba( 0, 0, 0, 0 )",i.fillRect(0,0,64,64),i.textAlign="center",i.font="bold 40px helvetica,sans-serif",i.fillStyle="#ffffff";const r=i.createRadialGradient(e,e,30,e,e,0);r.addColorStop(0,"rgba( 255, 128, 0, 64 )"),r.addColorStop(.3,"rgba( 255, 200, 0, 255 )"),r.addColorStop(1,"rgba( 255, 255, 0, 255 )"),i.fillStyle=r,i.beginPath(),i.arc(e,e,30,0,2*Math.PI),i.fill(),i.fillStyle="rgba( 0, 0, 0, 255 )",i.fillText(t,e,47);const s=new Rs(n);super({map:s,size:32,depthTest:!1,transparent:!0,alphaTest:.8,sizeAttenuation:!1}),s.onUpdate=function(t){t.image=null},this.name="ClusterMaterial"}}class ho extends Ns{constructor(){super()}editShader(t,e,n,i,r){const s=t.vertexShader.replace("#include <common>","$&\n"+e).replace("include <begin_vertex>","$&\n"+n),a=t.fragmentShader.replace("#include <common>","$&\n"+i).replace("#include <color_fragment>",r);t.vertexShader=s,t.fragmentShader=a}setThroughMode(t){switch(this.stencilWrite=!1,this.blending=1,t){case 2:this.blending=5,this.blendSrc=207,this.blendDst=206;break;case 1:this.stencilWrite=!0,this.stencilFunc=514}}}const co=["uniform float zOffset;","uniform float datumShift;","varying float vPositionZ;"].join("\n"),uo=["vPositionZ = position.z + zOffset + datumShift;"].join("\n"),po=["uniform vec3 contourColor;","uniform vec3 contourColor10;","uniform float contourInterval;","uniform vec3 baseColor;","varying float vPositionZ;"].join("\n"),fo=["float f = fract( vPositionZ / contourInterval );","if ( f > 0.5 ) f = 1.0 - f;","float f10 = fract( vPositionZ / ( contourInterval * 10.0 ) );","float df = fwidth( vPositionZ / contourInterval );","float contourColorSelection = step( 0.90, f10 );","float c = smoothstep( df * 0.5, df * 1.0, f );","vec4 finalColor = vec4( mix( contourColor, contourColor10, contourColorSelection ), 1.0 );","vec4 baseColorAlpha = vec4( baseColor, opacity );","diffuseColor = mix( finalColor, baseColorAlpha, c );"].join("\n");class mo extends ho{constructor(t){const e=t.survey,n=t.cfg,i=t.materials;super(),this.transparent=!0,this.extensions={derivatives:!0},this.onBeforeCompile=function(t){Object.assign(t.uniforms,{zOffset:{value:e.offsets.z},contourInterval:{value:n.themeValue("shading.contours.interval")},contourColor:{value:n.themeColor("shading.contours.line")},contourColor10:{value:n.themeColor("shading.contours.line10")},baseColor:{value:n.themeColor("shading.contours.base")}},i.commonDepthUniforms,i.commonTerrainUniforms),this.editShader(t,co,uo,po,fo)},Object.defineProperty(this,"opacity",{get:function(){return t.materials.terrainOpacity}})}}class go extends He{constructor(t){const e=t.survey,n=e.modelLimits,i=e.terrain,r=i.boundingBox,s=r.getSize(new lt),a=t.cfg.value("saturatedGradient",!1)?"gradientHi":"gradientLow",o=t.materials.textureCache;super({vertexShader:Ta.depthVertexShader,fragmentShader:Ta.depthFragmentShader,type:"CV.DepthMaterial",uniforms:Object.assign({uLight:{value:e.lightDirection},modelMin:{value:r.min},scaleX:{value:1/s.x},scaleY:{value:1/s.y},rangeZ:{value:s.z},depthScale:{value:1/(n.max.z-n.min.z)},cmap:{value:o.getTexture(a)},depthMap:{value:i.depthTexture}},t.materials.commonUniforms,t.materials.commonDepthUniforms),defines:{USE_COLOR:!0}})}}class vo extends He{constructor(t){const e=t.survey,n=t.cfg,i=e.modelLimits,r=e.terrain,s=r.boundingBox,a=s.getSize(new lt),o=i.max.z-i.min.z;super({vertexShader:Ta.depthCursorVertexShader,fragmentShader:Ta.depthCursorFragmentShader,type:"CV.DepthCursorMaterial",uniforms:Object.assign({uLight:{value:e.lightDirection},modelMin:{value:s.min},scaleX:{value:1/a.x},scaleY:{value:1/a.y},rangeZ:{value:a.z},depthMap:{value:r.depthTexture},cursor:{value:o/2},cursorWidth:{value:5},baseColor:{value:n.themeColor("shading.cursorBase")},cursorColor:{value:n.themeColor("shading.cursor")}},t.materials.commonUniforms,t.materials.commonDepthUniforms),defines:{USE_COLOR:!0}}),this.max=o}setCursor(t){const e=Math.max(Math.min(t,this.max),0);return this.uniforms.cursor.value=e,e}getCursor(){return this.uniforms.cursor.value}}class xo extends He{constructor(t){const e=t.boundingBox,n=e.min.z,i=e.max.z;super({vertexShader:Ta.depthMapVertexShader,fragmentShader:Ta.depthMapFragmentShader,type:"CV.DepthMapMaterial",depthWrite:!1,uniforms:{minZ:{value:n},scaleZ:{value:1/(i-n)}}})}}class yo extends bs{constructor(t){super();const e=t.materials.textureCache;return this.map=e.getTexture("disc"),this.color=new te(16777215),this.opacity=1,this.alphaTest=.8,this.sizeAttenuation=!1,this.transparent=!0,this.vertexColors=!0,this.onBeforeCompile=function(t){const e=t.vertexShader.replace("#include <common>","\nattribute float pSize;\n\n$&").replace("\tgl_PointSize = size;","\tgl_PointSize = pSize;");t.vertexShader=e},this}}
/**
	 * @license
	 * Copyright 2010-2021 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */const _o=100,Mo=301,bo=302,wo=306,So=1e3,Eo=1001,To=1002,Lo=1003,Co=1006,Ao=1008,Ro=1009,Po=1012,Do=1014,Io=1015,No=1016,zo=1020,Fo=1022,Oo=1023,Uo=1026,Bo=1027,ko=2300,Ho=2301,Go=2302,Vo=2400,Wo=2401,jo=2402,Xo=2500,qo=3e3,Yo=3001,Zo=3007,Jo=3002,Qo=7680,Ko=35044,$o=35048,tl="300 es";class el{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e<i;e++)n[e].call(this,t);t.target=null}}}const nl=[];for(let t=0;t<256;t++)nl[t]=(t<16?"0":"")+t.toString(16);const il=Math.PI/180,rl=180/Math.PI;function sl(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(nl[255&t]+nl[t>>8&255]+nl[t>>16&255]+nl[t>>24&255]+"-"+nl[255&e]+nl[e>>8&255]+"-"+nl[e>>16&15|64]+nl[e>>24&255]+"-"+nl[63&n|128]+nl[n>>8&255]+"-"+nl[n>>16&255]+nl[n>>24&255]+nl[255&i]+nl[i>>8&255]+nl[i>>16&255]+nl[i>>24&255]).toUpperCase()}function al(t,e,n){return Math.max(e,Math.min(n,t))}function ol(t,e,n){return(1-n)*t+n*e}function ll(t){return 0==(t&t-1)&&0!==t}function hl(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}class cl{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}cl.prototype.isVector2=!0;class ul{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,a,o,l){const h=this.elements;return h[0]=t,h[1]=i,h[2]=a,h[3]=e,h[4]=r,h[5]=o,h[6]=n,h[7]=s,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],h=n[4],c=n[7],u=n[2],d=n[5],p=n[8],f=i[0],m=i[3],g=i[6],v=i[1],x=i[4],y=i[7],_=i[2],M=i[5],b=i[8];return r[0]=s*f+a*v+o*_,r[3]=s*m+a*x+o*M,r[6]=s*g+a*y+o*b,r[1]=l*f+h*v+c*_,r[4]=l*m+h*x+c*M,r[7]=l*g+h*y+c*b,r[2]=u*f+d*v+p*_,r[5]=u*m+d*x+p*M,r[8]=u*g+d*y+p*b,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8];return e*s*h-e*a*l-n*r*h+n*a*o+i*r*l-i*s*o}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8],c=h*s-a*l,u=a*o-h*r,d=l*r-s*o,p=e*c+n*u+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=c*f,t[1]=(i*l-h*n)*f,t[2]=(a*n-i*s)*f,t[3]=u*f,t[4]=(h*e-i*o)*f,t[5]=(i*r-a*e)*f,t[6]=d*f,t[7]=(n*o-l*e)*f,t[8]=(s*e-n*r)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,a){const o=Math.cos(r),l=Math.sin(r);return this.set(n*o,n*l,-n*(o*s+l*a)+s+t,-i*l,i*o,-i*(-l*s+o*a)+a+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,r=i[0],s=i[3],a=i[6],o=i[1],l=i[4],h=i[7];return i[0]=e*r+n*o,i[3]=e*s+n*l,i[6]=e*a+n*h,i[1]=-n*r+e*o,i[4]=-n*s+e*l,i[7]=-n*a+e*h,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}let dl;ul.prototype.isMatrix3=!0;class pl{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===dl&&(dl=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),dl.width=t.width,dl.height=t.height;const n=dl.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=dl}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let fl=0;class ml extends el{constructor(t=ml.DEFAULT_IMAGE,e=ml.DEFAULT_MAPPING,n=1001,i=1001,r=1006,s=1008,a=1023,o=1009,l=1,h=3e3){super(),Object.defineProperty(this,"id",{value:fl++}),this.uuid=sl(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new cl(0,0),this.repeat=new cl(1,1),this.center=new cl(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ul,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const i=this.image;if(void 0===i.uuid&&(i.uuid=sl()),!e&&void 0===t.images[i.uuid]){let e;if(Array.isArray(i)){e=[];for(let t=0,n=i.length;t<n;t++)i[t].isDataTexture?e.push(gl(i[t].image)):e.push(gl(i[t]))}else e=gl(i);t.images[i.uuid]={uuid:i.uuid,url:e}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case So:t.x=t.x-Math.floor(t.x);break;case Eo:t.x=t.x<0?0:1;break;case To:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case So:t.y=t.y-Math.floor(t.y);break;case Eo:t.y=t.y<0?0:1;break;case To:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&this.version++}}function gl(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?pl.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}ml.DEFAULT_IMAGE=void 0,ml.DEFAULT_MAPPING=300,ml.prototype.isTexture=!0;class vl{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,a=.1,o=t.elements,l=o[0],h=o[4],c=o[8],u=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(h-u)<s&&Math.abs(c-f)<s&&Math.abs(p-m)<s){if(Math.abs(h+u)<a&&Math.abs(c+f)<a&&Math.abs(p+m)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,v=(g+1)/2,x=(h+u)/4,y=(c+f)/4,_=(p+m)/4;return t>o&&t>v?t<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=x/n,r=y/n):o>v?o<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(o),n=x/i,r=_/i):v<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(v),n=y/r,i=_/r),this.set(n,i,r,e),this}let v=Math.sqrt((m-p)*(m-p)+(c-f)*(c-f)+(u-h)*(u-h));return Math.abs(v)<.001&&(v=1),this.x=(m-p)/v,this.y=(c-f)/v,this.z=(u-h)/v,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}vl.prototype.isVector4=!0;class xl extends el{constructor(t,e,n={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new vl(0,0,t,e),this.scissorTest=!1,this.viewport=new vl(0,0,t,e),this.texture=new ml(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:Co,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}xl.prototype.isWebGLRenderTarget=!0;(class extends xl{constructor(t,e,n){super(t,e);const i=this.texture;this.texture=[];for(let t=0;t<n;t++)this.texture[t]=i.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}).prototype.isWebGLMultipleRenderTargets=!0;class yl extends xl{constructor(t,e,n){super(t,e,n),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}yl.prototype.isWebGLMultisampleRenderTarget=!0;class _l{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,r,s,a){let o=n[i+0],l=n[i+1],h=n[i+2],c=n[i+3];const u=r[s+0],d=r[s+1],p=r[s+2],f=r[s+3];if(0===a)return t[e+0]=o,t[e+1]=l,t[e+2]=h,void(t[e+3]=c);if(1===a)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(c!==f||o!==u||l!==d||h!==p){let t=1-a;const e=o*u+l*d+h*p+c*f,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,a=Math.sin(a*s)/r}const r=a*n;if(o=o*t+u*r,l=l*t+d*r,h=h*t+p*r,c=c*t+f*r,t===1-a){const t=1/Math.sqrt(o*o+l*l+h*h+c*c);o*=t,l*=t,h*=t,c*=t}}t[e]=o,t[e+1]=l,t[e+2]=h,t[e+3]=c}static multiplyQuaternionsFlat(t,e,n,i,r,s){const a=n[i],o=n[i+1],l=n[i+2],h=n[i+3],c=r[s],u=r[s+1],d=r[s+2],p=r[s+3];return t[e]=a*p+h*c+o*d-l*u,t[e+1]=o*p+h*u+l*c-a*d,t[e+2]=l*p+h*d+a*u-o*c,t[e+3]=h*p-a*c-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,r=t._z,s=t._order,a=Math.cos,o=Math.sin,l=a(n/2),h=a(i/2),c=a(r/2),u=o(n/2),d=o(i/2),p=o(r/2);switch(s){case"XYZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"YXZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"ZXY":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"ZYX":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"YZX":this._x=u*h*c+l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c-u*d*p;break;case"XZY":this._x=u*h*c-l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],a=e[5],o=e[9],l=e[2],h=e[6],c=e[10],u=n+a+c;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(h-o)*t,this._y=(r-l)*t,this._z=(s-i)*t}else if(n>a&&n>c){const t=2*Math.sqrt(1+n-a-c);this._w=(h-o)/t,this._x=.25*t,this._y=(i+s)/t,this._z=(r+l)/t}else if(a>c){const t=2*Math.sqrt(1+a-n-c);this._w=(r-l)/t,this._x=(i+s)/t,this._y=.25*t,this._z=(o+h)/t}else{const t=2*Math.sqrt(1+c-n-a);this._w=(s-i)/t,this._x=(r+l)/t,this._y=(o+h)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(al(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,a=e._x,o=e._y,l=e._z,h=e._w;return this._x=n*h+s*a+i*l-r*o,this._y=i*h+s*o+r*a-n*l,this._z=r*h+s*l+n*o-i*a,this._w=s*h-n*a-i*o-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let a=s*t._w+n*t._x+i*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),h=Math.atan2(l,a),c=Math.sin((1-e)*h)/l,u=Math.sin(e*h)/l;return this._w=s*c+this._w*u,this._x=n*c+this._x*u,this._y=i*c+this._y*u,this._z=r*c+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}_l.prototype.isQuaternion=!0;class Ml{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(wl.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(wl.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,a=t.z,o=t.w,l=o*e+s*i-a*n,h=o*n+a*e-r*i,c=o*i+r*n-s*e,u=-r*e-s*n-a*i;return this.x=l*o+u*-r+h*-a-c*-s,this.y=h*o+u*-s+c*-r-l*-a,this.z=c*o+u*-a+l*-s-h*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,a=e.y,o=e.z;return this.x=i*o-r*a,this.y=r*s-n*o,this.z=n*a-i*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return bl.copy(this).projectOnVector(t),this.sub(bl)}reflect(t){return this.sub(bl.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(al(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}Ml.prototype.isVector3=!0;const bl=new Ml,wl=new _l;class Sl{constructor(t=new Ml(1/0,1/0,1/0),e=new Ml(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.length;o<l;o+=3){const l=t[o],h=t[o+1],c=t[o+2];l<e&&(e=l),h<n&&(n=h),c<i&&(i=c),l>r&&(r=l),h>s&&(s=h),c>a&&(a=c)}return this.min.set(e,n,i),this.max.set(r,s,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.count;o<l;o++){const l=t.getX(o),h=t.getY(o),c=t.getZ(o);l<e&&(e=l),h<n&&(n=h),c<i&&(i=c),l>r&&(r=l),h>s&&(s=h),c>a&&(a=c)}return this.min.set(e,n,i),this.max.set(r,s,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Tl.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),Ll.copy(e.boundingBox),Ll.applyMatrix4(t.matrixWorld),this.union(Ll));const n=t.children;for(let t=0,e=n.length;t<e;t++)this.expandByObject(n[t]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Tl),Tl.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Nl),zl.subVectors(this.max,Nl),Cl.subVectors(t.a,Nl),Al.subVectors(t.b,Nl),Rl.subVectors(t.c,Nl),Pl.subVectors(Al,Cl),Dl.subVectors(Rl,Al),Il.subVectors(Cl,Rl);let e=[0,-Pl.z,Pl.y,0,-Dl.z,Dl.y,0,-Il.z,Il.y,Pl.z,0,-Pl.x,Dl.z,0,-Dl.x,Il.z,0,-Il.x,-Pl.y,Pl.x,0,-Dl.y,Dl.x,0,-Il.y,Il.x,0];return!!Ul(e,Cl,Al,Rl,zl)&&(e=[1,0,0,0,1,0,0,0,1],!!Ul(e,Cl,Al,Rl,zl)&&(Fl.crossVectors(Pl,Dl),e=[Fl.x,Fl.y,Fl.z],Ul(e,Cl,Al,Rl,zl)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Tl.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(Tl).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(El[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),El[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),El[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),El[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),El[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),El[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),El[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),El[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(El)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Sl.prototype.isBox3=!0;const El=[new Ml,new Ml,new Ml,new Ml,new Ml,new Ml,new Ml,new Ml],Tl=new Ml,Ll=new Sl,Cl=new Ml,Al=new Ml,Rl=new Ml,Pl=new Ml,Dl=new Ml,Il=new Ml,Nl=new Ml,zl=new Ml,Fl=new Ml,Ol=new Ml;function Ul(t,e,n,i,r){for(let s=0,a=t.length-3;s<=a;s+=3){Ol.fromArray(t,s);const a=r.x*Math.abs(Ol.x)+r.y*Math.abs(Ol.y)+r.z*Math.abs(Ol.z),o=e.dot(Ol),l=n.dot(Ol),h=i.dot(Ol);if(Math.max(-Math.max(o,l,h),Math.min(o,l,h))>a)return!1}return!0}const Bl=new Sl,kl=new Ml,Hl=new Ml,Gl=new Ml;class Vl{constructor(t=new Ml,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Bl.setFromPoints(t).getCenter(n);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Gl.subVectors(t,this.center);const e=Gl.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.add(Gl.multiplyScalar(n/t)),this.radius+=n}return this}union(t){return Hl.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(kl.copy(t.center).add(Hl)),this.expandByPoint(kl.copy(t.center).sub(Hl)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Wl=new Ml,jl=new Ml,Xl=new Ml,ql=new Ml,Yl=new Ml,Zl=new Ml,Jl=new Ml;class Ql{constructor(t=new Ml,e=new Ml(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Wl)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Wl.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Wl.copy(this.direction).multiplyScalar(e).add(this.origin),Wl.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){jl.copy(t).add(e).multiplyScalar(.5),Xl.copy(e).sub(t).normalize(),ql.copy(this.origin).sub(jl);const r=.5*t.distanceTo(e),s=-this.direction.dot(Xl),a=ql.dot(this.direction),o=-ql.dot(Xl),l=ql.lengthSq(),h=Math.abs(1-s*s);let c,u,d,p;if(h>0)if(c=s*o-a,u=s*a-o,p=r*h,c>=0)if(u>=-p)if(u<=p){const t=1/h;c*=t,u*=t,d=c*(c+s*u+2*a)+u*(s*c+u+2*o)+l}else u=r,c=Math.max(0,-(s*u+a)),d=-c*c+u*(u+2*o)+l;else u=-r,c=Math.max(0,-(s*u+a)),d=-c*c+u*(u+2*o)+l;else u<=-p?(c=Math.max(0,-(-s*r+a)),u=c>0?-r:Math.min(Math.max(-r,-o),r),d=-c*c+u*(u+2*o)+l):u<=p?(c=0,u=Math.min(Math.max(-r,-o),r),d=u*(u+2*o)+l):(c=Math.max(0,-(s*r+a)),u=c>0?r:Math.min(Math.max(-r,-o),r),d=-c*c+u*(u+2*o)+l);else u=s>0?-r:r,c=Math.max(0,-(s*u+a)),d=-c*c+u*(u+2*o)+l;return n&&n.copy(this.direction).multiplyScalar(c).add(this.origin),i&&i.copy(Xl).multiplyScalar(u).add(jl),d}intersectSphere(t,e){Wl.subVectors(t.center,this.origin);const n=Wl.dot(this.direction),i=Wl.dot(Wl)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),a=n-s,o=n+s;return a<0&&o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,a,o;const l=1/this.direction.x,h=1/this.direction.y,c=1/this.direction.z,u=this.origin;return l>=0?(n=(t.min.x-u.x)*l,i=(t.max.x-u.x)*l):(n=(t.max.x-u.x)*l,i=(t.min.x-u.x)*l),h>=0?(r=(t.min.y-u.y)*h,s=(t.max.y-u.y)*h):(r=(t.max.y-u.y)*h,s=(t.min.y-u.y)*h),n>s||r>i?null:((r>n||n!=n)&&(n=r),(s<i||i!=i)&&(i=s),c>=0?(a=(t.min.z-u.z)*c,o=(t.max.z-u.z)*c):(a=(t.max.z-u.z)*c,o=(t.min.z-u.z)*c),n>o||a>i?null:((a>n||n!=n)&&(n=a),(o<i||i!=i)&&(i=o),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,Wl)}intersectTriangle(t,e,n,i,r){Yl.subVectors(e,t),Zl.subVectors(n,t),Jl.crossVectors(Yl,Zl);let s,a=this.direction.dot(Jl);if(a>0){if(i)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}ql.subVectors(this.origin,t);const o=s*this.direction.dot(Zl.crossVectors(ql,Zl));if(o<0)return null;const l=s*this.direction.dot(Yl.cross(ql));if(l<0)return null;if(o+l>a)return null;const h=-s*ql.dot(Jl);return h<0?null:this.at(h/a,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Kl{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,a,o,l,h,c,u,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=h,g[10]=c,g[14]=u,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Kl).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/$l.setFromMatrixColumn(t,0).length(),r=1/$l.setFromMatrixColumn(t,1).length(),s=1/$l.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),a=Math.sin(n),o=Math.cos(i),l=Math.sin(i),h=Math.cos(r),c=Math.sin(r);if("XYZ"===t.order){const t=s*h,n=s*c,i=a*h,r=a*c;e[0]=o*h,e[4]=-o*c,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-a*o,e[2]=r-t*l,e[6]=i+n*l,e[10]=s*o}else if("YXZ"===t.order){const t=o*h,n=o*c,i=l*h,r=l*c;e[0]=t+r*a,e[4]=i*a-n,e[8]=s*l,e[1]=s*c,e[5]=s*h,e[9]=-a,e[2]=n*a-i,e[6]=r+t*a,e[10]=s*o}else if("ZXY"===t.order){const t=o*h,n=o*c,i=l*h,r=l*c;e[0]=t-r*a,e[4]=-s*c,e[8]=i+n*a,e[1]=n+i*a,e[5]=s*h,e[9]=r-t*a,e[2]=-s*l,e[6]=a,e[10]=s*o}else if("ZYX"===t.order){const t=s*h,n=s*c,i=a*h,r=a*c;e[0]=o*h,e[4]=i*l-n,e[8]=t*l+r,e[1]=o*c,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=a*o,e[10]=s*o}else if("YZX"===t.order){const t=s*o,n=s*l,i=a*o,r=a*l;e[0]=o*h,e[4]=r-t*c,e[8]=i*c+n,e[1]=c,e[5]=s*h,e[9]=-a*h,e[2]=-l*h,e[6]=n*c+i,e[10]=t-r*c}else if("XZY"===t.order){const t=s*o,n=s*l,i=a*o,r=a*l;e[0]=o*h,e[4]=-c,e[8]=l*h,e[1]=t*c+r,e[5]=s*h,e[9]=n*c-i,e[2]=i*c-n,e[6]=a*h,e[10]=r*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(eh,t,nh)}lookAt(t,e,n){const i=this.elements;return sh.subVectors(t,e),0===sh.lengthSq()&&(sh.z=1),sh.normalize(),ih.crossVectors(n,sh),0===ih.lengthSq()&&(1===Math.abs(n.z)?sh.x+=1e-4:sh.z+=1e-4,sh.normalize(),ih.crossVectors(n,sh)),ih.normalize(),rh.crossVectors(sh,ih),i[0]=ih.x,i[4]=rh.x,i[8]=sh.x,i[1]=ih.y,i[5]=rh.y,i[9]=sh.y,i[2]=ih.z,i[6]=rh.z,i[10]=sh.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[4],o=n[8],l=n[12],h=n[1],c=n[5],u=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],v=n[3],x=n[7],y=n[11],_=n[15],M=i[0],b=i[4],w=i[8],S=i[12],E=i[1],T=i[5],L=i[9],C=i[13],A=i[2],R=i[6],P=i[10],D=i[14],I=i[3],N=i[7],z=i[11],F=i[15];return r[0]=s*M+a*E+o*A+l*I,r[4]=s*b+a*T+o*R+l*N,r[8]=s*w+a*L+o*P+l*z,r[12]=s*S+a*C+o*D+l*F,r[1]=h*M+c*E+u*A+d*I,r[5]=h*b+c*T+u*R+d*N,r[9]=h*w+c*L+u*P+d*z,r[13]=h*S+c*C+u*D+d*F,r[2]=p*M+f*E+m*A+g*I,r[6]=p*b+f*T+m*R+g*N,r[10]=p*w+f*L+m*P+g*z,r[14]=p*S+f*C+m*D+g*F,r[3]=v*M+x*E+y*A+_*I,r[7]=v*b+x*T+y*R+_*N,r[11]=v*w+x*L+y*P+_*z,r[15]=v*S+x*C+y*D+_*F,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],a=t[5],o=t[9],l=t[13],h=t[2],c=t[6],u=t[10],d=t[14];return t[3]*(+r*o*c-i*l*c-r*a*u+n*l*u+i*a*d-n*o*d)+t[7]*(+e*o*d-e*l*u+r*s*u-i*s*d+i*l*h-r*o*h)+t[11]*(+e*l*c-e*a*d-r*s*c+n*s*d+r*a*h-n*l*h)+t[15]*(-i*a*h-e*o*c+e*a*u+i*s*c-n*s*u+n*o*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],h=t[8],c=t[9],u=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],v=c*m*l-f*u*l+f*o*d-a*m*d-c*o*g+a*u*g,x=p*u*l-h*m*l-p*o*d+s*m*d+h*o*g-s*u*g,y=h*f*l-p*c*l+p*a*d-s*f*d-h*a*g+s*c*g,_=p*c*o-h*f*o-p*a*u+s*f*u+h*a*m-s*c*m,M=e*v+n*x+i*y+r*_;if(0===M)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/M;return t[0]=v*b,t[1]=(f*u*r-c*m*r-f*i*d+n*m*d+c*i*g-n*u*g)*b,t[2]=(a*m*r-f*o*r+f*i*l-n*m*l-a*i*g+n*o*g)*b,t[3]=(c*o*r-a*u*r-c*i*l+n*u*l+a*i*d-n*o*d)*b,t[4]=x*b,t[5]=(h*m*r-p*u*r+p*i*d-e*m*d-h*i*g+e*u*g)*b,t[6]=(p*o*r-s*m*r-p*i*l+e*m*l+s*i*g-e*o*g)*b,t[7]=(s*u*r-h*o*r+h*i*l-e*u*l-s*i*d+e*o*d)*b,t[8]=y*b,t[9]=(p*c*r-h*f*r-p*n*d+e*f*d+h*n*g-e*c*g)*b,t[10]=(s*f*r-p*a*r+p*n*l-e*f*l-s*n*g+e*a*g)*b,t[11]=(h*a*r-s*c*r-h*n*l+e*c*l+s*n*d-e*a*d)*b,t[12]=_*b,t[13]=(h*f*i-p*c*i+p*n*u-e*f*u-h*n*m+e*c*m)*b,t[14]=(p*a*i-s*f*i-p*n*o+e*f*o+s*n*m-e*a*m)*b,t[15]=(s*c*i-h*a*i+h*n*o-e*c*o-s*n*u+e*a*u)*b,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,a=t.y,o=t.z,l=r*s,h=r*a;return this.set(l*s+n,l*a-i*o,l*o+i*a,0,l*a+i*o,h*a+n,h*o-i*s,0,l*o-i*a,h*o+i*s,r*o*o+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,s){return this.set(1,n,r,0,t,1,s,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,a=e._z,o=e._w,l=r+r,h=s+s,c=a+a,u=r*l,d=r*h,p=r*c,f=s*h,m=s*c,g=a*c,v=o*l,x=o*h,y=o*c,_=n.x,M=n.y,b=n.z;return i[0]=(1-(f+g))*_,i[1]=(d+y)*_,i[2]=(p-x)*_,i[3]=0,i[4]=(d-y)*M,i[5]=(1-(u+g))*M,i[6]=(m+v)*M,i[7]=0,i[8]=(p+x)*b,i[9]=(m-v)*b,i[10]=(1-(u+f))*b,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=$l.set(i[0],i[1],i[2]).length();const s=$l.set(i[4],i[5],i[6]).length(),a=$l.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],th.copy(this);const o=1/r,l=1/s,h=1/a;return th.elements[0]*=o,th.elements[1]*=o,th.elements[2]*=o,th.elements[4]*=l,th.elements[5]*=l,th.elements[6]*=l,th.elements[8]*=h,th.elements[9]*=h,th.elements[10]*=h,e.setFromRotationMatrix(th),n.x=r,n.y=s,n.z=a,this}makePerspective(t,e,n,i,r,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,o=2*r/(e-t),l=2*r/(n-i),h=(e+t)/(e-t),c=(n+i)/(n-i),u=-(s+r)/(s-r),d=-2*s*r/(s-r);return a[0]=o,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=l,a[9]=c,a[13]=0,a[2]=0,a[6]=0,a[10]=u,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,i,r,s){const a=this.elements,o=1/(e-t),l=1/(n-i),h=1/(s-r),c=(e+t)*o,u=(n+i)*l,d=(s+r)*h;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-c,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-u,a[2]=0,a[6]=0,a[10]=-2*h,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}Kl.prototype.isMatrix4=!0;const $l=new Ml,th=new Kl,eh=new Ml(0,0,0),nh=new Ml(1,1,1),ih=new Ml,rh=new Ml,sh=new Ml,ah=new Kl,oh=new _l;class lh{constructor(t=0,e=0,n=0,i=lh.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],s=i[4],a=i[8],o=i[1],l=i[5],h=i[9],c=i[2],u=i[6],d=i[10];switch(e){case"XYZ":this._y=Math.asin(al(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,d),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-al(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-c,r),this._z=0);break;case"ZXY":this._x=Math.asin(al(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-c,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,r));break;case"ZYX":this._y=Math.asin(-al(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,r)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(al(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-c,r)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-al(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-h,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return ah.makeRotationFromQuaternion(t),this.setFromRotationMatrix(ah,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return oh.setFromEuler(this),this.setFromQuaternion(oh,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new Ml(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}lh.prototype.isEuler=!0,lh.DefaultOrder="XYZ",lh.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class hh{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}let ch=0;const uh=new Ml,dh=new _l,ph=new Kl,fh=new Ml,mh=new Ml,gh=new Ml,vh=new _l,xh=new Ml(1,0,0),yh=new Ml(0,1,0),_h=new Ml(0,0,1),Mh={type:"added"},bh={type:"removed"};class wh extends el{constructor(){super(),Object.defineProperty(this,"id",{value:ch++}),this.uuid=sl(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=wh.DefaultUp.clone();const t=new Ml,e=new lh,n=new _l,i=new Ml(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Kl},normalMatrix:{value:new ul}}),this.matrix=new Kl,this.matrixWorld=new Kl,this.matrixAutoUpdate=wh.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new hh,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return dh.setFromAxisAngle(t,e),this.quaternion.multiply(dh),this}rotateOnWorldAxis(t,e){return dh.setFromAxisAngle(t,e),this.quaternion.premultiply(dh),this}rotateX(t){return this.rotateOnAxis(xh,t)}rotateY(t){return this.rotateOnAxis(yh,t)}rotateZ(t){return this.rotateOnAxis(_h,t)}translateOnAxis(t,e){return uh.copy(t).applyQuaternion(this.quaternion),this.position.add(uh.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(xh,t)}translateY(t){return this.translateOnAxis(yh,t)}translateZ(t){return this.translateOnAxis(_h,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(ph.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?fh.copy(t):fh.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),mh.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ph.lookAt(mh,fh,this.up):ph.lookAt(fh,mh,this.up),this.quaternion.setFromRotationMatrix(ph),i&&(ph.extractRotation(i.matrixWorld),dh.setFromRotationMatrix(ph),this.quaternion.premultiply(dh.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Mh)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(bh)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(bh)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),ph.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),ph.multiply(t.parent.matrixWorld)),t.applyMatrix4(ph),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(mh,t,gh),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(mh,vh,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const i=n[e];r(t.shapes,i)}else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];i.animations.push(r(t.animations,n))}}if(e){const e=s(t.geometries),i=s(t.materials),r=s(t.textures),a=s(t.images),o=s(t.shapes),l=s(t.skeletons),h=s(t.animations);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),a.length>0&&(n.images=a),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),h.length>0&&(n.animations=h)}return n.object=i,n;function s(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}wh.DefaultUp=new Ml(0,1,0),wh.DefaultMatrixAutoUpdate=!0,wh.prototype.isObject3D=!0;const Sh=new Ml,Eh=new Ml,Th=new Ml,Lh=new Ml,Ch=new Ml,Ah=new Ml,Rh=new Ml,Ph=new Ml,Dh=new Ml,Ih=new Ml;class Nh{constructor(t=new Ml,e=new Ml,n=new Ml){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),Sh.subVectors(t,e),i.cross(Sh);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){Sh.subVectors(i,e),Eh.subVectors(n,e),Th.subVectors(t,e);const s=Sh.dot(Sh),a=Sh.dot(Eh),o=Sh.dot(Th),l=Eh.dot(Eh),h=Eh.dot(Th),c=s*l-a*a;if(0===c)return r.set(-2,-1,-1);const u=1/c,d=(l*o-a*h)*u,p=(s*h-a*o)*u;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Lh),Lh.x>=0&&Lh.y>=0&&Lh.x+Lh.y<=1}static getUV(t,e,n,i,r,s,a,o){return this.getBarycoord(t,e,n,i,Lh),o.set(0,0),o.addScaledVector(r,Lh.x),o.addScaledVector(s,Lh.y),o.addScaledVector(a,Lh.z),o}static isFrontFacing(t,e,n,i){return Sh.subVectors(n,e),Eh.subVectors(t,e),Sh.cross(Eh).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Sh.subVectors(this.c,this.b),Eh.subVectors(this.a,this.b),.5*Sh.cross(Eh).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Nh.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Nh.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return Nh.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return Nh.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Nh.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let s,a;Ch.subVectors(i,n),Ah.subVectors(r,n),Ph.subVectors(t,n);const o=Ch.dot(Ph),l=Ah.dot(Ph);if(o<=0&&l<=0)return e.copy(n);Dh.subVectors(t,i);const h=Ch.dot(Dh),c=Ah.dot(Dh);if(h>=0&&c<=h)return e.copy(i);const u=o*c-h*l;if(u<=0&&o>=0&&h<=0)return s=o/(o-h),e.copy(n).addScaledVector(Ch,s);Ih.subVectors(t,r);const d=Ch.dot(Ih),p=Ah.dot(Ih);if(p>=0&&d<=p)return e.copy(r);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0)return a=l/(l-p),e.copy(n).addScaledVector(Ah,a);const m=h*p-d*c;if(m<=0&&c-h>=0&&d-p>=0)return Rh.subVectors(r,i),a=(c-h)/(c-h+(d-p)),e.copy(i).addScaledVector(Rh,a);const g=1/(m+f+u);return s=f*g,a=u*g,e.copy(n).addScaledVector(Ch,s).addScaledVector(Ah,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let zh=0;class Fh extends el{constructor(){super(),Object.defineProperty(this,"id",{value:zh++}),this.uuid=sl(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.format=Oo,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=_o,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Qo,this.stencilZFail=Qo,this.stencilZPass=Qo,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheenTint&&this.sheenTint.isColor&&(n.sheenTint=this.sheenTint.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(n.specularTint=this.specularTint.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(n.specularTintMap=this.specularTintMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationTint&&(n.attenuationTint=this.attenuationTint.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==Oo&&(n.format=this.format),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}Fh.prototype.isMaterial=!0;const Oh={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Uh={h:0,s:0,l:0},Bh={h:0,s:0,l:0};function kh(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function Hh(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function Gh(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class Vh{constructor(t,e,n){return void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){var i;if(t=(t%(i=1)+i)%i,e=al(e,0,1),n=al(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=kh(r,i,t+1/3),this.g=kh(r,i,t),this.b=kh(r,i,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const i=n[1],r=n[2];switch(i){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){const n=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,r=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(n,i,r)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Oh[t.toLowerCase()];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Hh(t.r),this.g=Hh(t.g),this.b=Hh(t.b),this}copyLinearToSRGB(t){return this.r=Gh(t.r),this.g=Gh(t.g),this.b=Gh(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,i=this.b,r=Math.max(e,n,i),s=Math.min(e,n,i);let a,o;const l=(s+r)/2;if(s===r)a=0,o=0;else{const t=r-s;switch(o=l<=.5?t/(r+s):t/(2-r-s),r){case e:a=(n-i)/t+(n<i?6:0);break;case n:a=(i-e)/t+2;break;case i:a=(e-n)/t+4}a/=6}return t.h=a,t.s=o,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL(Uh),Uh.h+=t,Uh.s+=e,Uh.l+=n,this.setHSL(Uh.h,Uh.s,Uh.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Uh),t.getHSL(Bh);const n=ol(Uh.h,Bh.h,e),i=ol(Uh.s,Bh.s,e),r=ol(Uh.l,Bh.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Vh.NAMES=Oh,Vh.prototype.isColor=!0,Vh.prototype.r=1,Vh.prototype.g=1,Vh.prototype.b=1;class Wh extends Fh{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new Vh(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Wh.prototype.isMeshBasicMaterial=!0;const jh=new Ml,Xh=new cl;class qh{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=Ko,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),r=new Vh),e[n++]=r.r,e[n++]=r.g,e[n++]=r.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),r=new cl),e[n++]=r.x,e[n++]=r.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),r=new Ml),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),r=new vl),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z,e[n++]=r.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)Xh.fromBufferAttribute(this,e),Xh.applyMatrix3(t),this.setXY(e,Xh.x,Xh.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)jh.fromBufferAttribute(this,e),jh.applyMatrix3(t),this.setXYZ(e,jh.x,jh.y,jh.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)jh.x=this.getX(e),jh.y=this.getY(e),jh.z=this.getZ(e),jh.applyMatrix4(t),this.setXYZ(e,jh.x,jh.y,jh.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)jh.x=this.getX(e),jh.y=this.getY(e),jh.z=this.getZ(e),jh.applyNormalMatrix(t),this.setXYZ(e,jh.x,jh.y,jh.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)jh.x=this.getX(e),jh.y=this.getY(e),jh.z=this.getZ(e),jh.transformDirection(t),this.setXYZ(e,jh.x,jh.y,jh.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==Ko&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}qh.prototype.isBufferAttribute=!0;class Yh extends qh{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Zh extends qh{constructor(t,e,n){super(new Uint32Array(t),e,n)}}(class extends qh{constructor(t,e,n){super(new Uint16Array(t),e,n)}}).prototype.isFloat16BufferAttribute=!0;class Jh extends qh{constructor(t,e,n){super(new Float32Array(t),e,n)}}function Qh(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,i=t.length;n<i;++n)t[n]>e&&(e=t[n]);return e}let Kh=0;const $h=new Kl,tc=new wh,ec=new Ml,nc=new Sl,ic=new Sl,rc=new Ml;class sc extends el{constructor(){super(),Object.defineProperty(this,"id",{value:Kh++}),this.uuid=sl(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Qh(t)>65535?Zh:Yh)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new ul).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return $h.makeRotationFromQuaternion(t),this.applyMatrix4($h),this}rotateX(t){return $h.makeRotationX(t),this.applyMatrix4($h),this}rotateY(t){return $h.makeRotationY(t),this.applyMatrix4($h),this}rotateZ(t){return $h.makeRotationZ(t),this.applyMatrix4($h),this}translate(t,e,n){return $h.makeTranslation(t,e,n),this.applyMatrix4($h),this}scale(t,e,n){return $h.makeScale(t,e,n),this.applyMatrix4($h),this}lookAt(t){return tc.lookAt(t),tc.updateMatrix(),this.applyMatrix4(tc.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ec).negate(),this.translate(ec.x,ec.y,ec.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Jh(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Sl);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new Ml(-1/0,-1/0,-1/0),new Ml(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];nc.setFromBufferAttribute(n),this.morphTargetsRelative?(rc.addVectors(this.boundingBox.min,nc.min),this.boundingBox.expandByPoint(rc),rc.addVectors(this.boundingBox.max,nc.max),this.boundingBox.expandByPoint(rc)):(this.boundingBox.expandByPoint(nc.min),this.boundingBox.expandByPoint(nc.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Vl);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new Ml,1/0);if(t){const n=this.boundingSphere.center;if(nc.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];ic.setFromBufferAttribute(n),this.morphTargetsRelative?(rc.addVectors(nc.min,ic.min),nc.expandByPoint(rc),rc.addVectors(nc.max,ic.max),nc.expandByPoint(rc)):(nc.expandByPoint(ic.min),nc.expandByPoint(ic.max))}nc.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)rc.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(rc));if(e)for(let r=0,s=e.length;r<s;r++){const s=e[r],a=this.morphTargetsRelative;for(let e=0,r=s.count;e<r;e++)rc.fromBufferAttribute(s,e),a&&(ec.fromBufferAttribute(t,e),rc.add(ec)),i=Math.max(i,n.distanceToSquared(rc))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,r=e.normal.array,s=e.uv.array,a=i.length/3;void 0===e.tangent&&this.setAttribute("tangent",new qh(new Float32Array(4*a),4));const o=e.tangent.array,l=[],h=[];for(let t=0;t<a;t++)l[t]=new Ml,h[t]=new Ml;const c=new Ml,u=new Ml,d=new Ml,p=new cl,f=new cl,m=new cl,g=new Ml,v=new Ml;function x(t,e,n){c.fromArray(i,3*t),u.fromArray(i,3*e),d.fromArray(i,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),u.sub(c),d.sub(c),f.sub(p),m.sub(p);const r=1/(f.x*m.y-m.x*f.y);isFinite(r)&&(g.copy(u).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(r),v.copy(d).multiplyScalar(f.x).addScaledVector(u,-m.x).multiplyScalar(r),l[t].add(g),l[e].add(g),l[n].add(g),h[t].add(v),h[e].add(v),h[n].add(v))}let y=this.groups;0===y.length&&(y=[{start:0,count:n.length}]);for(let t=0,e=y.length;t<e;++t){const e=y[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)x(n[t+0],n[t+1],n[t+2])}const _=new Ml,M=new Ml,b=new Ml,w=new Ml;function S(t){b.fromArray(r,3*t),w.copy(b);const e=l[t];_.copy(e),_.sub(b.multiplyScalar(b.dot(e))).normalize(),M.crossVectors(w,e);const n=M.dot(h[t])<0?-1:1;o[4*t]=_.x,o[4*t+1]=_.y,o[4*t+2]=_.z,o[4*t+3]=n}for(let t=0,e=y.length;t<e;++t){const e=y[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)S(n[t+0]),S(n[t+1]),S(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new qh(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new Ml,r=new Ml,s=new Ml,a=new Ml,o=new Ml,l=new Ml,h=new Ml,c=new Ml;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),f=t.getX(u+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),h.subVectors(s,r),c.subVectors(i,r),h.cross(c),a.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),a.add(h),o.add(h),l.add(h),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,a=e.count;t<a;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),h.subVectors(s,r),c.subVectors(i,r),h.cross(c),n.setXYZ(t+0,h.x,h.y,h.z),n.setXYZ(t+1,h.x,h.y,h.z),n.setXYZ(t+2,h.x,h.y,h.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(void 0===t.attributes[i])continue;const r=n[i].array,s=t.attributes[i],a=s.array,o=s.itemSize*e,l=Math.min(a.length,r.length-o);for(let t=0,e=o;t<l;t++,e++)r[e]=a[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)rc.fromBufferAttribute(t,e),rc.normalize(),t.setXYZ(e,rc.x,rc.y,rc.z)}toNonIndexed(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,s=new n.constructor(e.length*i);let a=0,o=0;for(let r=0,l=e.length;r<l;r++){a=t.isInterleavedBufferAttribute?e[r]*t.data.stride+t.offset:e[r]*i;for(let t=0;t<i;t++)s[o++]=n[a++]}return new qh(s,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new sc,n=this.index.array,i=this.attributes;for(const r in i){const s=t(i[r],n);e.setAttribute(r,s)}const r=this.morphAttributes;for(const i in r){const s=[],a=r[i];for(let e=0,i=a.length;e<i;e++){const i=t(a[e],n);s.push(i)}e.morphAttributes[i]=s}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,n=s.length;t<n;t++){const n=s[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const i=n[e];t.data.attributes[e]=i.toJSON(t.data)}const i={};let r=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],s=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];s.push(i.toJSON(t.data))}s.length>0&&(i[e]=s,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new sc).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const i=t.attributes;for(const t in i){const n=i[t];this.setAttribute(t,n.clone(e))}const r=t.morphAttributes;for(const t in r){const n=[],i=r[t];for(let t=0,r=i.length;t<r;t++)n.push(i[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}sc.prototype.isBufferGeometry=!0;const ac=new Kl,oc=new Ql,lc=new Vl,hc=new Ml,cc=new Ml,uc=new Ml,dc=new Ml,pc=new Ml,fc=new Ml,mc=new Ml,gc=new Ml,vc=new Ml,xc=new cl,yc=new cl,_c=new cl,Mc=new Ml,bc=new Ml;class wc extends wh{constructor(t=new sc,e=new Wh){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0===i)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),lc.copy(n.boundingSphere),lc.applyMatrix4(r),!1===t.ray.intersectsSphere(lc))return;if(ac.copy(r).invert(),oc.copy(t.ray).applyMatrix4(ac),null!==n.boundingBox&&!1===oc.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const r=n.index,a=n.attributes.position,o=n.morphAttributes.position,l=n.morphTargetsRelative,h=n.attributes.uv,c=n.attributes.uv2,u=n.groups,d=n.drawRange;if(null!==r)if(Array.isArray(i))for(let n=0,p=u.length;n<p;n++){const p=u[n],f=i[p.materialIndex];for(let n=Math.max(p.start,d.start),i=Math.min(p.start+p.count,d.start+d.count);n<i;n+=3){const i=r.getX(n),u=r.getX(n+1),d=r.getX(n+2);s=Sc(this,f,t,oc,a,o,l,h,c,i,u,d),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=p.materialIndex,e.push(s))}}else{for(let n=Math.max(0,d.start),u=Math.min(r.count,d.start+d.count);n<u;n+=3){const u=r.getX(n),d=r.getX(n+1),p=r.getX(n+2);s=Sc(this,i,t,oc,a,o,l,h,c,u,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}else if(void 0!==a)if(Array.isArray(i))for(let n=0,r=u.length;n<r;n++){const r=u[n],p=i[r.materialIndex];for(let n=Math.max(r.start,d.start),i=Math.min(r.start+r.count,d.start+d.count);n<i;n+=3){s=Sc(this,p,t,oc,a,o,l,h,c,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=r.materialIndex,e.push(s))}}else{for(let n=Math.max(0,d.start),r=Math.min(a.count,d.start+d.count);n<r;n+=3){s=Sc(this,i,t,oc,a,o,l,h,c,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function Sc(t,e,n,i,r,s,a,o,l,h,c,u){hc.fromBufferAttribute(r,h),cc.fromBufferAttribute(r,c),uc.fromBufferAttribute(r,u);const d=t.morphTargetInfluences;if(s&&d){mc.set(0,0,0),gc.set(0,0,0),vc.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(dc.fromBufferAttribute(n,h),pc.fromBufferAttribute(n,c),fc.fromBufferAttribute(n,u),a?(mc.addScaledVector(dc,e),gc.addScaledVector(pc,e),vc.addScaledVector(fc,e)):(mc.addScaledVector(dc.sub(hc),e),gc.addScaledVector(pc.sub(cc),e),vc.addScaledVector(fc.sub(uc),e)))}hc.add(mc),cc.add(gc),uc.add(vc)}t.isSkinnedMesh&&(t.boneTransform(h,hc),t.boneTransform(c,cc),t.boneTransform(u,uc));const p=function(t,e,n,i,r,s,a,o){let l;if(l=1===e.side?i.intersectTriangle(a,s,r,!0,o):i.intersectTriangle(r,s,a,2!==e.side,o),null===l)return null;bc.copy(o),bc.applyMatrix4(t.matrixWorld);const h=n.ray.origin.distanceTo(bc);return h<n.near||h>n.far?null:{distance:h,point:bc.clone(),object:t}}(t,e,n,i,hc,cc,uc,Mc);if(p){o&&(xc.fromBufferAttribute(o,h),yc.fromBufferAttribute(o,c),_c.fromBufferAttribute(o,u),p.uv=Nh.getUV(Mc,hc,cc,uc,xc,yc,_c,new cl)),l&&(xc.fromBufferAttribute(l,h),yc.fromBufferAttribute(l,c),_c.fromBufferAttribute(l,u),p.uv2=Nh.getUV(Mc,hc,cc,uc,xc,yc,_c,new cl));const t={a:h,b:c,c:u,normal:new Ml,materialIndex:0};Nh.getNormal(hc,cc,uc,t.normal),p.face=t}return p}wc.prototype.isMesh=!0;class Ec extends sc{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const a=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const o=[],l=[],h=[],c=[];let u=0,d=0;function p(t,e,n,i,r,s,p,f,m,g,v){const x=s/m,y=p/g,_=s/2,M=p/2,b=f/2,w=m+1,S=g+1;let E=0,T=0;const L=new Ml;for(let s=0;s<S;s++){const a=s*y-M;for(let o=0;o<w;o++){const u=o*x-_;L[t]=u*i,L[e]=a*r,L[n]=b,l.push(L.x,L.y,L.z),L[t]=0,L[e]=0,L[n]=f>0?1:-1,h.push(L.x,L.y,L.z),c.push(o/m),c.push(1-s/g),E+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=u+e+w*t,i=u+e+w*(t+1),r=u+(e+1)+w*(t+1),s=u+(e+1)+w*t;o.push(n,i,s),o.push(i,r,s),T+=6}a.addGroup(d,T,v),d+=T,u+=E}p("z","y","x",-1,-1,n,e,t,s,r,0),p("z","y","x",1,-1,n,e,-t,s,r,1),p("x","z","y",1,1,t,n,e,i,s,2),p("x","z","y",1,-1,t,n,-e,i,s,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(o),this.setAttribute("position",new Jh(l,3)),this.setAttribute("normal",new Jh(h,3)),this.setAttribute("uv",new Jh(c,2))}static fromJSON(t){return new Ec(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Tc(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[n][i]=r.clone():Array.isArray(r)?e[n][i]=r.slice():e[n][i]=r}}return e}function Lc(t){const e={};for(let n=0;n<t.length;n++){const i=Tc(t[n]);for(const t in i)e[t]=i[t]}return e}const Cc={clone:Tc,merge:Lc};class Ac extends Fh{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Tc(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}Ac.prototype.isShaderMaterial=!0;class Rc extends wh{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Kl,this.projectionMatrix=new Kl,this.projectionMatrixInverse=new Kl}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}Rc.prototype.isCamera=!0;class Pc extends Rc{constructor(t=50,e=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*rl*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*il*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*rl*Math.atan(Math.tan(.5*il*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*il*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,a=s.fullHeight;r+=s.offsetX*i/t,e-=s.offsetY*n/a,i*=s.width/t,n*=s.height/a}const a=this.filmOffset;0!==a&&(r+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Pc.prototype.isPerspectiveCamera=!0;const Dc=90;class Ic extends wh{constructor(t,e,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new Pc(Dc,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new Ml(1,0,0)),this.add(i);const r=new Pc(Dc,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new Ml(-1,0,0)),this.add(r);const s=new Pc(Dc,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new Ml(0,1,0)),this.add(s);const a=new Pc(Dc,1,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new Ml(0,-1,0)),this.add(a);const o=new Pc(Dc,1,t,e);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new Ml(0,0,1)),this.add(o);const l=new Pc(Dc,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new Ml(0,0,-1)),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,s,a,o,l]=this.children,h=t.xr.enabled,c=t.getRenderTarget();t.xr.enabled=!1;const u=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,o),n.texture.generateMipmaps=u,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(c),t.xr.enabled=h}}class Nc extends ml{constructor(t,e,n,i,r,s,a,o,l,h){super(t=void 0!==t?t:[],e=void 0!==e?e:Mo,n,i,r,s,a=void 0!==a?a:Fo,o,l,h),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Nc.prototype.isCubeTexture=!0;class zc extends xl{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new Nc(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:Co,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Oo,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},i=new Ec(5,5,5),r=new Ac({name:"CubemapFromEquirect",uniforms:Tc(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:1,blending:0});r.uniforms.tEquirect.value=e;const s=new wc(i,r),a=e.minFilter;e.minFilter===Ao&&(e.minFilter=Co);return new Ic(1,10,this).update(t,s),e.minFilter=a,s.geometry.dispose(),s.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,n,i);t.setRenderTarget(r)}}zc.prototype.isWebGLCubeRenderTarget=!0;const Fc=new Ml,Oc=new Ml,Uc=new ul;class Bc{constructor(t=new Ml(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=Fc.subVectors(n,e).cross(Oc.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(Fc),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||Uc.getNormalMatrix(t),i=this.coplanarPoint(Fc).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}Bc.prototype.isPlane=!0;const kc=new Vl,Hc=new Ml;class Gc{constructor(t=new Bc,e=new Bc,n=new Bc,i=new Bc,r=new Bc,s=new Bc){this.planes=[t,e,n,i,r,s]}set(t,e,n,i,r,s){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(i),a[4].copy(r),a[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],s=n[2],a=n[3],o=n[4],l=n[5],h=n[6],c=n[7],u=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],v=n[14],x=n[15];return e[0].setComponents(a-i,c-o,f-u,x-m).normalize(),e[1].setComponents(a+i,c+o,f+u,x+m).normalize(),e[2].setComponents(a+r,c+l,f+d,x+g).normalize(),e[3].setComponents(a-r,c-l,f-d,x-g).normalize(),e[4].setComponents(a-s,c-h,f-p,x-v).normalize(),e[5].setComponents(a+s,c+h,f+p,x+v).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),kc.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(kc)}intersectsSprite(t){return kc.center.set(0,0,0),kc.radius=.7071067811865476,kc.applyMatrix4(t.matrixWorld),this.intersectsSphere(kc)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let t=0;t<6;t++){if(e[t].distanceToPoint(n)<i)return!1}return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Hc.x=i.normal.x>0?t.max.x:t.min.x,Hc.y=i.normal.y>0?t.max.y:t.min.y,Hc.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Hc)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function Vc(){let t=null,e=!1,n=null,i=null;function r(e,s){n(e,s),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Wc(t,e){const n=e.isWebGL2,i=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),i.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=i.get(e);n&&(t.deleteBuffer(n.buffer),i.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){const t=i.get(e);return void((!t||t.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=i.get(e);void 0===s?i.set(e,function(e,i){const r=e.array,s=e.usage,a=t.createBuffer();t.bindBuffer(i,a),t.bufferData(i,r,s),e.onUploadCallback();let o=5126;return r instanceof Float32Array?o=5126:r instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):r instanceof Uint16Array?e.isFloat16BufferAttribute?n?o=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):o=5123:r instanceof Int16Array?o=5122:r instanceof Uint32Array?o=5125:r instanceof Int32Array?o=5124:r instanceof Int8Array?o=5120:(r instanceof Uint8Array||r instanceof Uint8ClampedArray)&&(o=5121),{buffer:a,type:o,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version}}(e,r)):s.version<e.version&&(!function(e,i,r){const s=i.array,a=i.updateRange;t.bindBuffer(r,e),-1===a.count?t.bufferSubData(r,0,s):(n?t.bufferSubData(r,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):t.bufferSubData(r,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,e,r),s.version=e.version)}}}class jc extends sc{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,a=Math.floor(n),o=Math.floor(i),l=a+1,h=o+1,c=t/a,u=e/o,d=[],p=[],f=[],m=[];for(let t=0;t<h;t++){const e=t*u-s;for(let n=0;n<l;n++){const i=n*c-r;p.push(i,-e,0),f.push(0,0,1),m.push(n/a),m.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<a;e++){const n=e+l*t,i=e+l*(t+1),r=e+1+l*(t+1),s=e+1+l*t;d.push(n,i,s),d.push(i,r,s)}this.setIndex(d),this.setAttribute("position",new Jh(p,3)),this.setAttribute("normal",new Jh(f,3)),this.setAttribute("uv",new Jh(m,2))}static fromJSON(t){return new jc(t.width,t.height,t.widthSegments,t.heightSegments)}}const Xc={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float NoH ) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float NoV, float NoL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n}\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in GeometricContext geometry ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = transmission.a;\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},qc={common:{diffuse:{value:new Vh(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new ul},uv2Transform:{value:new ul},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new cl(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Vh(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Vh(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ul}},sprite:{diffuse:{value:new Vh(16777215)},opacity:{value:1},center:{value:new cl(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ul}}},Yc={basic:{uniforms:Lc([qc.common,qc.specularmap,qc.envmap,qc.aomap,qc.lightmap,qc.fog]),vertexShader:Xc.meshbasic_vert,fragmentShader:Xc.meshbasic_frag},lambert:{uniforms:Lc([qc.common,qc.specularmap,qc.envmap,qc.aomap,qc.lightmap,qc.emissivemap,qc.fog,qc.lights,{emissive:{value:new Vh(0)}}]),vertexShader:Xc.meshlambert_vert,fragmentShader:Xc.meshlambert_frag},phong:{uniforms:Lc([qc.common,qc.specularmap,qc.envmap,qc.aomap,qc.lightmap,qc.emissivemap,qc.bumpmap,qc.normalmap,qc.displacementmap,qc.fog,qc.lights,{emissive:{value:new Vh(0)},specular:{value:new Vh(1118481)},shininess:{value:30}}]),vertexShader:Xc.meshphong_vert,fragmentShader:Xc.meshphong_frag},standard:{uniforms:Lc([qc.common,qc.envmap,qc.aomap,qc.lightmap,qc.emissivemap,qc.bumpmap,qc.normalmap,qc.displacementmap,qc.roughnessmap,qc.metalnessmap,qc.fog,qc.lights,{emissive:{value:new Vh(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Xc.meshphysical_vert,fragmentShader:Xc.meshphysical_frag},toon:{uniforms:Lc([qc.common,qc.aomap,qc.lightmap,qc.emissivemap,qc.bumpmap,qc.normalmap,qc.displacementmap,qc.gradientmap,qc.fog,qc.lights,{emissive:{value:new Vh(0)}}]),vertexShader:Xc.meshtoon_vert,fragmentShader:Xc.meshtoon_frag},matcap:{uniforms:Lc([qc.common,qc.bumpmap,qc.normalmap,qc.displacementmap,qc.fog,{matcap:{value:null}}]),vertexShader:Xc.meshmatcap_vert,fragmentShader:Xc.meshmatcap_frag},points:{uniforms:Lc([qc.points,qc.fog]),vertexShader:Xc.points_vert,fragmentShader:Xc.points_frag},dashed:{uniforms:Lc([qc.common,qc.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Xc.linedashed_vert,fragmentShader:Xc.linedashed_frag},depth:{uniforms:Lc([qc.common,qc.displacementmap]),vertexShader:Xc.depth_vert,fragmentShader:Xc.depth_frag},normal:{uniforms:Lc([qc.common,qc.bumpmap,qc.normalmap,qc.displacementmap,{opacity:{value:1}}]),vertexShader:Xc.meshnormal_vert,fragmentShader:Xc.meshnormal_frag},sprite:{uniforms:Lc([qc.sprite,qc.fog]),vertexShader:Xc.sprite_vert,fragmentShader:Xc.sprite_frag},background:{uniforms:{uvTransform:{value:new ul},t2D:{value:null}},vertexShader:Xc.background_vert,fragmentShader:Xc.background_frag},cube:{uniforms:Lc([qc.envmap,{opacity:{value:1}}]),vertexShader:Xc.cube_vert,fragmentShader:Xc.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Xc.equirect_vert,fragmentShader:Xc.equirect_frag},distanceRGBA:{uniforms:Lc([qc.common,qc.displacementmap,{referencePosition:{value:new Ml},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Xc.distanceRGBA_vert,fragmentShader:Xc.distanceRGBA_frag},shadow:{uniforms:Lc([qc.lights,qc.fog,{color:{value:new Vh(0)},opacity:{value:1}}]),vertexShader:Xc.shadow_vert,fragmentShader:Xc.shadow_frag}};function Zc(t,e,n,i,r){const s=new Vh(0);let a,o,l=0,h=null,c=0,u=null;function d(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,r)}return{getClearColor:function(){return s},setClearColor:function(t,e=1){s.set(t),l=e,d(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(t){l=t,d(s,l)},render:function(n,r){let p=!1,f=!0===r.isScene?r.background:null;f&&f.isTexture&&(f=e.get(f));const m=t.xr,g=m.getSession&&m.getSession();g&&"additive"===g.environmentBlendMode&&(f=null),null===f?d(s,l):f&&f.isColor&&(d(f,1),p=!0),(t.autoClear||p)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),f&&(f.isCubeTexture||f.mapping===wo)?(void 0===o&&(o=new wc(new Ec(1,1,1),new Ac({name:"BackgroundCubeMaterial",uniforms:Tc(Yc.cube.uniforms),vertexShader:Yc.cube.vertexShader,fragmentShader:Yc.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),o.geometry.deleteAttribute("uv"),o.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(o.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(o)),o.material.uniforms.envMap.value=f,o.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,h===f&&c===f.version&&u===t.toneMapping||(o.material.needsUpdate=!0,h=f,c=f.version,u=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null)):f&&f.isTexture&&(void 0===a&&(a=new wc(new jc(2,2),new Ac({name:"BackgroundMaterial",uniforms:Tc(Yc.background.uniforms),vertexShader:Yc.background.vertexShader,fragmentShader:Yc.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),a.material.uniforms.uvTransform.value.copy(f.matrix),h===f&&c===f.version&&u===t.toneMapping||(a.material.needsUpdate=!0,h=f,c=f.version,u=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null))}}}function Jc(t,e,n,i){const r=t.getParameter(34921),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),a=i.isWebGL2||null!==s,o={},l=d(null);let h=l;function c(e){return i.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function u(e){return i.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],i=[];for(let t=0;t<r;t++)e[t]=0,n[t]=0,i[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function p(){const t=h.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){m(t,0)}function m(n,r){const s=h.newAttributes,a=h.enabledAttributes,o=h.attributeDivisors;if(s[n]=1,0===a[n]&&(t.enableVertexAttribArray(n),a[n]=1),o[n]!==r){(i.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,r),o[n]=r}}function g(){const e=h.newAttributes,n=h.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function v(e,n,r,s,a,o){!0!==i.isWebGL2||5124!==r&&5125!==r?t.vertexAttribPointer(e,n,r,s,a,o):t.vertexAttribIPointer(e,n,r,a,o)}function x(){y(),h!==l&&(h=l,c(h.object))}function y(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,u,x,y){let _=!1;if(a){const e=function(e,n,r){const a=!0===r.wireframe;let l=o[e.id];void 0===l&&(l={},o[e.id]=l);let h=l[n.id];void 0===h&&(h={},l[n.id]=h);let c=h[a];void 0===c&&(c=d(i.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),h[a]=c);return c}(x,u,l);h!==e&&(h=e,c(h.object)),_=function(t,e){const n=h.attributes,i=t.attributes;let r=0;for(const t in i){const e=n[t],s=i[t];if(void 0===e)return!0;if(e.attribute!==s)return!0;if(e.data!==s.data)return!0;r++}return h.attributesNum!==r||h.index!==e}(x,y),_&&function(t,e){const n={},i=t.attributes;let r=0;for(const t in i){const e=i[t],s={};s.attribute=e,e.data&&(s.data=e.data),n[t]=s,r++}h.attributes=n,h.attributesNum=r,h.index=e}(x,y)}else{const t=!0===l.wireframe;h.geometry===x.id&&h.program===u.id&&h.wireframe===t||(h.geometry=x.id,h.program=u.id,h.wireframe=t,_=!0)}!0===r.isInstancedMesh&&(_=!0),null!==y&&n.update(y,34963),_&&(!function(r,s,a,o){if(!1===i.isWebGL2&&(r.isInstancedMesh||o.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();const l=o.attributes,h=a.getAttributes(),c=s.defaultAttributeValues;for(const e in h){const i=h[e];if(i.location>=0){let s=l[e];if(void 0===s&&("instanceMatrix"===e&&r.instanceMatrix&&(s=r.instanceMatrix),"instanceColor"===e&&r.instanceColor&&(s=r.instanceColor)),void 0!==s){const e=s.normalized,a=s.itemSize,l=n.get(s);if(void 0===l)continue;const h=l.buffer,c=l.type,u=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,l=n.stride,d=s.offset;if(n&&n.isInstancedInterleavedBuffer){for(let t=0;t<i.locationSize;t++)m(i.location+t,n.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let t=0;t<i.locationSize;t++)f(i.location+t);t.bindBuffer(34962,h);for(let t=0;t<i.locationSize;t++)v(i.location+t,a/i.locationSize,c,e,l*u,(d+a/i.locationSize*t)*u)}else{if(s.isInstancedBufferAttribute){for(let t=0;t<i.locationSize;t++)m(i.location+t,s.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let t=0;t<i.locationSize;t++)f(i.location+t);t.bindBuffer(34962,h);for(let t=0;t<i.locationSize;t++)v(i.location+t,a/i.locationSize,c,e,a*u,a/i.locationSize*t*u)}}else if(void 0!==c){const n=c[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(i.location,n);break;case 3:t.vertexAttrib3fv(i.location,n);break;case 4:t.vertexAttrib4fv(i.location,n);break;default:t.vertexAttrib1fv(i.location,n)}}}}g()}(r,l,u,x),null!==y&&t.bindBuffer(34963,n.get(y).buffer))},reset:x,resetDefaultState:y,dispose:function(){x();for(const t in o){const e=o[t];for(const t in e){const n=e[t];for(const t in n)u(n[t].object),delete n[t];delete e[t]}delete o[t]}},releaseStatesOfGeometry:function(t){if(void 0===o[t.id])return;const e=o[t.id];for(const t in e){const n=e[t];for(const t in n)u(n[t].object),delete n[t];delete e[t]}delete o[t.id]},releaseStatesOfProgram:function(t){for(const e in o){const n=o[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)u(i[t].object),delete i[t];delete n[t.id]}},initAttributes:p,enableAttribute:f,disableUnusedAttributes:g}}function Qc(t,e,n,i){const r=i.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,i){t.drawArrays(s,e,i),n.update(i,s,1)},this.renderInstances=function(i,a,o){if(0===o)return;let l,h;if(r)l=t,h="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),h="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[h](s,i,a,o),n.update(a,s,o)}}function Kc(t,e,n){let i;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const o=r(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=s||e.has("WEBGL_draw_buffers"),h=!0===n.logarithmicDepthBuffer,c=t.getParameter(34930),u=t.getParameter(35660),d=t.getParameter(3379),p=t.getParameter(34076),f=t.getParameter(34921),m=t.getParameter(36347),g=t.getParameter(36348),v=t.getParameter(36349),x=u>0,y=s||e.has("OES_texture_float");return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");i=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:r,precision:a,logarithmicDepthBuffer:h,maxTextures:c,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:v,vertexTextures:x,floatFragmentTextures:y,floatVertexTextures:x&&y,maxSamples:s?t.getParameter(36183):0}}function $c(t){const e=this;let n=null,i=0,r=!1,s=!1;const a=new Bc,o=new ul,l={value:null,needsUpdate:!1};function h(){l.value!==n&&(l.value=n,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function c(t,n,i,r){const s=null!==t?t.length:0;let h=null;if(0!==s){if(h=l.value,!0!==r||null===h){const e=i+4*s,r=n.matrixWorldInverse;o.getNormalMatrix(r),(null===h||h.length<e)&&(h=new Float32Array(e));for(let e=0,n=i;e!==s;++e,n+=4)a.copy(t[e]).applyMatrix4(r,o),a.normal.toArray(h,n),h[n+3]=a.constant}l.value=h,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,h}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const a=0!==t.length||e||0!==i||r;return r=e,n=c(t,s,0),i=t.length,a},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1,h()},this.setState=function(e,a,o){const u=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!r||null===u||0===u.length||s&&!p)s?c(null):h();else{const t=s?0:i,e=4*t;let r=f.clippingState||null;l.value=r,r=c(u,a,e,o);for(let t=0;t!==e;++t)r[t]=n[t];f.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function tu(t){let e=new WeakMap;function n(t,e){return 303===e?t.mapping=Mo:304===e&&(t.mapping=bo),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){const s=r.mapping;if(303===s||304===s){if(e.has(r)){return n(e.get(r).texture,r.mapping)}{const s=r.image;if(s&&s.height>0){const a=t.getRenderTarget(),o=new zc(s.height/2);return o.fromEquirectangularTexture(t,r),e.set(r,o),t.setRenderTarget(a),r.addEventListener("dispose",i),n(o.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}Yc.physical={uniforms:Lc([Yc.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new cl(1,1)},clearcoatNormalMap:{value:null},sheenTint:{value:new Vh(0)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new cl},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new Vh(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new Vh(1,1,1)},specularTintMap:{value:null}}]),vertexShader:Xc.meshphysical_vert,fragmentShader:Xc.meshphysical_frag};class eu extends Rc{constructor(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,a=i+e,o=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,s=r+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(r,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}eu.prototype.isOrthographicCamera=!0;class nu extends Ac{constructor(t){super(t),this.type="RawShaderMaterial"}}nu.prototype.isRawShaderMaterial=!0;const iu=Math.pow(2,8),ru=[.125,.215,.35,.446,.526,.582],su=5+ru.length,au=20,ou={[qo]:0,[Yo]:1,[Jo]:2,3004:3,3005:4,3006:5,[Zo]:6},lu=new eu,{_lodPlanes:hu,_sizeLods:cu,_sigmas:uu}=yu(),du=new Vh;let pu=null;const fu=(1+Math.sqrt(5))/2,mu=1/fu,gu=[new Ml(1,1,1),new Ml(-1,1,1),new Ml(1,1,-1),new Ml(-1,1,-1),new Ml(0,fu,mu),new Ml(0,fu,-mu),new Ml(mu,0,fu),new Ml(-mu,0,fu),new Ml(fu,mu,0),new Ml(-fu,mu,0)];class vu{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const e=new Float32Array(t),n=new Ml(0,1,0);return new nu({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:ou[3e3]},outputEncoding:{value:ou[3e3]}},vertexShader:Su(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Eu()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}(au),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){pu=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=wu(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=bu(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<hu.length;t++)hu[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(pu),t.scissorTest=!1,Mu(t,0,0,t.width,t.height)}_fromTexture(t){pu=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:Lo,minFilter:Lo,generateMipmaps:!1,type:Ro,format:1023,encoding:xu(t)?t.encoding:Jo,depthBuffer:!1},n=_u(e);return n.depthBuffer=!t,this._pingPongRenderTarget=_u(e),n}_compileMaterial(t){const e=new wc(hu[0],t);this._renderer.compile(e,lu)}_sceneToCubeUV(t,e,n,i){const r=new Pc(90,1,e,n),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,h=o.outputEncoding,c=o.toneMapping;o.getClearColor(du),o.toneMapping=0,o.outputEncoding=qo,o.autoClear=!1;const u=new Wh({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),d=new wc(new Ec,u);let p=!1;const f=t.background;f?f.isColor&&(u.color.copy(f),t.background=null,p=!0):(u.color.copy(du),p=!0);for(let e=0;e<6;e++){const n=e%3;0==n?(r.up.set(0,s[e],0),r.lookAt(a[e],0,0)):1==n?(r.up.set(0,0,s[e]),r.lookAt(0,a[e],0)):(r.up.set(0,s[e],0),r.lookAt(0,0,a[e])),Mu(i,n*iu,e>2?iu:0,iu,iu),o.setRenderTarget(i),p&&o.render(d,r),o.render(t,r)}d.geometry.dispose(),d.material.dispose(),o.toneMapping=c,o.outputEncoding=h,o.autoClear=l,t.background=f}_textureToCubeUV(t,e){const n=this._renderer;t.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=wu()):null==this._equirectShader&&(this._equirectShader=bu());const i=t.isCubeTexture?this._cubemapShader:this._equirectShader,r=new wc(hu[0],i),s=i.uniforms;s.envMap.value=t,t.isCubeTexture||s.texelSize.value.set(1/t.image.width,1/t.image.height),s.inputEncoding.value=ou[t.encoding],s.outputEncoding.value=ou[e.texture.encoding],Mu(e,0,0,3*iu,2*iu),n.setRenderTarget(e),n.render(r,lu)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<su;e++){const n=Math.sqrt(uu[e]*uu[e]-uu[e-1]*uu[e-1]),i=gu[(e-1)%gu.length];this._blur(t,e-1,e,n,i)}e.autoClear=n}_blur(t,e,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,i,"latitudinal",r),this._halfBlur(s,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,s,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const h=new wc(hu[i],l),c=l.uniforms,u=cu[n]-1,d=isFinite(r)?Math.PI/(2*u):2*Math.PI/39,p=r/d,f=isFinite(r)?1+Math.floor(3*p):au;f>au&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<au;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0==t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;c.envMap.value=t.texture,c.samples.value=f,c.weights.value=m,c.latitudinal.value="latitudinal"===s,a&&(c.poleAxis.value=a),c.dTheta.value=d,c.mipInt.value=8-n,c.inputEncoding.value=ou[t.texture.encoding],c.outputEncoding.value=ou[t.texture.encoding];const v=cu[i];Mu(e,3*Math.max(0,iu-2*v),(0===i?0:2*iu)+2*v*(i>4?i-8+4:0),3*v,2*v),o.setRenderTarget(e),o.render(h,lu)}}function xu(t){return void 0!==t&&t.type===Ro&&(t.encoding===qo||t.encoding===Yo||t.encoding===Zo)}function yu(){const t=[],e=[],n=[];let i=8;for(let r=0;r<su;r++){const s=Math.pow(2,i);e.push(s);let a=1/s;r>4?a=ru[r-8+4-1]:0==r&&(a=0),n.push(a);const o=1/(s-1),l=-o/2,h=1+o/2,c=[l,l,h,l,h,h,l,l,h,h,l,h],u=6,d=6,p=3,f=2,m=1,g=new Float32Array(p*d*u),v=new Float32Array(f*d*u),x=new Float32Array(m*d*u);for(let t=0;t<u;t++){const e=t%3*2/3-1,n=t>2?0:-1,i=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];g.set(i,p*d*t),v.set(c,f*d*t);const r=[t,t,t,t,t,t];x.set(r,m*d*t)}const y=new sc;y.setAttribute("position",new qh(g,p)),y.setAttribute("uv",new qh(v,f)),y.setAttribute("faceIndex",new qh(x,m)),t.push(y),i>4&&i--}return{_lodPlanes:t,_sizeLods:e,_sigmas:n}}function _u(t){const e=new xl(3*iu,3*iu,t);return e.texture.mapping=wo,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function Mu(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function bu(){const t=new cl(1,1);return new nu({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:t},inputEncoding:{value:ou[3e3]},outputEncoding:{value:ou[3e3]}},vertexShader:Su(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Eu()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}function wu(){return new nu({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:ou[3e3]},outputEncoding:{value:ou[3e3]}},vertexShader:Su(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Eu()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}function Su(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function Eu(){return"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"}function Tu(t){let e=new WeakMap,n=null;function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){const s=r.mapping,a=303===s||304===s,o=s===Mo||s===bo;if(a||o){if(e.has(r))return e.get(r).texture;{const s=r.image;if(a&&s&&s.height>0||o&&s&&function(t){let e=0;const n=6;for(let i=0;i<n;i++)void 0!==t[i]&&e++;return e===n}(s)){const s=t.getRenderTarget();null===n&&(n=new vu(t));const o=a?n.fromEquirectangular(r):n.fromCubemap(r);return e.set(r,o),t.setRenderTarget(s),r.addEventListener("dispose",i),o.texture}return null}}}return r},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function Lu(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function Cu(t,e,n,i){const r={},s=new WeakMap;function a(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);o.removeEventListener("dispose",a),delete r[o.id];const l=s.get(o);l&&(e.remove(l),s.delete(o)),i.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(t){const n=[],i=t.index,r=t.attributes.position;let a=0;if(null!==i){const t=i.array;a=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],s=t[e+2];n.push(i,r,r,s,s,i)}}else{const t=r.array;a=r.version;for(let e=0,i=t.length/3-1;e<i;e+=3){const t=e+0,i=e+1,r=e+2;n.push(t,i,i,r,r,t)}}const o=new(Qh(n)>65535?Zh:Yh)(n,1);o.version=a;const l=s.get(t);l&&e.remove(l),s.set(t,o)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",a),r[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const t in n)e.update(n[t],34962);const i=t.morphAttributes;for(const t in i){const n=i[t];for(let t=0,i=n.length;t<i;t++)e.update(n[t],34962)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&o(t)}else o(t);return s.get(t)}}}function Au(t,e,n,i){const r=i.isWebGL2;let s,a,o;this.setMode=function(t){s=t},this.setIndex=function(t){a=t.type,o=t.bytesPerElement},this.render=function(e,i){t.drawElements(s,i,a,e*o),n.update(i,s,1)},this.renderInstances=function(i,l,h){if(0===h)return;let c,u;if(r)c=t,u="drawElementsInstanced";else if(c=e.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===c)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[u](s,l,a,i*o,h),n.update(l,s,h)}}function Ru(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,i){switch(e.calls++,n){case 4:e.triangles+=i*(t/3);break;case 1:e.lines+=i*(t/2);break;case 3:e.lines+=i*(t-1);break;case 2:e.lines+=i*t;break;case 0:e.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function Pu(t,e){return t[0]-e[0]}function Du(t,e){return Math.abs(e[1])-Math.abs(t[1])}function Iu(t){const e={},n=new Float32Array(8),i=[];for(let t=0;t<8;t++)i[t]=[t,0];return{update:function(r,s,a,o){const l=r.morphTargetInfluences,h=void 0===l?0:l.length;let c=e[s.id];if(void 0===c||c.length!==h){c=[];for(let t=0;t<h;t++)c[t]=[t,0];e[s.id]=c}for(let t=0;t<h;t++){const e=c[t];e[0]=t,e[1]=l[t]}c.sort(Du);for(let t=0;t<8;t++)t<h&&c[t][1]?(i[t][0]=c[t][0],i[t][1]=c[t][1]):(i[t][0]=Number.MAX_SAFE_INTEGER,i[t][1]=0);i.sort(Pu);const u=s.morphAttributes.position,d=s.morphAttributes.normal;let p=0;for(let t=0;t<8;t++){const e=i[t],r=e[0],a=e[1];r!==Number.MAX_SAFE_INTEGER&&a?(u&&s.getAttribute("morphTarget"+t)!==u[r]&&s.setAttribute("morphTarget"+t,u[r]),d&&s.getAttribute("morphNormal"+t)!==d[r]&&s.setAttribute("morphNormal"+t,d[r]),n[t]=a,p+=a):(u&&!0===s.hasAttribute("morphTarget"+t)&&s.deleteAttribute("morphTarget"+t),d&&!0===s.hasAttribute("morphNormal"+t)&&s.deleteAttribute("morphNormal"+t),n[t]=0)}const f=s.morphTargetsRelative?1:1-p;o.getUniforms().setValue(t,"morphTargetBaseInfluence",f),o.getUniforms().setValue(t,"morphTargetInfluences",n)}}}function Nu(t,e,n,i){let r=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const a=i.render.frame,o=t.geometry,l=e.get(t,o);return r.get(l)!==a&&(e.update(l),r.set(l,a)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),l},dispose:function(){r=new WeakMap}}}class zu extends ml{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=Lo,this.minFilter=Lo,this.wrapR=Eo,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}zu.prototype.isDataTexture2DArray=!0;class Fu extends ml{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=Lo,this.minFilter=Lo,this.wrapR=Eo,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Fu.prototype.isDataTexture3D=!0;const Ou=new ml,Uu=new zu,Bu=new Fu,ku=new Nc,Hu=[],Gu=[],Vu=new Float32Array(16),Wu=new Float32Array(9),ju=new Float32Array(4);function Xu(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let s=Hu[r];if(void 0===s&&(s=new Float32Array(r),Hu[r]=s),0!==e){i.toArray(s,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(s,r)}return s}function qu(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function Yu(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function Zu(t,e){let n=Gu[e];void 0===n&&(n=new Int32Array(e),Gu[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function Ju(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Qu(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(qu(n,e))return;t.uniform2fv(this.addr,e),Yu(n,e)}}function Ku(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(qu(n,e))return;t.uniform3fv(this.addr,e),Yu(n,e)}}function $u(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(qu(n,e))return;t.uniform4fv(this.addr,e),Yu(n,e)}}function td(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(qu(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),Yu(n,e)}else{if(qu(n,i))return;ju.set(i),t.uniformMatrix2fv(this.addr,!1,ju),Yu(n,i)}}function ed(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(qu(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),Yu(n,e)}else{if(qu(n,i))return;Wu.set(i),t.uniformMatrix3fv(this.addr,!1,Wu),Yu(n,i)}}function nd(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(qu(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),Yu(n,e)}else{if(qu(n,i))return;Vu.set(i),t.uniformMatrix4fv(this.addr,!1,Vu),Yu(n,i)}}function id(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function rd(t,e){const n=this.cache;qu(n,e)||(t.uniform2iv(this.addr,e),Yu(n,e))}function sd(t,e){const n=this.cache;qu(n,e)||(t.uniform3iv(this.addr,e),Yu(n,e))}function ad(t,e){const n=this.cache;qu(n,e)||(t.uniform4iv(this.addr,e),Yu(n,e))}function od(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function ld(t,e){const n=this.cache;qu(n,e)||(t.uniform2uiv(this.addr,e),Yu(n,e))}function hd(t,e){const n=this.cache;qu(n,e)||(t.uniform3uiv(this.addr,e),Yu(n,e))}function cd(t,e){const n=this.cache;qu(n,e)||(t.uniform4uiv(this.addr,e),Yu(n,e))}function ud(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(e||Ou,r)}function dd(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||Bu,r)}function pd(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTextureCube(e||ku,r)}function fd(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||Uu,r)}function md(t,e){t.uniform1fv(this.addr,e)}function gd(t,e){const n=Xu(e,this.size,2);t.uniform2fv(this.addr,n)}function vd(t,e){const n=Xu(e,this.size,3);t.uniform3fv(this.addr,n)}function xd(t,e){const n=Xu(e,this.size,4);t.uniform4fv(this.addr,n)}function yd(t,e){const n=Xu(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function _d(t,e){const n=Xu(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function Md(t,e){const n=Xu(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function bd(t,e){t.uniform1iv(this.addr,e)}function wd(t,e){t.uniform2iv(this.addr,e)}function Sd(t,e){t.uniform3iv(this.addr,e)}function Ed(t,e){t.uniform4iv(this.addr,e)}function Td(t,e){t.uniform1uiv(this.addr,e)}function Ld(t,e){t.uniform2uiv(this.addr,e)}function Cd(t,e){t.uniform3uiv(this.addr,e)}function Ad(t,e){t.uniform4uiv(this.addr,e)}function Rd(t,e,n){const i=e.length,r=Zu(n,i);t.uniform1iv(this.addr,r);for(let t=0;t!==i;++t)n.safeSetTexture2D(e[t]||Ou,r[t])}function Pd(t,e,n){const i=e.length,r=Zu(n,i);t.uniform1iv(this.addr,r);for(let t=0;t!==i;++t)n.safeSetTextureCube(e[t]||ku,r[t])}function Dd(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return Ju;case 35664:return Qu;case 35665:return Ku;case 35666:return $u;case 35674:return td;case 35675:return ed;case 35676:return nd;case 5124:case 35670:return id;case 35667:case 35671:return rd;case 35668:case 35672:return sd;case 35669:case 35673:return ad;case 5125:return od;case 36294:return ld;case 36295:return hd;case 36296:return cd;case 35678:case 36198:case 36298:case 36306:case 35682:return ud;case 35679:case 36299:case 36307:return dd;case 35680:case 36300:case 36308:case 36293:return pd;case 36289:case 36303:case 36311:case 36292:return fd}}(e.type)}function Id(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return md;case 35664:return gd;case 35665:return vd;case 35666:return xd;case 35674:return yd;case 35675:return _d;case 35676:return Md;case 5124:case 35670:return bd;case 35667:case 35671:return wd;case 35668:case 35672:return Sd;case 35669:case 35673:return Ed;case 5125:return Td;case 36294:return Ld;case 36295:return Cd;case 36296:return Ad;case 35678:case 36198:case 36298:case 36306:case 35682:return Rd;case 35680:case 36300:case 36308:case 36293:return Pd}}(e.type)}function Nd(t){this.id=t,this.seq=[],this.map={}}Id.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),Yu(e,t)},Nd.prototype.setValue=function(t,e,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const s=i[r];s.setValue(t,e[s.id],n)}};const zd=/(\w+)(\])?(\[|\.)?/g;function Fd(t,e){t.seq.push(e),t.map[e.id]=e}function Od(t,e,n){const i=t.name,r=i.length;for(zd.lastIndex=0;;){const s=zd.exec(i),a=zd.lastIndex;let o=s[1];const l="]"===s[2],h=s[3];if(l&&(o|=0),void 0===h||"["===h&&a+2===r){Fd(n,void 0===h?new Dd(o,t,e):new Id(o,t,e));break}{let t=n.map[o];void 0===t&&(t=new Nd(o),Fd(n,t)),n=t}}}function Ud(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);Od(n,t.getUniformLocation(e,n.name),this)}}function Bd(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}Ud.prototype.setValue=function(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)},Ud.prototype.setOptional=function(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)},Ud.upload=function(t,e,n,i){for(let r=0,s=e.length;r!==s;++r){const s=e[r],a=n[s.id];!1!==a.needsUpdate&&s.setValue(t,a.value,i)}},Ud.seqWithValue=function(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n};let kd=0;function Hd(t){switch(t){case qo:return["Linear","( value )"];case Yo:return["sRGB","( value )"];case Jo:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case Zo:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function Gd(t,e,n){const i=t.getShaderParameter(e,35713),r=t.getShaderInfoLog(e).trim();return i&&""===r?"":n.toUpperCase()+"\n\n"+r+"\n\n"+function(t){const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join("\n")}(t.getShaderSource(e))}function Vd(t,e){const n=Hd(e);return"vec4 "+t+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function Wd(t,e){const n=Hd(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function jd(t,e){let n;switch(e){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function Xd(t){return""!==t}function qd(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Yd(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Zd=/^[ \t]*#include +<([\w\d./]+)>/gm;function Jd(t){return t.replace(Zd,Qd)}function Qd(t,e){const n=Xc[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return Jd(n)}const Kd=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,$d=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function tp(t){return t.replace($d,np).replace(Kd,ep)}function ep(t,e,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),np(t,e,n,i)}function np(t,e,n,i){let r="";for(let t=parseInt(e);t<parseInt(n);t++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return r}function ip(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function rp(t,e,n,i){const r=t.getContext(),s=n.defines;let a=n.vertexShader,o=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(n),h=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case Mo:case bo:e="ENVMAP_TYPE_CUBE";break;case wo:case 307:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),c=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case bo:case 307:e="ENVMAP_MODE_REFRACTION"}return e}(n),u=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(n),d=t.gammaFactor>0?t.gammaFactor:1,p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Xd).join("\n")}(n),f=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(s),m=r.createProgram();let g,v,x=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[f].filter(Xd).join("\n"),g.length>0&&(g+="\n"),v=[p,f].filter(Xd).join("\n"),v.length>0&&(v+="\n")):(g=[ip(n),"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularTintMap?"#define USE_SPECULARTINTMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Xd).join("\n"),v=[p,ip(n),"#define SHADER_NAME "+n.shaderName,f,"#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularTintMap?"#define USE_SPECULARTINTMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheenTint?"#define USE_SHEEN":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?Xc.tonemapping_pars_fragment:"",0!==n.toneMapping?jd("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.format===Fo?"#define OPAQUE":"",Xc.encodings_pars_fragment,n.map?Vd("mapTexelToLinear",n.mapEncoding):"",n.matcap?Vd("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?Vd("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?Vd("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.specularTintMap?Vd("specularTintMapTexelToLinear",n.specularTintMapEncoding):"",n.lightMap?Vd("lightMapTexelToLinear",n.lightMapEncoding):"",Wd("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(Xd).join("\n")),a=Jd(a),a=qd(a,n),a=Yd(a,n),o=Jd(o),o=qd(o,n),o=Yd(o,n),a=tp(a),o=tp(o),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(x="#version 300 es\n",g=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,v=["#define varying in",n.glslVersion===tl?"":"out highp vec4 pc_fragColor;",n.glslVersion===tl?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+v);const y=x+v+o,_=Bd(r,35633,x+g+a),M=Bd(r,35632,y);if(r.attachShader(m,_),r.attachShader(m,M),void 0!==n.index0AttributeName?r.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),t.debug.checkShaderErrors){const t=r.getProgramInfoLog(m).trim(),e=r.getShaderInfoLog(_).trim(),n=r.getShaderInfoLog(M).trim();let i=!0,s=!0;if(!1===r.getProgramParameter(m,35714)){i=!1;const e=Gd(r,_,"vertex"),n=Gd(r,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(m,35715)+"\n\nProgram Info Log: "+t+"\n"+e+"\n"+n)}else""!==t?console.warn("THREE.WebGLProgram: Program Info Log:",t):""!==e&&""!==n||(s=!1);s&&(this.diagnostics={runnable:i,programLog:t,vertexShader:{log:e,prefix:g},fragmentShader:{log:n,prefix:v}})}let b,w;return r.deleteShader(_),r.deleteShader(M),this.getUniforms=function(){return void 0===b&&(b=new Ud(r,m)),b},this.getAttributes=function(){return void 0===w&&(w=function(t,e){const n={},i=t.getProgramParameter(e,35721);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r),s=i.name;let a=1;35674===i.type&&(a=2),35675===i.type&&(a=3),35676===i.type&&(a=4),n[s]={type:i.type,location:t.getAttribLocation(e,s),locationSize:a}}return n}(r,m)),w},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=kd++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=_,this.fragmentShader=M,this}function sp(t,e,n,i,r,s,a){const o=[],l=r.isWebGL2,h=r.logarithmicDepthBuffer,c=r.floatVertexTextures,u=r.maxVertexUniforms,d=r.vertexTextures;let p=r.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheenTint","transmission","transmissionMap","thicknessMap"];function g(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=qo,e}return{getParameters:function(s,o,m,v,x){const y=v.fog,_=s.isMeshStandardMaterial?v.environment:null,M=(s.isMeshStandardMaterial?n:e).get(s.envMap||_),b=f[s.type],w=x.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(c)return 1024;{const t=u,n=Math.floor((t-20)/4),i=Math.min(n,e.length);return i<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+i+"."),0):i}}(x):0;let S,E;if(null!==s.precision&&(p=r.getMaxPrecision(s.precision),p!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",p,"instead.")),b){const t=Yc[b];S=t.vertexShader,E=t.fragmentShader}else S=s.vertexShader,E=s.fragmentShader;const T=t.getRenderTarget(),L=s.alphaTest>0,C=s.clearcoat>0;return{isWebGL2:l,shaderID:b,shaderName:s.type,vertexShader:S,fragmentShader:E,defines:s.defines,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:p,instancing:!0===x.isInstancedMesh,instancingColor:!0===x.isInstancedMesh&&null!==x.instanceColor,supportsVertexTextures:d,outputEncoding:null!==T?g(T.texture):t.outputEncoding,map:!!s.map,mapEncoding:g(s.map),matcap:!!s.matcap,matcapEncoding:g(s.matcap),envMap:!!M,envMapMode:M&&M.mapping,envMapEncoding:g(M),envMapCubeUV:!!M&&(M.mapping===wo||307===M.mapping),lightMap:!!s.lightMap,lightMapEncoding:g(s.lightMap),aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,emissiveMapEncoding:g(s.emissiveMap),bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:1===s.normalMapType,tangentSpaceNormalMap:0===s.normalMapType,clearcoat:C,clearcoatMap:C&&!!s.clearcoatMap,clearcoatRoughnessMap:C&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:C&&!!s.clearcoatNormalMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularTintMap:!!s.specularTintMap,specularTintMapEncoding:g(s.specularTintMap),alphaMap:!!s.alphaMap,alphaTest:L,gradientMap:!!s.gradientMap,sheenTint:!!s.sheenTint&&(s.sheenTint.r>0||s.sheenTint.g>0||s.sheenTint.b>0),transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!x.geometry&&!!x.geometry.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!x.geometry&&!!x.geometry.attributes.color&&4===x.geometry.attributes.color.itemSize,vertexUvs:!!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatMap||s.clearcoatRoughnessMap||s.clearcoatNormalMap||s.displacementMap||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularTintMap),uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularTintMap||!s.displacementMap),fog:!!y,useFog:s.fog,fogExp2:y&&y.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:h,skinning:!0===x.isSkinnedMesh&&w>0,maxBones:w,useVertexTexture:c,morphTargets:!!x.geometry&&!!x.geometry.morphAttributes.position,morphNormals:!!x.geometry&&!!x.geometry.morphAttributes.normal,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:s.format,dithering:s.dithering,shadowMapEnabled:t.shadowMap.enabled&&m.length>0,shadowMapType:t.shadowMap.type,toneMapping:s.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:2===s.side,flipSided:1===s.side,depthPacking:void 0!==s.depthPacking&&s.depthPacking,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:l||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:l||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:l||i.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.fragmentShader),n.push(e.vertexShader)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);if(!1===e.isRawShaderMaterial){for(let t=0;t<m.length;t++)n.push(e[m[t]]);n.push(t.outputEncoding),n.push(t.gammaFactor)}return n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=f[t.type];let n;if(e){const t=Yc[e];n=Cc.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let i;for(let t=0,e=o.length;t<e;t++){const e=o[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new rp(t,n,e,s),o.push(i)),i},releaseProgram:function(t){if(0==--t.usedTimes){const e=o.indexOf(t);o[e]=o[o.length-1],o.pop(),t.destroy()}},programs:o}}function ap(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function op(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function lp(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function hp(t){const e=[];let n=0;const i=[],r=[],s=[],a={id:-1};function o(i,r,s,o,l,h){let c=e[n];const u=t.get(s);return void 0===c?(c={id:i.id,object:i,geometry:r,material:s,program:u.program||a,groupOrder:o,renderOrder:i.renderOrder,z:l,group:h},e[n]=c):(c.id=i.id,c.object=i,c.geometry=r,c.material=s,c.program=u.program||a,c.groupOrder=o,c.renderOrder=i.renderOrder,c.z=l,c.group=h),n++,c}return{opaque:i,transmissive:r,transparent:s,init:function(){n=0,i.length=0,r.length=0,s.length=0},push:function(t,e,n,a,l,h){const c=o(t,e,n,a,l,h);n.transmission>0?r.push(c):!0===n.transparent?s.push(c):i.push(c)},unshift:function(t,e,n,a,l,h){const c=o(t,e,n,a,l,h);n.transmission>0?r.unshift(c):!0===n.transparent?s.unshift(c):i.unshift(c)},finish:function(){for(let t=n,i=e.length;t<i;t++){const n=e[t];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(t,e){i.length>1&&i.sort(t||op),r.length>1&&r.sort(e||lp),s.length>1&&s.sort(e||lp)}}}function cp(t){let e=new WeakMap;return{get:function(n,i){let r;return!1===e.has(n)?(r=new hp(t),e.set(n,[r])):i>=e.get(n).length?(r=new hp(t),e.get(n).push(r)):r=e.get(n)[i],r},dispose:function(){e=new WeakMap}}}function up(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new Ml,color:new Vh};break;case"SpotLight":n={position:new Ml,direction:new Ml,color:new Vh,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Ml,color:new Vh,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Ml,skyColor:new Vh,groundColor:new Vh};break;case"RectAreaLight":n={color:new Vh,position:new Ml,halfWidth:new Ml,halfHeight:new Ml}}return t[e.id]=n,n}}}let dp=0;function pp(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function fp(t,e){const n=new up,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new cl};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new cl,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)r.probe.push(new Ml);const s=new Ml,a=new Kl,o=new Kl;return{setup:function(s,a){let o=0,l=0,h=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let c=0,u=0,d=0,p=0,f=0,m=0,g=0,v=0;s.sort(pp);const x=!0!==a?Math.PI:1;for(let t=0,e=s.length;t<e;t++){const e=s[t],a=e.color,y=e.intensity,_=e.distance,M=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=a.r*y*x,l+=a.g*y*x,h+=a.b*y*x;else if(e.isLightProbe)for(let t=0;t<9;t++)r.probe[t].addScaledVector(e.sh.coefficients[t],y);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*x),e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.directionalShadow[c]=n,r.directionalShadowMap[c]=M,r.directionalShadowMatrix[c]=e.shadow.matrix,m++}r.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(a).multiplyScalar(y*x),t.distance=_,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.spotShadow[d]=n,r.spotShadowMap[d]=M,r.spotShadowMatrix[d]=e.shadow.matrix,v++}r.spot[d]=t,d++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(a).multiplyScalar(y),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),r.rectArea[p]=t,p++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*x),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,r.pointShadow[u]=n,r.pointShadowMap[u]=M,r.pointShadowMatrix[u]=e.shadow.matrix,g++}r.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(y*x),t.groundColor.copy(e.groundColor).multiplyScalar(y*x),r.hemi[f]=t,f++}}p>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=qc.LTC_FLOAT_1,r.rectAreaLTC2=qc.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=qc.LTC_HALF_1,r.rectAreaLTC2=qc.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=o,r.ambient[1]=l,r.ambient[2]=h;const y=r.hash;y.directionalLength===c&&y.pointLength===u&&y.spotLength===d&&y.rectAreaLength===p&&y.hemiLength===f&&y.numDirectionalShadows===m&&y.numPointShadows===g&&y.numSpotShadows===v||(r.directional.length=c,r.spot.length=d,r.rectArea.length=p,r.point.length=u,r.hemi.length=f,r.directionalShadow.length=m,r.directionalShadowMap.length=m,r.pointShadow.length=g,r.pointShadowMap.length=g,r.spotShadow.length=v,r.spotShadowMap.length=v,r.directionalShadowMatrix.length=m,r.pointShadowMatrix.length=g,r.spotShadowMatrix.length=v,y.directionalLength=c,y.pointLength=u,y.spotLength=d,y.rectAreaLength=p,y.hemiLength=f,y.numDirectionalShadows=m,y.numPointShadows=g,y.numSpotShadows=v,r.version=dp++)},setupView:function(t,e){let n=0,i=0,l=0,h=0,c=0;const u=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),n++}else if(d.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const t=r.rectArea[h];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),o.identity(),a.copy(d.matrixWorld),a.premultiply(u),o.extractRotation(a),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),h++}else if(d.isPointLight){const t=r.point[i];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),i++}else if(d.isHemisphereLight){const t=r.hemi[c];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(u),t.direction.normalize(),c++}}},state:r}}function mp(t,e){const n=new fp(t,e),i=[],r=[];return{init:function(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function(t){n.setup(i,t)},setupLightsView:function(t){n.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){r.push(t)}}}function gp(t,e){let n=new WeakMap;return{get:function(i,r=0){let s;return!1===n.has(i)?(s=new mp(t,e),n.set(i,[s])):r>=n.get(i).length?(s=new mp(t,e),n.get(i).push(s)):s=n.get(i)[r],s},dispose:function(){n=new WeakMap}}}class vp extends Fh{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}vp.prototype.isMeshDepthMaterial=!0;class xp extends Fh{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new Ml,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}xp.prototype.isMeshDistanceMaterial=!0;function yp(t,e,n){let i=new Gc;const r=new cl,s=new cl,a=new vl,o=new vp({depthPacking:3201}),l=new xp,h={},c=n.maxTextureSize,u={0:1,1:0,2:2},d=new Ac({uniforms:{shadow_pass:{value:null},resolution:{value:new cl},radius:{value:4},samples:{value:8}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new sc;f.setAttribute("position",new qh(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new wc(f,d),g=this;function v(n,i){const r=e.update(m);d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,d.uniforms.samples.value=n.blurSamples,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,r,d,m,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,p.uniforms.samples.value=n.blurSamples,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,r,p,m,null)}function x(e,n,i,r,s,a,c){let d=null;const p=!0===r.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(d=void 0!==p?p:!0===r.isPointLight?l:o,t.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length||i.displacementMap&&0!==i.displacementScale||i.alphaMap&&i.alphaTest>0){const t=d.uuid,e=i.uuid;let n=h[t];void 0===n&&(n={},h[t]=n);let r=n[e];void 0===r&&(r=d.clone(),n[e]=r),d=r}return d.visible=i.visible,d.wireframe=i.wireframe,d.side=3===c?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:u[i.side],d.alphaMap=i.alphaMap,d.alphaTest=i.alphaTest,d.clipShadows=i.clipShadows,d.clippingPlanes=i.clippingPlanes,d.clipIntersection=i.clipIntersection,d.displacementMap=i.displacementMap,d.displacementScale=i.displacementScale,d.displacementBias=i.displacementBias,d.wireframeLinewidth=i.wireframeLinewidth,d.linewidth=i.linewidth,!0===r.isPointLight&&!0===d.isMeshDistanceMaterial&&(d.referencePosition.setFromMatrixPosition(r.matrixWorld),d.nearDistance=s,d.farDistance=a),d}function y(n,r,s,a,o){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===o)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const i=e.update(n),r=n.material;if(Array.isArray(r)){const e=i.groups;for(let l=0,h=e.length;l<h;l++){const h=e[l],c=r[h.materialIndex];if(c&&c.visible){const e=x(n,0,c,a,s.near,s.far,o);t.renderBufferDirect(s,null,i,e,n,h)}}}else if(r.visible){const e=x(n,0,r,a,s.near,s.far,o);t.renderBufferDirect(s,null,i,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)y(l[t],r,s,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(e,n,o){if(!1===g.enabled)return;if(!1===g.autoUpdate&&!1===g.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),h=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,h=e.length;l<h;l++){const h=e[l],u=h.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",h,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;r.copy(u.mapSize);const p=u.getFrameExtents();if(r.multiply(p),s.copy(u.mapSize),(r.x>c||r.y>c)&&(r.x>c&&(s.x=Math.floor(c/p.x),r.x=s.x*p.x,u.mapSize.x=s.x),r.y>c&&(s.y=Math.floor(c/p.y),r.y=s.y*p.y,u.mapSize.y=s.y)),null===u.map&&!u.isPointLightShadow&&3===this.type){const t={minFilter:Co,magFilter:Co,format:Oo};u.map=new xl(r.x,r.y,t),u.map.texture.name=h.name+".shadowMap",u.mapPass=new xl(r.x,r.y,t),u.camera.updateProjectionMatrix()}if(null===u.map){const t={minFilter:Lo,magFilter:Lo,format:Oo};u.map=new xl(r.x,r.y,t),u.map.texture.name=h.name+".shadowMap",u.camera.updateProjectionMatrix()}t.setRenderTarget(u.map),t.clear();const f=u.getViewportCount();for(let t=0;t<f;t++){const e=u.getViewport(t);a.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(a),u.updateMatrices(h,t),i=u.getFrustum(),y(n,o,u.camera,h,this.type)}u.isPointLightShadow||3!==this.type||v(u,o),u.needsUpdate=!1}g.needsUpdate=!1,t.setRenderTarget(l,h,u)}}function _p(t,e,n){const i=n.isWebGL2;const r=new function(){let e=!1;const n=new vl;let i=null;const r=new vl(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,a,o){!0===o&&(e*=a,i*=a,s*=a),n.set(e,i,s,a),!1===r.equals(n)&&(t.clearColor(e,i,s,a),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,i=null,r=null;return{setTest:function(t){t?O(2929):U(2929)},setMask:function(i){n===i||e||(t.depthMask(i),n=i)},setFunc:function(e){if(i!==e){if(e)switch(e){case 0:t.depthFunc(512);break;case 1:t.depthFunc(519);break;case 2:t.depthFunc(513);break;case 3:t.depthFunc(515);break;case 4:t.depthFunc(514);break;case 5:t.depthFunc(518);break;case 6:t.depthFunc(516);break;case 7:t.depthFunc(517);break;default:t.depthFunc(515)}else t.depthFunc(515);i=e}},setLocked:function(t){e=t},setClear:function(e){r!==e&&(t.clearDepth(e),r=e)},reset:function(){e=!1,n=null,i=null,r=null}}},a=new function(){let e=!1,n=null,i=null,r=null,s=null,a=null,o=null,l=null,h=null;return{setTest:function(t){e||(t?O(2960):U(2960))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,a){i===e&&r===n&&s===a||(t.stencilFunc(e,n,a),i=e,r=n,s=a)},setOp:function(e,n,i){a===e&&o===n&&l===i||(t.stencilOp(e,n,i),a=e,o=n,l=i)},setLocked:function(t){e=t},setClear:function(e){h!==e&&(t.clearStencil(e),h=e)},reset:function(){e=!1,n=null,i=null,r=null,s=null,a=null,o=null,l=null,h=null}}};let o={},l=null,h={},c=null,u=!1,d=null,p=null,f=null,m=null,g=null,v=null,x=null,y=!1,_=null,M=null,b=null,w=null,S=null;const E=t.getParameter(35661);let T=!1,L=0;const C=t.getParameter(7938);-1!==C.indexOf("WebGL")?(L=parseFloat(/^WebGL (\d)/.exec(C)[1]),T=L>=1):-1!==C.indexOf("OpenGL ES")&&(L=parseFloat(/^OpenGL ES (\d)/.exec(C)[1]),T=L>=2);let A=null,R={};const P=t.getParameter(3088),D=t.getParameter(2978),I=(new vl).fromArray(P),N=(new vl).fromArray(D);function z(e,n,i){const r=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let e=0;e<i;e++)t.texImage2D(n+e,0,6408,1,1,0,6408,5121,r);return s}const F={};function O(e){!0!==o[e]&&(t.enable(e),o[e]=!0)}function U(e){!1!==o[e]&&(t.disable(e),o[e]=!1)}F[3553]=z(3553,3553,1),F[34067]=z(34067,34069,6),r.setClear(0,0,0,1),s.setClear(1),a.setClear(0),O(2929),s.setFunc(3),G(!1),V(1),O(2884),H(0);const B={[_o]:32774,101:32778,102:32779};if(i)B[103]=32775,B[104]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(B[103]=t.MIN_EXT,B[104]=t.MAX_EXT)}const k={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function H(e,n,i,r,s,a,o,l){if(0!==e){if(!1===u&&(O(3042),u=!0),5===e)s=s||n,a=a||i,o=o||r,n===p&&s===g||(t.blendEquationSeparate(B[n],B[s]),p=n,g=s),i===f&&r===m&&a===v&&o===x||(t.blendFuncSeparate(k[i],k[r],k[a],k[o]),f=i,m=r,v=a,x=o),d=e,y=null;else if(e!==d||l!==y){if(p===_o&&g===_o||(t.blendEquation(32774),p=_o,g=_o),l)switch(e){case 1:t.blendFuncSeparate(1,771,1,771);break;case 2:t.blendFunc(1,1);break;case 3:t.blendFuncSeparate(0,0,769,771);break;case 4:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(770,771,1,771);break;case 2:t.blendFunc(770,1);break;case 3:t.blendFunc(0,769);break;case 4:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}f=null,m=null,v=null,x=null,d=e,y=l}}else!0===u&&(U(3042),u=!1)}function G(e){_!==e&&(e?t.frontFace(2304):t.frontFace(2305),_=e)}function V(e){0!==e?(O(2884),e!==M&&(1===e?t.cullFace(1029):2===e?t.cullFace(1028):t.cullFace(1032))):U(2884),M=e}function W(e,n,i){e?(O(32823),w===n&&S===i||(t.polygonOffset(n,i),w=n,S=i)):U(32823)}function j(e){void 0===e&&(e=33984+E-1),A!==e&&(t.activeTexture(e),A=e)}return{buffers:{color:r,depth:s,stencil:a},enable:O,disable:U,bindFramebuffer:function(e,n){return null===n&&null!==l&&(n=l),h[e]!==n&&(t.bindFramebuffer(e,n),h[e]=n,i&&(36009===e&&(h[36160]=n),36160===e&&(h[36009]=n)),!0)},bindXRFramebuffer:function(e){e!==l&&(t.bindFramebuffer(36160,e),l=e)},useProgram:function(e){return c!==e&&(t.useProgram(e),c=e,!0)},setBlending:H,setMaterial:function(t,e){2===t.side?U(2884):O(2884);let n=1===t.side;e&&(n=!n),G(n),1===t.blending&&!1===t.transparent?H(0):H(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),s.setFunc(t.depthFunc),s.setTest(t.depthTest),s.setMask(t.depthWrite),r.setMask(t.colorWrite);const i=t.stencilWrite;a.setTest(i),i&&(a.setMask(t.stencilWriteMask),a.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),a.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),W(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?O(32926):U(32926)},setFlipSided:G,setCullFace:V,setLineWidth:function(e){e!==b&&(T&&t.lineWidth(e),b=e)},setPolygonOffset:W,setScissorTest:function(t){t?O(3089):U(3089)},activeTexture:j,bindTexture:function(e,n){null===A&&j();let i=R[A];void 0===i&&(i={type:void 0,texture:void 0},R[A]=i),i.type===e&&i.texture===n||(t.bindTexture(e,n||F[e]),i.type=e,i.texture=n)},unbindTexture:function(){const e=R[A];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===I.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),I.copy(e))},viewport:function(e){!1===N.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),N.copy(e))},reset:function(){t.disable(3042),t.disable(2884),t.disable(2929),t.disable(32823),t.disable(3089),t.disable(2960),t.disable(32926),t.blendEquation(32774),t.blendFunc(1,0),t.blendFuncSeparate(1,0,1,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(513),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(519,0,4294967295),t.stencilOp(7680,7680,7680),t.clearStencil(0),t.cullFace(1029),t.frontFace(2305),t.polygonOffset(0,0),t.activeTexture(33984),t.bindFramebuffer(36160,null),!0===i&&(t.bindFramebuffer(36009,null),t.bindFramebuffer(36008,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),o={},A=null,R={},l=null,h={},c=null,u=!1,d=null,p=null,f=null,m=null,g=null,v=null,x=null,y=!1,_=null,M=null,b=null,w=null,S=null,I.set(0,0,t.canvas.width,t.canvas.height),N.set(0,0,t.canvas.width,t.canvas.height),r.reset(),s.reset(),a.reset()}}}function Mp(t,e,n,i,r,s,a){const o=r.isWebGL2,l=r.maxTextures,h=r.maxCubemapSize,c=r.maxTextureSize,u=r.maxSamples,d=new WeakMap;let p,f=!1;try{f="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function m(t,e){return f?new OffscreenCanvas(t,e):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(t,e,n,i){let r=1;if((t.width>i||t.height>i)&&(r=i/Math.max(t.width,t.height)),r<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const i=e?hl:Math.floor,s=i(r*t.width),a=i(r*t.height);void 0===p&&(p=m(s,a));const o=n?m(s,a):p;o.width=s,o.height=a;return o.getContext("2d").drawImage(t,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+a+")."),o}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function v(t){return ll(t.width)&&ll(t.height)}function x(t,e){return t.generateMipmaps&&e&&t.minFilter!==Lo&&t.minFilter!==Co}function y(e,n,r,s,a=1){t.generateMipmap(e);i.get(n).__maxMipLevel=Math.log2(Math.max(r,s,a))}function _(n,i,r){if(!1===o)return i;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let s=i;return 6403===i&&(5126===r&&(s=33326),5131===r&&(s=33325),5121===r&&(s=33321)),6407===i&&(5126===r&&(s=34837),5131===r&&(s=34843),5121===r&&(s=32849)),6408===i&&(5126===r&&(s=34836),5131===r&&(s=34842),5121===r&&(s=32856)),33325!==s&&33326!==s&&34842!==s&&34836!==s||e.get("EXT_color_buffer_float"),s}function M(t){return t===Lo||1004===t||1005===t?9728:9729}function b(e){const n=e.target;n.removeEventListener("dispose",b),function(e){const n=i.get(e);if(void 0===n.__webglInit)return;t.deleteTexture(n.__webglTexture),i.remove(e)}(n),n.isVideoTexture&&d.delete(n),a.memory.textures--}function w(e){const n=e.target;n.removeEventListener("dispose",w),function(e){const n=e.texture,r=i.get(e),s=i.get(n);if(!e)return;void 0!==s.__webglTexture&&(t.deleteTexture(s.__webglTexture),a.memory.textures--);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(r.__webglFramebuffer[e]),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer[e]);else t.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&t.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer&&t.deleteRenderbuffer(r.__webglColorRenderbuffer),r.__webglDepthRenderbuffer&&t.deleteRenderbuffer(r.__webglDepthRenderbuffer);if(e.isWebGLMultipleRenderTargets)for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);r.__webglTexture&&(t.deleteTexture(r.__webglTexture),a.memory.textures--),i.remove(n[e])}i.remove(n),i.remove(e)}(n)}let S=0;function E(t,e){const r=i.get(t);if(t.isVideoTexture&&function(t){const e=a.render.frame;d.get(t)!==e&&(d.set(t,e),t.update())}(t),t.version>0&&r.__version!==t.version){const n=t.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void P(r,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,r.__webglTexture)}function T(e,r){const a=i.get(e);e.version>0&&a.__version!==e.version?function(e,i,r){if(6!==i.image.length)return;R(e,i),n.activeTexture(33984+r),n.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment),t.pixelStorei(37443,0);const a=i&&(i.isCompressedTexture||i.image[0].isCompressedTexture),l=i.image[0]&&i.image[0].isDataTexture,c=[];for(let t=0;t<6;t++)c[t]=a||l?l?i.image[t].image:i.image[t]:g(i.image[t],!1,!0,h);const u=c[0],d=v(u)||o,p=s.convert(i.format),f=s.convert(i.type),m=_(i.internalFormat,p,f);let M;if(A(34067,i,d),a){for(let t=0;t<6;t++){M=c[t].mipmaps;for(let e=0;e<M.length;e++){const r=M[e];i.format!==Oo&&i.format!==Fo?null!==p?n.compressedTexImage2D(34069+t,e,m,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+t,e,m,r.width,r.height,0,p,f,r.data)}}e.__maxMipLevel=M.length-1}else{M=i.mipmaps;for(let t=0;t<6;t++)if(l){n.texImage2D(34069+t,0,m,c[t].width,c[t].height,0,p,f,c[t].data);for(let e=0;e<M.length;e++){const i=M[e].image[t].image;n.texImage2D(34069+t,e+1,m,i.width,i.height,0,p,f,i.data)}}else{n.texImage2D(34069+t,0,m,p,f,c[t]);for(let e=0;e<M.length;e++){const i=M[e];n.texImage2D(34069+t,e+1,m,p,f,i.image[t])}}e.__maxMipLevel=M.length}x(i,d)&&y(34067,i,u.width,u.height);e.__version=i.version,i.onUpdate&&i.onUpdate(i)}(a,e,r):(n.activeTexture(33984+r),n.bindTexture(34067,a.__webglTexture))}const L={[So]:10497,[Eo]:33071,[To]:33648},C={[Lo]:9728,1004:9984,1005:9986,[Co]:9729,1007:9985,[Ao]:9987};function A(n,s,a){if(a?(t.texParameteri(n,10242,L[s.wrapS]),t.texParameteri(n,10243,L[s.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,L[s.wrapR]),t.texParameteri(n,10240,C[s.magFilter]),t.texParameteri(n,10241,C[s.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),s.wrapS===Eo&&s.wrapT===Eo||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,M(s.magFilter)),t.texParameteri(n,10241,M(s.minFilter)),s.minFilter!==Lo&&s.minFilter!==Co&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const a=e.get("EXT_texture_filter_anisotropic");if(s.type===Io&&!1===e.has("OES_texture_float_linear"))return;if(!1===o&&s.type===No&&!1===e.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||i.get(s).__currentAnisotropy)&&(t.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),i.get(s).__currentAnisotropy=s.anisotropy)}}function R(e,n){void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",b),e.__webglTexture=t.createTexture(),a.memory.textures++)}function P(e,i,r){let a=3553;i.isDataTexture2DArray&&(a=35866),i.isDataTexture3D&&(a=32879),R(e,i),n.activeTexture(33984+r),n.bindTexture(a,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment),t.pixelStorei(37443,0);const l=function(t){return!o&&(t.wrapS!==Eo||t.wrapT!==Eo||t.minFilter!==Lo&&t.minFilter!==Co)}(i)&&!1===v(i.image),h=g(i.image,l,!1,c),u=v(h)||o,d=s.convert(i.format);let p,f=s.convert(i.type),m=_(i.internalFormat,d,f);A(a,i,u);const M=i.mipmaps;if(i.isDepthTexture)m=6402,o?m=i.type===Io?36012:i.type===Do?33190:i.type===zo?35056:33189:i.type===Io&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),i.format===Uo&&6402===m&&i.type!==Po&&i.type!==Do&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),i.type=Po,f=s.convert(i.type)),i.format===Bo&&6402===m&&(m=34041,i.type!==zo&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),i.type=zo,f=s.convert(i.type))),n.texImage2D(3553,0,m,h.width,h.height,0,d,f,null);else if(i.isDataTexture)if(M.length>0&&u){for(let t=0,e=M.length;t<e;t++)p=M[t],n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);i.generateMipmaps=!1,e.__maxMipLevel=M.length-1}else n.texImage2D(3553,0,m,h.width,h.height,0,d,f,h.data),e.__maxMipLevel=0;else if(i.isCompressedTexture){for(let t=0,e=M.length;t<e;t++)p=M[t],i.format!==Oo&&i.format!==Fo?null!==d?n.compressedTexImage2D(3553,t,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);e.__maxMipLevel=M.length-1}else if(i.isDataTexture2DArray)n.texImage3D(35866,0,m,h.width,h.height,h.depth,0,d,f,h.data),e.__maxMipLevel=0;else if(i.isDataTexture3D)n.texImage3D(32879,0,m,h.width,h.height,h.depth,0,d,f,h.data),e.__maxMipLevel=0;else if(M.length>0&&u){for(let t=0,e=M.length;t<e;t++)p=M[t],n.texImage2D(3553,t,m,d,f,p);i.generateMipmaps=!1,e.__maxMipLevel=M.length-1}else n.texImage2D(3553,0,m,d,f,h),e.__maxMipLevel=0;x(i,u)&&y(a,i,h.width,h.height),e.__version=i.version,i.onUpdate&&i.onUpdate(i)}function D(e,r,a,o,l){const h=s.convert(a.format),c=s.convert(a.type),u=_(a.internalFormat,h,c);32879===l||35866===l?n.texImage3D(l,0,u,r.width,r.height,r.depth,0,h,c,null):n.texImage2D(l,0,u,r.width,r.height,0,h,c,null),n.bindFramebuffer(36160,e),t.framebufferTexture2D(36160,o,l,i.get(a).__webglTexture,0),n.bindFramebuffer(36160,null)}function I(e,n,i){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let r=33189;if(i){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===Io?r=36012:e.type===Do&&(r=33190));const i=z(n);t.renderbufferStorageMultisample(36161,i,r,n.width,n.height)}else t.renderbufferStorage(36161,r,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){if(i){const e=z(n);t.renderbufferStorageMultisample(36161,e,35056,n.width,n.height)}else t.renderbufferStorage(36161,34041,n.width,n.height);t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture[0]:n.texture,r=s.convert(e.format),a=s.convert(e.type),o=_(e.internalFormat,r,a);if(i){const e=z(n);t.renderbufferStorageMultisample(36161,e,o,n.width,n.height)}else t.renderbufferStorage(36161,o,n.width,n.height)}t.bindRenderbuffer(36161,null)}function N(e){const r=i.get(e),s=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),E(r.depthTexture,0);const s=i.get(r.depthTexture).__webglTexture;if(r.depthTexture.format===Uo)t.framebufferTexture2D(36160,36096,3553,s,0);else{if(r.depthTexture.format!==Bo)throw new Error("Unknown depthTexture format");t.framebufferTexture2D(36160,33306,3553,s,0)}}(r.__webglFramebuffer,e)}else if(s){r.__webglDepthbuffer=[];for(let i=0;i<6;i++)n.bindFramebuffer(36160,r.__webglFramebuffer[i]),r.__webglDepthbuffer[i]=t.createRenderbuffer(),I(r.__webglDepthbuffer[i],e,!1)}else n.bindFramebuffer(36160,r.__webglFramebuffer),r.__webglDepthbuffer=t.createRenderbuffer(),I(r.__webglDepthbuffer,e,!1);n.bindFramebuffer(36160,null)}function z(t){return o&&t.isWebGLMultisampleRenderTarget?Math.min(u,t.samples):0}let F=!1,O=!1;this.allocateTextureUnit=function(){const t=S;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),S+=1,t},this.resetTextureUnits=function(){S=0},this.setTexture2D=E,this.setTexture2DArray=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?P(r,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,r.__webglTexture))},this.setTexture3D=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?P(r,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,r.__webglTexture))},this.setTextureCube=T,this.setupRenderTarget=function(e){const l=e.texture,h=i.get(e),c=i.get(l);e.addEventListener("dispose",w),!0!==e.isWebGLMultipleRenderTargets&&(c.__webglTexture=t.createTexture(),c.__version=l.version,a.memory.textures++);const u=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=!0===e.isWebGLMultisampleRenderTarget,f=l.isDataTexture3D||l.isDataTexture2DArray,m=v(e)||o;if(!o||l.format!==Fo||l.type!==Io&&l.type!==No||(l.format=Oo,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),u){h.__webglFramebuffer=[];for(let e=0;e<6;e++)h.__webglFramebuffer[e]=t.createFramebuffer()}else if(h.__webglFramebuffer=t.createFramebuffer(),d)if(r.drawBuffers){const n=e.texture;for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);void 0===r.__webglTexture&&(r.__webglTexture=t.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(p)if(o){h.__webglMultisampledFramebuffer=t.createFramebuffer(),h.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,h.__webglColorRenderbuffer);const i=s.convert(l.format),r=s.convert(l.type),a=_(l.internalFormat,i,r),o=z(e);t.renderbufferStorageMultisample(36161,o,a,e.width,e.height),n.bindFramebuffer(36160,h.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,h.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(h.__webglDepthRenderbuffer=t.createRenderbuffer(),I(h.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(u){n.bindTexture(34067,c.__webglTexture),A(34067,l,m);for(let t=0;t<6;t++)D(h.__webglFramebuffer[t],e,l,36064,34069+t);x(l,m)&&y(34067,l,e.width,e.height),n.unbindTexture()}else if(d){const t=e.texture;for(let r=0,s=t.length;r<s;r++){const s=t[r],a=i.get(s);n.bindTexture(3553,a.__webglTexture),A(3553,s,m),D(h.__webglFramebuffer,e,s,36064+r,3553),x(s,m)&&y(3553,s,e.width,e.height)}n.unbindTexture()}else{let t=3553;if(f)if(o){t=l.isDataTexture3D?32879:35866}else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");n.bindTexture(t,c.__webglTexture),A(t,l,m),D(h.__webglFramebuffer,e,l,36064,t),x(l,m)&&y(t,l,e.width,e.height,e.depth),n.unbindTexture()}e.depthBuffer&&N(e)},this.updateRenderTargetMipmap=function(t){const e=v(t)||o,r=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let s=0,a=r.length;s<a;s++){const a=r[s];if(x(a,e)){const e=t.isWebGLCubeRenderTarget?34067:3553,r=i.get(a).__webglTexture;n.bindTexture(e,r),y(e,a,t.width,t.height),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.isWebGLMultisampleRenderTarget)if(o){const r=e.width,s=e.height;let a=16384;e.depthBuffer&&(a|=256),e.stencilBuffer&&(a|=1024);const o=i.get(e);n.bindFramebuffer(36008,o.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,o.__webglFramebuffer),t.blitFramebuffer(0,0,r,s,0,0,r,s,a,9728),n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,o.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===F&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),F=!0),t=t.texture),E(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===O&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),O=!0),t=t.texture),T(t,e)}}function bp(t,e,n){const i=n.isWebGL2;return{convert:function(t){let n;if(t===Ro)return 5121;if(1017===t)return 32819;if(1018===t)return 32820;if(1019===t)return 33635;if(1010===t)return 5120;if(1011===t)return 5122;if(t===Po)return 5123;if(1013===t)return 5124;if(t===Do)return 5125;if(t===Io)return 5126;if(t===No)return i?5131:(n=e.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(1021===t)return 6406;if(t===Fo)return 6407;if(t===Oo)return 6408;if(1024===t)return 6409;if(1025===t)return 6410;if(t===Uo)return 6402;if(t===Bo)return 34041;if(1028===t)return 6403;if(1029===t)return 36244;if(1030===t)return 33319;if(1031===t)return 33320;if(1032===t)return 36248;if(1033===t)return 36249;if(33776===t||33777===t||33778===t||33779===t){if(n=e.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(33776===t)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===t)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===t)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===t)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===t||35841===t||35842===t||35843===t){if(n=e.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(35840===t)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===t)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===t)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===t)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===t)return n=e.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===t||37496===t)&&(n=e.get("WEBGL_compressed_texture_etc"),null!==n)){if(37492===t)return n.COMPRESSED_RGB8_ETC2;if(37496===t)return n.COMPRESSED_RGBA8_ETC2_EAC}return 37808===t||37809===t||37810===t||37811===t||37812===t||37813===t||37814===t||37815===t||37816===t||37817===t||37818===t||37819===t||37820===t||37821===t||37840===t||37841===t||37842===t||37843===t||37844===t||37845===t||37846===t||37847===t||37848===t||37849===t||37850===t||37851===t||37852===t||37853===t?(n=e.get("WEBGL_compressed_texture_astc"),null!==n?t:null):36492===t?(n=e.get("EXT_texture_compression_bptc"),null!==n?t:null):t===zo?i?34042:(n=e.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}class wp extends Pc{constructor(t=[]){super(),this.cameras=t}}wp.prototype.isArrayCamera=!0;class Sp extends wh{constructor(){super(),this.type="Group"}}Sp.prototype.isGroup=!0;const Ep={type:"move"};class Tp{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new Sp,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new Sp,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Ml,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Ml),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new Sp,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Ml,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Ml),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(null!==a&&(i=e.getPose(t.targetRaySpace,n),null!==i&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(Ep))),l&&t.hand){s=!0;for(const i of t.hand.values()){const t=e.getJointPose(i,n);if(void 0===l.joints[i.jointName]){const t=new Sp;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[i.jointName]=t,l.add(t)}const r=l.joints[i.jointName];null!==t&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.jointRadius=t.radius),r.visible=null!==t}const i=l.joints["index-finger-tip"],r=l.joints["thumb-tip"],a=i.position.distanceTo(r.position),o=.02,h=.005;l.inputState.pinching&&a>o+h?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&a<=o-h&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1));return null!==a&&(a.visible=null!==i),null!==o&&(o.visible=null!==r),null!==l&&(l.visible=null!==s),this}}class Lp extends el{constructor(t,e){super();const n=this,i=t.state;let r=null,s=1,a=null,o="local-floor",l=null,h=null,c=null,u=null,d=null,p=!1,f=null,m=null,g=null,v=null,x=null,y=null;const _=[],M=new Map,b=new Pc;b.layers.enable(1),b.viewport=new vl;const w=new Pc;w.layers.enable(2),w.viewport=new vl;const S=[b,w],E=new wp;E.layers.enable(1),E.layers.enable(2);let T=null,L=null;function C(t){const e=M.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function A(){M.forEach((function(t,e){t.disconnect(e)})),M.clear(),T=null,L=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),c&&e.deleteFramebuffer(c),f&&e.deleteFramebuffer(f),m&&e.deleteRenderbuffer(m),g&&e.deleteRenderbuffer(g),c=null,f=null,m=null,g=null,d=null,u=null,h=null,r=null,z.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function R(t){const e=r.inputSources;for(let t=0;t<_.length;t++)M.set(e[t],_[t]);for(let e=0;e<t.removed.length;e++){const n=t.removed[e],i=M.get(n);i&&(i.dispatchEvent({type:"disconnected",data:n}),M.delete(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e],i=M.get(n);i&&i.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=_[t];return void 0===e&&(e=new Tp,_[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=_[t];return void 0===e&&(e=new Tp,_[t]=e),e.getGripSpace()},this.getHand=function(t){let e=_[t];return void 0===e&&(e=new Tp,_[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){s=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return h},this.getFrame=function(){return v},this.getSession=function(){return r},this.setSession=async function(t){if(r=t,null!==r){r.addEventListener("select",C),r.addEventListener("selectstart",C),r.addEventListener("selectend",C),r.addEventListener("squeeze",C),r.addEventListener("squeezestart",C),r.addEventListener("squeezeend",C),r.addEventListener("end",A),r.addEventListener("inputsourceschange",R);const t=e.getContextAttributes();if(!0!==t.xrCompatible&&await e.makeXRCompatible(),void 0===r.renderState.layers){const n={antialias:t.antialias,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(r,e,n),r.updateRenderState({baseLayer:d})}else if(e instanceof WebGLRenderingContext){const n={antialias:!0,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(r,e,n),r.updateRenderState({layers:[d]})}else{p=t.antialias;let n=null;t.depth&&(y=256,t.stencil&&(y|=1024),x=t.stencil?33306:36096,n=t.stencil?35056:33190);const a={colorFormat:t.alpha?32856:32849,depthFormat:n,scaleFactor:s};h=new XRWebGLBinding(r,e),u=h.createProjectionLayer(a),c=e.createFramebuffer(),r.updateRenderState({layers:[u]}),p&&(f=e.createFramebuffer(),m=e.createRenderbuffer(),e.bindRenderbuffer(36161,m),e.renderbufferStorageMultisample(36161,4,32856,u.textureWidth,u.textureHeight),i.bindFramebuffer(36160,f),e.framebufferRenderbuffer(36160,36064,36161,m),e.bindRenderbuffer(36161,null),null!==n&&(g=e.createRenderbuffer(),e.bindRenderbuffer(36161,g),e.renderbufferStorageMultisample(36161,4,n,u.textureWidth,u.textureHeight),e.framebufferRenderbuffer(36160,x,36161,g),e.bindRenderbuffer(36161,null)),i.bindFramebuffer(36160,null))}a=await r.requestReferenceSpace(o),z.setContext(r),z.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const P=new Ml,D=new Ml;function I(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===r)return;E.near=w.near=b.near=t.near,E.far=w.far=b.far=t.far,T===E.near&&L===E.far||(r.updateRenderState({depthNear:E.near,depthFar:E.far}),T=E.near,L=E.far);const e=t.parent,n=E.cameras;I(E,e);for(let t=0;t<n.length;t++)I(n[t],e);E.matrixWorld.decompose(E.position,E.quaternion,E.scale),t.position.copy(E.position),t.quaternion.copy(E.quaternion),t.scale.copy(E.scale),t.matrix.copy(E.matrix),t.matrixWorld.copy(E.matrixWorld);const i=t.children;for(let t=0,e=i.length;t<e;t++)i[t].updateMatrixWorld(!0);2===n.length?function(t,e,n){P.setFromMatrixPosition(e.matrixWorld),D.setFromMatrixPosition(n.matrixWorld);const i=P.distanceTo(D),r=e.projectionMatrix.elements,s=n.projectionMatrix.elements,a=r[14]/(r[10]-1),o=r[14]/(r[10]+1),l=(r[9]+1)/r[5],h=(r[9]-1)/r[5],c=(r[8]-1)/r[0],u=(s[8]+1)/s[0],d=a*c,p=a*u,f=i/(-c+u),m=f*-c;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=a+f,v=o+f,x=d-m,y=p+(i-m),_=l*o/v*g,M=h*o/v*g;t.projectionMatrix.makePerspective(x,y,_,M,g,v)}(E,b,w):E.projectionMatrix.copy(b.projectionMatrix)},this.getCamera=function(){return E},this.getFoveation=function(){return null!==u?u.fixedFoveation:null!==d?d.fixedFoveation:void 0},this.setFoveation=function(t){null!==u&&(u.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)};let N=null;const z=new Vc;z.setAnimationLoop((function(t,n){if(l=n.getViewerPose(a),v=n,null!==l){const t=l.views;null!==d&&i.bindXRFramebuffer(d.framebuffer);let n=!1;t.length!==E.cameras.length&&(E.cameras.length=0,n=!0);for(let r=0;r<t.length;r++){const s=t[r];let a=null;if(null!==d)a=d.getViewport(s);else{const t=h.getViewSubImage(u,s);i.bindXRFramebuffer(c),void 0!==t.depthStencilTexture&&e.framebufferTexture2D(36160,x,3553,t.depthStencilTexture,0),e.framebufferTexture2D(36160,36064,3553,t.colorTexture,0),a=t.viewport}const o=S[r];o.matrix.fromArray(s.transform.matrix),o.projectionMatrix.fromArray(s.projectionMatrix),o.viewport.set(a.x,a.y,a.width,a.height),0===r&&E.matrix.copy(o.matrix),!0===n&&E.cameras.push(o)}p&&(i.bindXRFramebuffer(f),null!==y&&e.clear(y))}const s=r.inputSources;for(let t=0;t<_.length;t++){const e=_[t],i=s[t];e.update(i,n,a)}if(N&&N(t,n),p){const t=u.textureWidth,n=u.textureHeight;i.bindFramebuffer(36008,f),i.bindFramebuffer(36009,c),e.invalidateFramebuffer(36008,[x]),e.invalidateFramebuffer(36009,[x]),e.blitFramebuffer(0,0,t,n,0,0,t,n,16384,9728),e.invalidateFramebuffer(36008,[36064]),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null),i.bindFramebuffer(36160,f)}v=null})),this.setAnimationLoop=function(t){N=t},this.dispose=function(){}}}function Cp(t){function e(e,n){e.opacity.value=n.opacity,n.color&&e.diffuse.value.copy(n.color),n.emissive&&e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.specularMap&&(e.specularMap.value=n.specularMap),n.alphaTest>0&&(e.alphaTest.value=n.alphaTest);const i=t.get(n).envMap;if(i){e.envMap.value=i,e.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,e.reflectivity.value=n.reflectivity,e.ior.value=n.ior,e.refractionRatio.value=n.refractionRatio;const r=t.get(i).__maxMipLevel;void 0!==r&&(e.maxMipLevel.value=r)}let r,s;n.lightMap&&(e.lightMap.value=n.lightMap,e.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(e.aoMap.value=n.aoMap,e.aoMapIntensity.value=n.aoMapIntensity),n.map?r=n.map:n.specularMap?r=n.specularMap:n.displacementMap?r=n.displacementMap:n.normalMap?r=n.normalMap:n.bumpMap?r=n.bumpMap:n.roughnessMap?r=n.roughnessMap:n.metalnessMap?r=n.metalnessMap:n.alphaMap?r=n.alphaMap:n.emissiveMap?r=n.emissiveMap:n.clearcoatMap?r=n.clearcoatMap:n.clearcoatNormalMap?r=n.clearcoatNormalMap:n.clearcoatRoughnessMap?r=n.clearcoatRoughnessMap:n.specularIntensityMap?r=n.specularIntensityMap:n.specularTintMap?r=n.specularTintMap:n.transmissionMap?r=n.transmissionMap:n.thicknessMap&&(r=n.thicknessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uvTransform.value.copy(r.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),e.uv2Transform.value.copy(s.matrix))}function n(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(e.emissiveMap.value=n.emissiveMap),n.bumpMap&&(e.bumpMap.value=n.bumpMap,e.bumpScale.value=n.bumpScale,1===n.side&&(e.bumpScale.value*=-1)),n.normalMap&&(e.normalMap.value=n.normalMap,e.normalScale.value.copy(n.normalScale),1===n.side&&e.normalScale.value.negate()),n.displacementMap&&(e.displacementMap.value=n.displacementMap,e.displacementScale.value=n.displacementScale,e.displacementBias.value=n.displacementBias);t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,i,r,s,a){i.isMeshBasicMaterial?e(t,i):i.isMeshLambertMaterial?(e(t,i),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,i)):i.isMeshToonMaterial?(e(t,i),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap);e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshPhongMaterial?(e(t,i),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshStandardMaterial?(e(t,i),i.isMeshPhysicalMaterial?function(t,e,i){n(t,e),t.ior.value=e.ior,e.sheenTint&&t.sheenTint.value.copy(e.sheenTint);e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,1===e.side&&t.clearcoatNormalScale.value.negate()));e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=i.texture,t.transmissionSamplerSize.value.set(i.width,i.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap),t.attenuationDistance.value=e.attenuationDistance,t.attenuationTint.value.copy(e.attenuationTint));t.specularIntensity.value=e.specularIntensity,t.specularTint.value.copy(e.specularTint),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap);e.specularTintMap&&(t.specularTintMap.value=e.specularTintMap)}(t,i,a):n(t,i)):i.isMeshMatcapMaterial?(e(t,i),function(t,e){e.matcap&&(t.matcap.value=e.matcap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDepthMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDistanceMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias);t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,i)):i.isMeshNormalMaterial?(e(t,i),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,i),i.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,i)):i.isPointsMaterial?function(t,e,n,i){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*i,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);e.alphaTest>0&&(t.alphaTest.value=e.alphaTest);let r;e.map?r=e.map:e.alphaMap&&(r=e.alphaMap);void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uvTransform.value.copy(r.matrix))}(t,i,r,s):i.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);e.alphaTest>0&&(t.alphaTest.value=e.alphaTest);let n;e.map?n=e.map:e.alphaMap&&(n=e.alphaMap);void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,i):i.isShadowMaterial?(t.color.value.copy(i.color),t.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function Ap(t={}){const e=void 0!==t.canvas?t.canvas:function(){const t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,i=void 0!==t.alpha&&t.alpha,r=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,a=void 0!==t.antialias&&t.antialias,o=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,h=void 0!==t.powerPreference?t.powerPreference:"default",c=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let u=null,d=null;const p=[],f=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=qo,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const m=this;let g=!1,v=0,x=0,y=null,_=-1,M=null;const b=new vl,w=new vl;let S=null,E=e.width,T=e.height,L=1,C=null,A=null;const R=new vl(0,0,E,T),P=new vl(0,0,E,T);let D=!1;const I=[],N=new Gc;let z=!1,F=!1,O=null;const U=new Kl,B=new Ml,k={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function H(){return null===y?L:1}let G,V,W,j,X,q,Y,Z,J,Q,K,$,tt,et,nt,it,rt,st,at,ot,lt,ht,ct,ut=n;function dt(t,n){for(let i=0;i<t.length;i++){const r=t[i],s=e.getContext(r,n);if(null!==s)return s}return null}try{const t={alpha:i,depth:r,stencil:s,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:h,failIfMajorPerformanceCaveat:c};if(e.addEventListener("webglcontextlost",mt,!1),e.addEventListener("webglcontextrestored",gt,!1),null===ut){const e=["webgl2","webgl","experimental-webgl"];if(!0===m.isWebGL1Renderer&&e.shift(),ut=dt(e,t),null===ut)throw dt(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===ut.getShaderPrecisionFormat&&(ut.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function pt(){G=new Lu(ut),V=new Kc(ut,G,t),G.init(V),ht=new bp(ut,G,V),W=new _p(ut,G,V),I[0]=1029,j=new Ru(ut),X=new ap,q=new Mp(ut,G,W,X,V,ht,j),Y=new tu(m),Z=new Tu(m),J=new Wc(ut,V),ct=new Jc(ut,G,J,V),Q=new Cu(ut,J,j,ct),K=new Nu(ut,Q,J,j),at=new Iu(ut),it=new $c(X),$=new sp(m,Y,Z,G,V,ct,it),tt=new Cp(X),et=new cp(X),nt=new gp(G,V),st=new Zc(m,Y,W,K,o),rt=new yp(m,K,V),ot=new Qc(ut,G,j,V),lt=new Au(ut,G,j,V),j.programs=$.programs,m.capabilities=V,m.extensions=G,m.properties=X,m.renderLists=et,m.shadowMap=rt,m.state=W,m.info=j}pt();const ft=new Lp(m,ut);function mt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),g=!0}function gt(){console.log("THREE.WebGLRenderer: Context Restored."),g=!1;const t=j.autoReset,e=rt.enabled,n=rt.autoUpdate,i=rt.needsUpdate,r=rt.type;pt(),j.autoReset=t,rt.enabled=e,rt.autoUpdate=n,rt.needsUpdate=i,rt.type=r}function vt(t){const e=t.target;e.removeEventListener("dispose",vt),function(t){(function(t){const e=X.get(t).programs;void 0!==e&&e.forEach((function(t){$.releaseProgram(t)}))})(t),X.remove(t)}(e)}this.xr=ft,this.getContext=function(){return ut},this.getContextAttributes=function(){return ut.getContextAttributes()},this.forceContextLoss=function(){const t=G.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=G.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return L},this.setPixelRatio=function(t){void 0!==t&&(L=t,this.setSize(E,T,!1))},this.getSize=function(t){return t.set(E,T)},this.setSize=function(t,n,i){ft.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(E=t,T=n,e.width=Math.floor(t*L),e.height=Math.floor(n*L),!1!==i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(E*L,T*L).floor()},this.setDrawingBufferSize=function(t,n,i){E=t,T=n,L=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(b)},this.getViewport=function(t){return t.copy(R)},this.setViewport=function(t,e,n,i){t.isVector4?R.set(t.x,t.y,t.z,t.w):R.set(t,e,n,i),W.viewport(b.copy(R).multiplyScalar(L).floor())},this.getScissor=function(t){return t.copy(P)},this.setScissor=function(t,e,n,i){t.isVector4?P.set(t.x,t.y,t.z,t.w):P.set(t,e,n,i),W.scissor(w.copy(P).multiplyScalar(L).floor())},this.getScissorTest=function(){return D},this.setScissorTest=function(t){W.setScissorTest(D=t)},this.setOpaqueSort=function(t){C=t},this.setTransparentSort=function(t){A=t},this.getClearColor=function(t){return t.copy(st.getClearColor())},this.setClearColor=function(){st.setClearColor.apply(st,arguments)},this.getClearAlpha=function(){return st.getClearAlpha()},this.setClearAlpha=function(){st.setClearAlpha.apply(st,arguments)},this.clear=function(t,e,n){let i=0;(void 0===t||t)&&(i|=16384),(void 0===e||e)&&(i|=256),(void 0===n||n)&&(i|=1024),ut.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",mt,!1),e.removeEventListener("webglcontextrestored",gt,!1),et.dispose(),nt.dispose(),X.dispose(),Y.dispose(),Z.dispose(),K.dispose(),ct.dispose(),ft.dispose(),ft.removeEventListener("sessionstart",yt),ft.removeEventListener("sessionend",_t),O&&(O.dispose(),O=null),Mt.stop()},this.renderBufferImmediate=function(t,e){ct.initAttributes();const n=X.get(t);t.hasPositions&&!n.position&&(n.position=ut.createBuffer()),t.hasNormals&&!n.normal&&(n.normal=ut.createBuffer()),t.hasUvs&&!n.uv&&(n.uv=ut.createBuffer()),t.hasColors&&!n.color&&(n.color=ut.createBuffer());const i=e.getAttributes();t.hasPositions&&(ut.bindBuffer(34962,n.position),ut.bufferData(34962,t.positionArray,35048),ct.enableAttribute(i.position.location),ut.vertexAttribPointer(i.position.location,3,5126,!1,0,0)),t.hasNormals&&(ut.bindBuffer(34962,n.normal),ut.bufferData(34962,t.normalArray,35048),ct.enableAttribute(i.normal.location),ut.vertexAttribPointer(i.normal.location,3,5126,!1,0,0)),t.hasUvs&&(ut.bindBuffer(34962,n.uv),ut.bufferData(34962,t.uvArray,35048),ct.enableAttribute(i.uv.location),ut.vertexAttribPointer(i.uv.location,2,5126,!1,0,0)),t.hasColors&&(ut.bindBuffer(34962,n.color),ut.bufferData(34962,t.colorArray,35048),ct.enableAttribute(i.color.location),ut.vertexAttribPointer(i.color.location,3,5126,!1,0,0)),ct.disableUnusedAttributes(),ut.drawArrays(4,0,t.count),t.count=0},this.renderBufferDirect=function(t,e,n,i,r,s){null===e&&(e=k);const a=r.isMesh&&r.matrixWorld.determinant()<0,o=Ct(t,e,i,r);W.setMaterial(i,a);let l=n.index;const h=n.attributes.position;if(null===l){if(void 0===h||0===h.count)return}else if(0===l.count)return;let c,u=1;!0===i.wireframe&&(l=Q.getWireframeAttribute(n),u=2),void 0===n.morphAttributes.position&&void 0===n.morphAttributes.normal||at.update(r,n,i,o),ct.setup(r,i,o,n,l);let d=ot;null!==l&&(c=J.get(l),d=lt,d.setIndex(c));const p=null!==l?l.count:h.count,f=n.drawRange.start*u,m=n.drawRange.count*u,g=null!==s?s.start*u:0,v=null!==s?s.count*u:1/0,x=Math.max(f,g),y=Math.min(p,f+m,g+v)-1,_=Math.max(0,y-x+1);if(0!==_){if(r.isMesh)!0===i.wireframe?(W.setLineWidth(i.wireframeLinewidth*H()),d.setMode(1)):d.setMode(4);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),W.setLineWidth(t*H()),r.isLineSegments?d.setMode(1):r.isLineLoop?d.setMode(2):d.setMode(3)}else r.isPoints?d.setMode(0):r.isSprite&&d.setMode(4);if(r.isInstancedMesh)d.renderInstances(x,_,r.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(x,_,t)}else d.render(x,_)}},this.compile=function(t,e){d=nt.get(t),d.init(),f.push(d),t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(d.pushLight(t),t.castShadow&&d.pushShadow(t))})),d.setupLights(m.physicallyCorrectLights),t.traverse((function(e){const n=e.material;if(n)if(Array.isArray(n))for(let i=0;i<n.length;i++){Tt(n[i],t,e)}else Tt(n,t,e)})),f.pop(),d=null};let xt=null;function yt(){Mt.stop()}function _t(){Mt.start()}const Mt=new Vc;function bt(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)d.pushLight(t),t.castShadow&&d.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||N.intersectsSprite(t)){i&&B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);const e=K.update(t),r=t.material;r.visible&&u.push(t,e,r,n,B.z,null)}}else if(t.isImmediateRenderObject)i&&B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U),u.push(t,null,t.material,n,B.z,null);else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==j.render.frame&&(t.skeleton.update(),t.skeleton.frame=j.render.frame),!t.frustumCulled||N.intersectsObject(t))){i&&B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);const e=K.update(t),r=t.material;if(Array.isArray(r)){const i=e.groups;for(let s=0,a=i.length;s<a;s++){const a=i[s],o=r[a.materialIndex];o&&o.visible&&u.push(t,e,o,n,B.z,a)}}else r.visible&&u.push(t,e,r,n,B.z,null)}const r=t.children;for(let t=0,s=r.length;t<s;t++)bt(r[t],e,n,i)}function wt(t,e,n,i){const r=t.opaque,s=t.transmissive,o=t.transparent;d.setupLightsView(n),s.length>0&&function(t,e,n){if(null===O){const t=!0===a&&!0===V.isWebGL2;O=new(t?yl:xl)(1024,1024,{generateMipmaps:!0,type:null!==ht.convert(No)?No:Ro,minFilter:Ao,magFilter:Lo,wrapS:Eo,wrapT:Eo})}const i=m.getRenderTarget();m.setRenderTarget(O),m.clear();const r=m.toneMapping;m.toneMapping=0,St(t,e,n),m.toneMapping=r,q.updateMultisampleRenderTarget(O),q.updateRenderTargetMipmap(O),m.setRenderTarget(i)}(r,e,n),i&&W.viewport(b.copy(i)),r.length>0&&St(r,e,n),s.length>0&&St(s,e,n),o.length>0&&St(o,e,n)}function St(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,s=t.length;r<s;r++){const s=t[r],a=s.object,o=s.geometry,l=null===i?s.material:i,h=s.group;a.layers.test(n.layers)&&Et(a,e,n,o,l,h)}}function Et(t,e,n,i,r,s){if(t.onBeforeRender(m,e,n,i,r,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){const i=Ct(n,e,r,t);W.setMaterial(r),ct.reset(),function(t,e){t.render((function(t){m.renderBufferImmediate(t,e)}))}(t,i)}else!0===r.transparent&&2===r.side?(r.side=1,r.needsUpdate=!0,m.renderBufferDirect(n,e,i,r,t,s),r.side=0,r.needsUpdate=!0,m.renderBufferDirect(n,e,i,r,t,s),r.side=2):m.renderBufferDirect(n,e,i,r,t,s);t.onAfterRender(m,e,n,i,r,s)}function Tt(t,e,n){!0!==e.isScene&&(e=k);const i=X.get(t),r=d.state.lights,s=d.state.shadowsArray,a=r.state.version,o=$.getParameters(t,r.state,s,e,n),l=$.getProgramCacheKey(o);let h=i.programs;i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=(t.isMeshStandardMaterial?Z:Y).get(t.envMap||i.environment),void 0===h&&(t.addEventListener("dispose",vt),h=new Map,i.programs=h);let c=h.get(l);if(void 0!==c){if(i.currentProgram===c&&i.lightsStateVersion===a)return Lt(t,o),c}else o.uniforms=$.getUniforms(t),t.onBuild(o,m),t.onBeforeCompile(o,m),c=$.acquireProgram(o,l),h.set(l,c),i.uniforms=o.uniforms;const u=i.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=it.uniform),Lt(t,o),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=a,i.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotShadowMatrix.value=r.state.spotShadowMatrix,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix);const p=c.getUniforms(),f=Ud.seqWithValue(p.seq,u);return i.currentProgram=c,i.uniformsList=f,c}function Lt(t,e){const n=X.get(t);n.outputEncoding=e.outputEncoding,n.instancing=e.instancing,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents}function Ct(t,e,n,i){!0!==e.isScene&&(e=k),q.resetTextureUnits();const r=e.fog,s=n.isMeshStandardMaterial?e.environment:null,a=null===y?m.outputEncoding:y.texture.encoding,o=(n.isMeshStandardMaterial?Z:Y).get(n.envMap||s),l=!0===n.vertexColors&&!!i.geometry&&!!i.geometry.attributes.color&&4===i.geometry.attributes.color.itemSize,h=!!i.geometry&&!!i.geometry.attributes.tangent,c=!!i.geometry&&!!i.geometry.morphAttributes.position,u=!!i.geometry&&!!i.geometry.morphAttributes.normal,p=X.get(n),f=d.state.lights;if(!0===z&&(!0===F||t!==M)){const e=t===M&&n.id===_;it.setState(n,t,e)}let g=!1;n.version===p.__version?p.needsLights&&p.lightsStateVersion!==f.state.version||p.outputEncoding!==a||i.isInstancedMesh&&!1===p.instancing?g=!0:i.isInstancedMesh||!0!==p.instancing?i.isSkinnedMesh&&!1===p.skinning?g=!0:i.isSkinnedMesh||!0!==p.skinning?p.envMap!==o||n.fog&&p.fog!==r?g=!0:void 0===p.numClippingPlanes||p.numClippingPlanes===it.numPlanes&&p.numIntersection===it.numIntersection?(p.vertexAlphas!==l||p.vertexTangents!==h||p.morphTargets!==c||p.morphNormals!==u)&&(g=!0):g=!0:g=!0:g=!0:(g=!0,p.__version=n.version);let v=p.currentProgram;!0===g&&(v=Tt(n,e,i));let x=!1,b=!1,w=!1;const S=v.getUniforms(),E=p.uniforms;if(W.useProgram(v.program)&&(x=!0,b=!0,w=!0),n.id!==_&&(_=n.id,b=!0),x||M!==t){if(S.setValue(ut,"projectionMatrix",t.projectionMatrix),V.logarithmicDepthBuffer&&S.setValue(ut,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),M!==t&&(M=t,b=!0,w=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const e=S.map.cameraPosition;void 0!==e&&e.setValue(ut,B.setFromMatrixPosition(t.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&S.setValue(ut,"isOrthographic",!0===t.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||i.isSkinnedMesh)&&S.setValue(ut,"viewMatrix",t.matrixWorldInverse)}if(i.isSkinnedMesh){S.setOptional(ut,i,"bindMatrix"),S.setOptional(ut,i,"bindMatrixInverse");const t=i.skeleton;t&&(V.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),S.setValue(ut,"boneTexture",t.boneTexture,q),S.setValue(ut,"boneTextureSize",t.boneTextureSize)):S.setOptional(ut,t,"boneMatrices"))}return(b||p.receiveShadow!==i.receiveShadow)&&(p.receiveShadow=i.receiveShadow,S.setValue(ut,"receiveShadow",i.receiveShadow)),b&&(S.setValue(ut,"toneMappingExposure",m.toneMappingExposure),p.needsLights&&function(t,e){t.ambientLightColor.needsUpdate=e,t.lightProbe.needsUpdate=e,t.directionalLights.needsUpdate=e,t.directionalLightShadows.needsUpdate=e,t.pointLights.needsUpdate=e,t.pointLightShadows.needsUpdate=e,t.spotLights.needsUpdate=e,t.spotLightShadows.needsUpdate=e,t.rectAreaLights.needsUpdate=e,t.hemisphereLights.needsUpdate=e}(E,w),r&&n.fog&&tt.refreshFogUniforms(E,r),tt.refreshMaterialUniforms(E,n,L,T,O),Ud.upload(ut,p.uniformsList,E,q)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(Ud.upload(ut,p.uniformsList,E,q),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&S.setValue(ut,"center",i.center),S.setValue(ut,"modelViewMatrix",i.modelViewMatrix),S.setValue(ut,"normalMatrix",i.normalMatrix),S.setValue(ut,"modelMatrix",i.matrixWorld),v}Mt.setAnimationLoop((function(t){xt&&xt(t)})),"undefined"!=typeof window&&Mt.setContext(window),this.setAnimationLoop=function(t){xt=t,ft.setAnimationLoop(t),null===t?Mt.stop():Mt.start()},ft.addEventListener("sessionstart",yt),ft.addEventListener("sessionend",_t),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===g)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===ft.enabled&&!0===ft.isPresenting&&(!0===ft.cameraAutoUpdate&&ft.updateCamera(e),e=ft.getCamera()),!0===t.isScene&&t.onBeforeRender(m,t,e,y),d=nt.get(t,f.length),d.init(),f.push(d),U.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),N.setFromProjectionMatrix(U),F=this.localClippingEnabled,z=it.init(this.clippingPlanes,F,e),u=et.get(t,p.length),u.init(),p.push(u),bt(t,e,0,m.sortObjects),u.finish(),!0===m.sortObjects&&u.sort(C,A),!0===z&&it.beginShadows();const n=d.state.shadowsArray;if(rt.render(n,t,e),!0===z&&it.endShadows(),!0===this.info.autoReset&&this.info.reset(),st.render(u,t),d.setupLights(m.physicallyCorrectLights),e.isArrayCamera){const n=e.cameras;for(let e=0,i=n.length;e<i;e++){const i=n[e];wt(u,t,i,i.viewport)}}else wt(u,t,e);null!==y&&(q.updateMultisampleRenderTarget(y),q.updateRenderTargetMipmap(y)),!0===t.isScene&&t.onAfterRender(m,t,e),W.buffers.depth.setTest(!0),W.buffers.depth.setMask(!0),W.buffers.color.setMask(!0),W.setPolygonOffset(!1),ct.resetDefaultState(),_=-1,M=null,f.pop(),d=f.length>0?f[f.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=function(){return v},this.getActiveMipmapLevel=function(){return x},this.getRenderTarget=function(){return y},this.setRenderTarget=function(t,e=0,n=0){y=t,v=e,x=n,t&&void 0===X.get(t).__webglFramebuffer&&q.setupRenderTarget(t);let i=null,r=!1,s=!1;if(t){const n=t.texture;(n.isDataTexture3D||n.isDataTexture2DArray)&&(s=!0);const a=X.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=a[e],r=!0):i=t.isWebGLMultisampleRenderTarget?X.get(t).__webglMultisampledFramebuffer:a,b.copy(t.viewport),w.copy(t.scissor),S=t.scissorTest}else b.copy(R).multiplyScalar(L).floor(),w.copy(P).multiplyScalar(L).floor(),S=D;if(W.bindFramebuffer(36160,i)&&V.drawBuffers){let e=!1;if(t)if(t.isWebGLMultipleRenderTargets){const n=t.texture;if(I.length!==n.length||36064!==I[0]){for(let t=0,e=n.length;t<e;t++)I[t]=36064+t;I.length=n.length,e=!0}}else 1===I.length&&36064===I[0]||(I[0]=36064,I.length=1,e=!0);else 1===I.length&&1029===I[0]||(I[0]=1029,I.length=1,e=!0);e&&(V.isWebGL2?ut.drawBuffers(I):G.get("WEBGL_draw_buffers").drawBuffersWEBGL(I))}if(W.viewport(b),W.scissor(w),W.setScissorTest(S),r){const i=X.get(t.texture);ut.framebufferTexture2D(36160,36064,34069+e,i.__webglTexture,n)}else if(s){const i=X.get(t.texture),r=e||0;ut.framebufferTextureLayer(36160,36064,i.__webglTexture,n||0,r)}_=-1},this.readRenderTargetPixels=function(t,e,n,i,r,s,a){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=X.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){W.bindFramebuffer(36160,o);try{const a=t.texture,o=a.format,l=a.type;if(o!==Oo&&ht.convert(o)!==ut.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const h=l===No&&(G.has("EXT_color_buffer_half_float")||V.isWebGL2&&G.has("EXT_color_buffer_float"));if(!(l===Ro||ht.convert(l)===ut.getParameter(35738)||l===Io&&(V.isWebGL2||G.has("OES_texture_float")||G.has("WEBGL_color_buffer_float"))||h))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===ut.checkFramebufferStatus(36160)?e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&ut.readPixels(e,n,i,r,ht.convert(o),ht.convert(l),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const t=null!==y?X.get(y).__webglFramebuffer:null;W.bindFramebuffer(36160,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){const i=Math.pow(2,-n),r=Math.floor(e.image.width*i),s=Math.floor(e.image.height*i);let a=ht.convert(e.format);V.isWebGL2&&(6407===a&&(a=32849),6408===a&&(a=32856)),q.setTexture2D(e,0),ut.copyTexImage2D(3553,n,a,t.x,t.y,r,s,0),W.unbindTexture()},this.copyTextureToTexture=function(t,e,n,i=0){const r=e.image.width,s=e.image.height,a=ht.convert(n.format),o=ht.convert(n.type);q.setTexture2D(n,0),ut.pixelStorei(37440,n.flipY),ut.pixelStorei(37441,n.premultiplyAlpha),ut.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?ut.texSubImage2D(3553,i,t.x,t.y,r,s,a,o,e.image.data):e.isCompressedTexture?ut.compressedTexSubImage2D(3553,i,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,a,e.mipmaps[0].data):ut.texSubImage2D(3553,i,t.x,t.y,a,o,e.image),0===i&&n.generateMipmaps&&ut.generateMipmap(3553),W.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,i,r=0){if(m.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=t.max.x-t.min.x+1,a=t.max.y-t.min.y+1,o=t.max.z-t.min.z+1,l=ht.convert(i.format),h=ht.convert(i.type);let c;if(i.isDataTexture3D)q.setTexture3D(i,0),c=32879;else{if(!i.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");q.setTexture2DArray(i,0),c=35866}ut.pixelStorei(37440,i.flipY),ut.pixelStorei(37441,i.premultiplyAlpha),ut.pixelStorei(3317,i.unpackAlignment);const u=ut.getParameter(3314),d=ut.getParameter(32878),p=ut.getParameter(3316),f=ut.getParameter(3315),g=ut.getParameter(32877),v=n.isCompressedTexture?n.mipmaps[0]:n.image;ut.pixelStorei(3314,v.width),ut.pixelStorei(32878,v.height),ut.pixelStorei(3316,t.min.x),ut.pixelStorei(3315,t.min.y),ut.pixelStorei(32877,t.min.z),n.isDataTexture||n.isDataTexture3D?ut.texSubImage3D(c,r,e.x,e.y,e.z,s,a,o,l,h,v.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ut.compressedTexSubImage3D(c,r,e.x,e.y,e.z,s,a,o,l,v.data)):ut.texSubImage3D(c,r,e.x,e.y,e.z,s,a,o,l,h,v),ut.pixelStorei(3314,u),ut.pixelStorei(32878,d),ut.pixelStorei(3316,p),ut.pixelStorei(3315,f),ut.pixelStorei(32877,g),0===r&&i.generateMipmaps&&ut.generateMipmap(c),W.unbindTexture()},this.initTexture=function(t){q.setTexture2D(t,0),W.unbindTexture()},this.resetState=function(){v=0,x=0,y=null,W.reset(),ct.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}(class extends Ap{}).prototype.isWebGL1Renderer=!0;class Rp extends wh{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}Rp.prototype.isScene=!0;class Pp{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=Ko,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=sl()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=sl()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=sl()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Pp.prototype.isInterleavedBuffer=!0;const Dp=new Ml;class Ip{constructor(t,e,n,i=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)Dp.x=this.getX(e),Dp.y=this.getY(e),Dp.z=this.getZ(e),Dp.applyMatrix4(t),this.setXYZ(e,Dp.x,Dp.y,Dp.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Dp.x=this.getX(e),Dp.y=this.getY(e),Dp.z=this.getZ(e),Dp.applyNormalMatrix(t),this.setXYZ(e,Dp.x,Dp.y,Dp.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Dp.x=this.getX(e),Dp.y=this.getY(e),Dp.z=this.getZ(e),Dp.transformDirection(t),this.setXYZ(e,Dp.x,Dp.y,Dp.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new qh(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Ip(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Ip.prototype.isInterleavedBufferAttribute=!0;class Np extends Fh{constructor(t){super(),this.type="SpriteMaterial",this.color=new Vh(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}let zp;Np.prototype.isSpriteMaterial=!0;const Fp=new Ml,Op=new Ml,Up=new Ml,Bp=new cl,kp=new cl,Hp=new Kl,Gp=new Ml,Vp=new Ml,Wp=new Ml,jp=new cl,Xp=new cl,qp=new cl;function Yp(t,e,n,i,r,s){Bp.subVectors(t,n).addScalar(.5).multiply(i),void 0!==r?(kp.x=s*Bp.x-r*Bp.y,kp.y=r*Bp.x+s*Bp.y):kp.copy(Bp),t.copy(e),t.x+=kp.x,t.y+=kp.y,t.applyMatrix4(Hp)}(class extends wh{constructor(t){if(super(),this.type="Sprite",void 0===zp){zp=new sc;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new Pp(t,5);zp.setIndex([0,1,2,0,2,3]),zp.setAttribute("position",new Ip(e,3,0,!1)),zp.setAttribute("uv",new Ip(e,2,3,!1))}this.geometry=zp,this.material=void 0!==t?t:new Np,this.center=new cl(.5,.5)}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Op.setFromMatrixScale(this.matrixWorld),Hp.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Up.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Op.multiplyScalar(-Up.z);const n=this.material.rotation;let i,r;0!==n&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;Yp(Gp.set(-.5,-.5,0),Up,s,Op,i,r),Yp(Vp.set(.5,-.5,0),Up,s,Op,i,r),Yp(Wp.set(.5,.5,0),Up,s,Op,i,r),jp.set(0,0),Xp.set(1,0),qp.set(1,1);let a=t.ray.intersectTriangle(Gp,Vp,Wp,!1,Fp);if(null===a&&(Yp(Vp.set(-.5,.5,0),Up,s,Op,i,r),Xp.set(0,1),a=t.ray.intersectTriangle(Gp,Wp,Vp,!1,Fp),null===a))return;const o=t.ray.origin.distanceTo(Fp);o<t.near||o>t.far||e.push({distance:o,point:Fp.clone(),uv:Nh.getUV(Fp,Gp,Vp,Wp,jp,Xp,qp,new cl),face:null,object:this})}copy(t){return super.copy(t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}).prototype.isSprite=!0;const Zp=new Ml,Jp=new vl,Qp=new vl,Kp=new Ml,$p=new Kl;class tf extends wc{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Kl,this.bindMatrixInverse=new Kl}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new vl,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const i=1/t.manhattanLength();i!==1/0?t.multiplyScalar(i):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,i=this.geometry;Jp.fromBufferAttribute(i.attributes.skinIndex,t),Qp.fromBufferAttribute(i.attributes.skinWeight,t),Zp.fromBufferAttribute(i.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const i=Qp.getComponent(t);if(0!==i){const r=Jp.getComponent(t);$p.multiplyMatrices(n.bones[r].matrixWorld,n.boneInverses[r]),e.addScaledVector(Kp.copy(Zp).applyMatrix4($p),i)}}return e.applyMatrix4(this.bindMatrixInverse)}}tf.prototype.isSkinnedMesh=!0;(class extends wh{constructor(){super(),this.type="Bone"}}).prototype.isBone=!0;(class extends ml{constructor(t=null,e=1,n=1,i,r,s,a,o,l=1003,h=1003,c,u){super(null,s,a,o,l,h,i,r,c,u),this.image={data:t,width:e,height:n},this.magFilter=l,this.minFilter=h,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}).prototype.isDataTexture=!0;class ef extends qh{constructor(t,e,n,i=1){"number"==typeof n&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}ef.prototype.isInstancedBufferAttribute=!0;const nf=new Kl,rf=new Kl,sf=[],af=new wc;(class extends wc{constructor(t,e,n){super(t,e),this.instanceMatrix=new ef(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(af.geometry=this.geometry,af.material=this.material,void 0!==af.material)for(let r=0;r<i;r++){this.getMatrixAt(r,nf),rf.multiplyMatrices(n,nf),af.matrixWorld=rf,af.raycast(t,sf);for(let t=0,n=sf.length;t<n;t++){const n=sf[t];n.instanceId=r,n.object=this,e.push(n)}sf.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new ef(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}).prototype.isInstancedMesh=!0;class of extends Fh{constructor(t){super(),this.type="LineBasicMaterial",this.color=new Vh(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}of.prototype.isLineBasicMaterial=!0;const lf=new Ml,hf=new Ml,cf=new Kl,uf=new Ql,df=new Vl;class pf extends wh{constructor(t=new sc,e=new of){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,i=e.count;t<i;t++)lf.fromBufferAttribute(e,t-1),hf.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=lf.distanceTo(hf);t.setAttribute("lineDistance",new Jh(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),df.copy(n.boundingSphere),df.applyMatrix4(i),df.radius+=r,!1===t.ray.intersectsSphere(df))return;cf.copy(i).invert(),uf.copy(t.ray).applyMatrix4(cf);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new Ml,h=new Ml,c=new Ml,u=new Ml,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const i=n.index,r=n.attributes.position;if(null!==i){for(let n=Math.max(0,s.start),a=Math.min(i.count,s.start+s.count)-1;n<a;n+=d){const s=i.getX(n),a=i.getX(n+1);l.fromBufferAttribute(r,s),h.fromBufferAttribute(r,a);if(uf.distanceSqToSegment(l,h,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const d=t.ray.origin.distanceTo(u);d<t.near||d>t.far||e.push({distance:d,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else{for(let n=Math.max(0,s.start),i=Math.min(r.count,s.start+s.count)-1;n<i;n+=d){l.fromBufferAttribute(r,n),h.fromBufferAttribute(r,n+1);if(uf.distanceSqToSegment(l,h,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const i=t.ray.origin.distanceTo(u);i<t.near||i>t.far||e.push({distance:i,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}pf.prototype.isLine=!0;const ff=new Ml,mf=new Ml;class gf extends pf{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,i=e.count;t<i;t+=2)ff.fromBufferAttribute(e,t),mf.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+ff.distanceTo(mf);t.setAttribute("lineDistance",new Jh(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}gf.prototype.isLineSegments=!0;(class extends pf{constructor(t,e){super(t,e),this.type="LineLoop"}}).prototype.isLineLoop=!0;class vf extends Fh{constructor(t){super(),this.type="PointsMaterial",this.color=new Vh(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}vf.prototype.isPointsMaterial=!0;const xf=new Kl,yf=new Ql,_f=new Vl,Mf=new Ml;function bf(t,e,n,i,r,s,a){const o=yf.distanceSqToPoint(t);if(o<n){const n=new Ml;yf.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:e,face:null,object:a})}}(class extends wh{constructor(t=new sc,e=new vf){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),_f.copy(n.boundingSphere),_f.applyMatrix4(i),_f.radius+=r,!1===t.ray.intersectsSphere(_f))return;xf.copy(i).invert(),yf.copy(t.ray).applyMatrix4(xf);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a;if(n.isBufferGeometry){const r=n.index,a=n.attributes.position;if(null!==r){for(let n=Math.max(0,s.start),l=Math.min(r.count,s.start+s.count);n<l;n++){const s=r.getX(n);Mf.fromBufferAttribute(a,s),bf(Mf,s,o,i,t,e,this)}}else{for(let n=Math.max(0,s.start),r=Math.min(a.count,s.start+s.count);n<r;n++)Mf.fromBufferAttribute(a,n),bf(Mf,n,o,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}).prototype.isPoints=!0;(class extends ml{constructor(t,e,n,i,r,s,a,o,l){super(t,e,n,i,r,s,a,o,l),this.format=void 0!==a?a:Fo,this.minFilter=void 0!==s?s:Co,this.magFilter=void 0!==r?r:Co,this.generateMipmaps=!1;const h=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){h.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1==="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}).prototype.isVideoTexture=!0;(class extends ml{constructor(t,e,n,i,r,s,a,o,l,h,c,u){super(null,s,a,o,l,h,i,r,c,u),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}).prototype.isCompressedTexture=!0;(class extends ml{constructor(t,e,n,i,r,s,a,o,l){super(t,e,n,i,r,s,a,o,l),this.needsUpdate=!0}}).prototype.isCanvasTexture=!0;(class extends ml{constructor(t,e,n,i,r,s,a,o,l,h){if((h=void 0!==h?h:Uo)!==Uo&&h!==Bo)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&h===Uo&&(n=Po),void 0===n&&h===Bo&&(n=zo),super(null,i,r,s,a,o,h,n,l),this.image={width:t,height:e},this.magFilter=void 0!==a?a:Lo,this.minFilter=void 0!==o?o:Lo,this.flipY=!1,this.generateMipmaps=!1}}).prototype.isDepthTexture=!0,new Ml,new Ml,new Ml,new Nh;class wf{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const r=n.length;let s;s=e||t*n[r-1];let a,o=0,l=r-1;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),a=n[i]-s,a<0)o=i+1;else{if(!(a>0)){l=i;break}l=i-1}if(i=l,n[i]===s)return i/(r-1);const h=n[i];return(i+(s-h)/(n[i+1]-h))/(r-1)}getTangent(t,e){const n=1e-4;let i=t-n,r=t+n;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),a=this.getPoint(r),o=e||(s.isVector2?new cl:new Ml);return o.copy(a).sub(s).normalize(),o}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new Ml,i=[],r=[],s=[],a=new Ml,o=new Kl;for(let e=0;e<=t;e++){const n=e/t;i[e]=this.getTangentAt(n,new Ml),i[e].normalize()}r[0]=new Ml,s[0]=new Ml;let l=Number.MAX_VALUE;const h=Math.abs(i[0].x),c=Math.abs(i[0].y),u=Math.abs(i[0].z);h<=l&&(l=h,n.set(1,0,0)),c<=l&&(l=c,n.set(0,1,0)),u<=l&&n.set(0,0,1),a.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],a),s[0].crossVectors(i[0],r[0]);for(let e=1;e<=t;e++){if(r[e]=r[e-1].clone(),s[e]=s[e-1].clone(),a.crossVectors(i[e-1],i[e]),a.length()>Number.EPSILON){a.normalize();const t=Math.acos(al(i[e-1].dot(i[e]),-1,1));r[e].applyMatrix4(o.makeRotationAxis(a,t))}s[e].crossVectors(i[e],r[e])}if(!0===e){let e=Math.acos(al(r[0].dot(r[t]),-1,1));e/=t,i[0].dot(a.crossVectors(r[0],r[t]))>0&&(e=-e);for(let n=1;n<=t;n++)r[n].applyMatrix4(o.makeRotationAxis(i[n],e*n)),s[n].crossVectors(i[n],r[n])}return{tangents:i,normals:r,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Sf extends wf{constructor(t=0,e=0,n=1,i=1,r=0,s=2*Math.PI,a=!1,o=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=s,this.aClockwise=a,this.aRotation=o}getPoint(t,e){const n=e||new cl,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=s?0:i),!0!==this.aClockwise||s||(r===i?r=-i:r-=i);const a=this.aStartAngle+t*r;let o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=o-this.aX,i=l-this.aY;o=n*t-i*e+this.aX,l=n*e+i*t+this.aY}return n.set(o,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}Sf.prototype.isEllipseCurve=!0;class Ef extends Sf{constructor(t,e,n,i,r,s){super(t,e,n,n,i,r,s),this.type="ArcCurve"}}function Tf(){let t=0,e=0,n=0,i=0;function r(r,s,a,o){t=r,e=a,n=-3*r+3*s-2*a-o,i=2*r-2*s+a+o}return{initCatmullRom:function(t,e,n,i,s){r(e,n,s*(n-t),s*(i-e))},initNonuniformCatmullRom:function(t,e,n,i,s,a,o){let l=(e-t)/s-(n-t)/(s+a)+(n-e)/a,h=(n-e)/a-(i-e)/(a+o)+(i-n)/o;l*=a,h*=a,r(e,n,l,h)},calc:function(r){const s=r*r;return t+e*r+n*s+i*(s*r)}}}Ef.prototype.isArcCurve=!0;const Lf=new Ml,Cf=new Tf,Af=new Tf,Rf=new Tf;class Pf extends wf{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new Ml){const n=e,i=this.points,r=i.length,s=(r-(this.closed?0:1))*t;let a,o,l=Math.floor(s),h=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/r)+1)*r:0===h&&l===r-1&&(l=r-2,h=1),this.closed||l>0?a=i[(l-1)%r]:(Lf.subVectors(i[0],i[1]).add(i[0]),a=Lf);const c=i[l%r],u=i[(l+1)%r];if(this.closed||l+2<r?o=i[(l+2)%r]:(Lf.subVectors(i[r-1],i[r-2]).add(i[r-1]),o=Lf),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(a.distanceToSquared(c),t),n=Math.pow(c.distanceToSquared(u),t),i=Math.pow(u.distanceToSquared(o),t);n<1e-4&&(n=1),e<1e-4&&(e=n),i<1e-4&&(i=n),Cf.initNonuniformCatmullRom(a.x,c.x,u.x,o.x,e,n,i),Af.initNonuniformCatmullRom(a.y,c.y,u.y,o.y,e,n,i),Rf.initNonuniformCatmullRom(a.z,c.z,u.z,o.z,e,n,i)}else"catmullrom"===this.curveType&&(Cf.initCatmullRom(a.x,c.x,u.x,o.x,this.tension),Af.initCatmullRom(a.y,c.y,u.y,o.y,this.tension),Rf.initCatmullRom(a.z,c.z,u.z,o.z,this.tension));return n.set(Cf.calc(h),Af.calc(h),Rf.calc(h)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new Ml).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function Df(t,e,n,i,r){const s=.5*(i-e),a=.5*(r-n),o=t*t;return(2*n-2*i+s+a)*(t*o)+(-3*n+3*i-2*s-a)*o+s*t+n}function If(t,e,n,i){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,i)}function Nf(t,e,n,i,r){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,i)+function(t,e){return t*t*t*e}(t,r)}Pf.prototype.isCatmullRomCurve3=!0;class zf extends wf{constructor(t=new cl,e=new cl,n=new cl,i=new cl){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new cl){const n=e,i=this.v0,r=this.v1,s=this.v2,a=this.v3;return n.set(Nf(t,i.x,r.x,s.x,a.x),Nf(t,i.y,r.y,s.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}zf.prototype.isCubicBezierCurve=!0;class Ff extends wf{constructor(t=new Ml,e=new Ml,n=new Ml,i=new Ml){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new Ml){const n=e,i=this.v0,r=this.v1,s=this.v2,a=this.v3;return n.set(Nf(t,i.x,r.x,s.x,a.x),Nf(t,i.y,r.y,s.y,a.y),Nf(t,i.z,r.z,s.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Ff.prototype.isCubicBezierCurve3=!0;class Of extends wf{constructor(t=new cl,e=new cl){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new cl){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new cl;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Of.prototype.isLineCurve=!0;class Uf extends wf{constructor(t=new cl,e=new cl,n=new cl){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new cl){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(If(t,i.x,r.x,s.x),If(t,i.y,r.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Uf.prototype.isQuadraticBezierCurve=!0;class Bf extends wf{constructor(t=new Ml,e=new Ml,n=new Ml){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new Ml){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(If(t,i.x,r.x,s.x),If(t,i.y,r.y,s.y),If(t,i.z,r.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Bf.prototype.isQuadraticBezierCurve3=!0;class kf extends wf{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new cl){const n=e,i=this.points,r=(i.length-1)*t,s=Math.floor(r),a=r-s,o=i[0===s?s:s-1],l=i[s],h=i[s>i.length-2?i.length-1:s+1],c=i[s>i.length-3?i.length-1:s+2];return n.set(Df(a,o.x,l.x,h.x,c.x),Df(a,o.y,l.y,h.y,c.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new cl).fromArray(n))}return this}}kf.prototype.isSplineCurve=!0;var Hf=Object.freeze({__proto__:null,ArcCurve:Ef,CatmullRomCurve3:Pf,CubicBezierCurve:zf,CubicBezierCurve3:Ff,EllipseCurve:Sf,LineCurve:Of,LineCurve3:class extends wf{constructor(t=new Ml,e=new Ml){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new Ml){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}},QuadraticBezierCurve:Uf,QuadraticBezierCurve3:Bf,SplineCurve:kf});const Gf=function(t,e,n=2){const i=e&&e.length,r=i?e[0]*n:t.length;let s=Vf(t,0,r,n,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,h,c,u,d,p;if(i&&(s=function(t,e,n,i){const r=[];let s,a,o,l,h;for(s=0,a=e.length;s<a;s++)o=e[s]*i,l=s<a-1?e[s+1]*i:t.length,h=Vf(t,o,l,i,!1),h===h.next&&(h.steiner=!0),r.push(tm(h));for(r.sort(Jf),s=0;s<r.length;s++)Qf(r[s],n),n=Wf(n,n.next);return n}(t,e,s,n)),t.length>80*n){o=h=t[0],l=c=t[1];for(let e=n;e<r;e+=n)u=t[e],d=t[e+1],u<o&&(o=u),d<l&&(l=d),u>h&&(h=u),d>c&&(c=d);p=Math.max(h-o,c-l),p=0!==p?1/p:0}return jf(s,a,n,o,l,p),a};function Vf(t,e,n,i,r){let s,a;if(r===function(t,e,n,i){let r=0;for(let s=e,a=n-i;s<n;s+=i)r+=(t[a]-t[s])*(t[s+1]+t[a+1]),a=s;return r}(t,e,n,i)>0)for(s=e;s<n;s+=i)a=cm(s,t[s],t[s+1],a);else for(s=n-i;s>=e;s-=i)a=cm(s,t[s],t[s+1],a);return a&&rm(a,a.next)&&(um(a),a=a.next),a}function Wf(t,e){if(!t)return t;e||(e=t);let n,i=t;do{if(n=!1,i.steiner||!rm(i,i.next)&&0!==im(i.prev,i,i.next))i=i.next;else{if(um(i),i=e=i.prev,i===i.next)break;n=!0}}while(n||i!==e);return e}function jf(t,e,n,i,r,s,a){if(!t)return;!a&&s&&function(t,e,n,i){let r=t;do{null===r.z&&(r.z=$f(r.x,r.y,e,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,n,i,r,s,a,o,l,h=1;do{for(n=t,t=null,s=null,a=0;n;){for(a++,i=n,o=0,e=0;e<h&&(o++,i=i.nextZ,i);e++);for(l=h;o>0||l>0&&i;)0!==o&&(0===l||!i||n.z<=i.z)?(r=n,n=n.nextZ,o--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:t=r,r.prevZ=s,s=r;n=i}s.nextZ=null,h*=2}while(a>1)}(r)}(t,i,r,s);let o,l,h=t;for(;t.prev!==t.next;)if(o=t.prev,l=t.next,s?qf(t,i,r,s):Xf(t))e.push(o.i/n),e.push(t.i/n),e.push(l.i/n),um(t),t=l.next,h=l.next;else if((t=l)===h){a?1===a?jf(t=Yf(Wf(t),e,n),e,n,i,r,s,2):2===a&&Zf(t,e,n,i,r,s):jf(Wf(t),e,n,i,r,s,1);break}}function Xf(t){const e=t.prev,n=t,i=t.next;if(im(e,n,i)>=0)return!1;let r=t.next.next;for(;r!==t.prev;){if(em(e.x,e.y,n.x,n.y,i.x,i.y,r.x,r.y)&&im(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function qf(t,e,n,i){const r=t.prev,s=t,a=t.next;if(im(r,s,a)>=0)return!1;const o=r.x<s.x?r.x<a.x?r.x:a.x:s.x<a.x?s.x:a.x,l=r.y<s.y?r.y<a.y?r.y:a.y:s.y<a.y?s.y:a.y,h=r.x>s.x?r.x>a.x?r.x:a.x:s.x>a.x?s.x:a.x,c=r.y>s.y?r.y>a.y?r.y:a.y:s.y>a.y?s.y:a.y,u=$f(o,l,e,n,i),d=$f(h,c,e,n,i);let p=t.prevZ,f=t.nextZ;for(;p&&p.z>=u&&f&&f.z<=d;){if(p!==t.prev&&p!==t.next&&em(r.x,r.y,s.x,s.y,a.x,a.y,p.x,p.y)&&im(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,f!==t.prev&&f!==t.next&&em(r.x,r.y,s.x,s.y,a.x,a.y,f.x,f.y)&&im(f.prev,f,f.next)>=0)return!1;f=f.nextZ}for(;p&&p.z>=u;){if(p!==t.prev&&p!==t.next&&em(r.x,r.y,s.x,s.y,a.x,a.y,p.x,p.y)&&im(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==t.prev&&f!==t.next&&em(r.x,r.y,s.x,s.y,a.x,a.y,f.x,f.y)&&im(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function Yf(t,e,n){let i=t;do{const r=i.prev,s=i.next.next;!rm(r,s)&&sm(r,i,i.next,s)&&lm(r,s)&&lm(s,r)&&(e.push(r.i/n),e.push(i.i/n),e.push(s.i/n),um(i),um(i.next),i=t=s),i=i.next}while(i!==t);return Wf(i)}function Zf(t,e,n,i,r,s){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.i!==t.i&&nm(a,t)){let o=hm(a,t);return a=Wf(a,a.next),o=Wf(o,o.next),jf(a,e,n,i,r,s),void jf(o,e,n,i,r,s)}t=t.next}a=a.next}while(a!==t)}function Jf(t,e){return t.x-e.x}function Qf(t,e){if(e=function(t,e){let n=e;const i=t.x,r=t.y;let s,a=-1/0;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){const t=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=i&&t>a){if(a=t,t===i){if(r===n.y)return n;if(r===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!s)return null;if(i===a)return s;const o=s,l=s.x,h=s.y;let c,u=1/0;n=s;do{i>=n.x&&n.x>=l&&i!==n.x&&em(r<h?i:a,r,l,h,r<h?a:i,r,n.x,n.y)&&(c=Math.abs(r-n.y)/(i-n.x),lm(n,t)&&(c<u||c===u&&(n.x>s.x||n.x===s.x&&Kf(s,n)))&&(s=n,u=c)),n=n.next}while(n!==o);return s}(t,e),e){const n=hm(e,t);Wf(e,e.next),Wf(n,n.next)}}function Kf(t,e){return im(t.prev,t,e.prev)<0&&im(e.next,t,t.next)<0}function $f(t,e,n,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function tm(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function em(t,e,n,i,r,s,a,o){return(r-a)*(e-o)-(t-a)*(s-o)>=0&&(t-a)*(i-o)-(n-a)*(e-o)>=0&&(n-a)*(s-o)-(r-a)*(i-o)>=0}function nm(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&sm(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(lm(t,e)&&lm(e,t)&&function(t,e){let n=t,i=!1;const r=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&r<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(im(t.prev,t,e.prev)||im(t,e.prev,e))||rm(t,e)&&im(t.prev,t,t.next)>0&&im(e.prev,e,e.next)>0)}function im(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function rm(t,e){return t.x===e.x&&t.y===e.y}function sm(t,e,n,i){const r=om(im(t,e,n)),s=om(im(t,e,i)),a=om(im(n,i,t)),o=om(im(n,i,e));return r!==s&&a!==o||(!(0!==r||!am(t,n,e))||(!(0!==s||!am(t,i,e))||(!(0!==a||!am(n,t,i))||!(0!==o||!am(n,e,i)))))}function am(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function om(t){return t>0?1:t<0?-1:0}function lm(t,e){return im(t.prev,t,t.next)<0?im(t,e,t.next)>=0&&im(t,t.prev,e)>=0:im(t,e,t.prev)<0||im(t,t.next,e)<0}function hm(t,e){const n=new dm(t.i,t.x,t.y),i=new dm(e.i,e.x,e.y),r=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=r,r.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function cm(t,e,n,i){const r=new dm(t,e,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function um(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function dm(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class pm{static area(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return.5*n}static isClockWise(t){return pm.area(t)<0}static triangulateShape(t,e){const n=[],i=[],r=[];fm(t),mm(n,t);let s=t.length;e.forEach(fm);for(let t=0;t<e.length;t++)i.push(s),s+=e[t].length,mm(n,e[t]);const a=Gf(n,i);for(let t=0;t<a.length;t+=3)r.push(a.slice(t,t+3));return r}}function fm(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function mm(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class gm extends sc{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let e=0,n=t.length;e<n;e++){s(t[e])}function s(t){const s=[],a=void 0!==e.curveSegments?e.curveSegments:12,o=void 0!==e.steps?e.steps:1;let l=void 0!==e.depth?e.depth:100,h=void 0===e.bevelEnabled||e.bevelEnabled,c=void 0!==e.bevelThickness?e.bevelThickness:6,u=void 0!==e.bevelSize?e.bevelSize:c-2,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:vm;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=e.amount);let g,v,x,y,_,M=!1;f&&(g=f.getSpacedPoints(o),M=!0,h=!1,v=f.computeFrenetFrames(o,!1),x=new Ml,y=new Ml,_=new Ml),h||(p=0,c=0,u=0,d=0);const b=t.extractPoints(a);let w=b.shape;const S=b.holes;if(!pm.isClockWise(w)){w=w.reverse();for(let t=0,e=S.length;t<e;t++){const e=S[t];pm.isClockWise(e)&&(S[t]=e.reverse())}}const E=pm.triangulateShape(w,S),T=w;for(let t=0,e=S.length;t<e;t++){const e=S[t];w=w.concat(e)}function L(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const C=w.length,A=E.length;function R(t,e,n){let i,r,s;const a=t.x-e.x,o=t.y-e.y,l=n.x-t.x,h=n.y-t.y,c=a*a+o*o,u=a*h-o*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(c),d=Math.sqrt(l*l+h*h),p=e.x-o/u,f=e.y+a/u,m=((n.x-h/d-p)*h-(n.y+l/d-f)*l)/(a*h-o*l);i=p+a*m-t.x,r=f+o*m-t.y;const g=i*i+r*r;if(g<=2)return new cl(i,r);s=Math.sqrt(g/2)}else{let t=!1;a>Number.EPSILON?l>Number.EPSILON&&(t=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(h)&&(t=!0),t?(i=-o,r=a,s=Math.sqrt(c)):(i=a,r=o,s=Math.sqrt(c/2))}return new cl(i/s,r/s)}const P=[];for(let t=0,e=T.length,n=e-1,i=t+1;t<e;t++,n++,i++)n===e&&(n=0),i===e&&(i=0),P[t]=R(T[t],T[n],T[i]);const D=[];let I,N=P.concat();for(let t=0,e=S.length;t<e;t++){const e=S[t];I=[];for(let t=0,n=e.length,i=n-1,r=t+1;t<n;t++,i++,r++)i===n&&(i=0),r===n&&(r=0),I[t]=R(e[t],e[i],e[r]);D.push(I),N=N.concat(I)}for(let t=0;t<p;t++){const e=t/p,n=c*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=T.length;t<e;t++){const e=L(T[t],P[t],i);O(e.x,e.y,-n)}for(let t=0,e=S.length;t<e;t++){const e=S[t];I=D[t];for(let t=0,r=e.length;t<r;t++){const r=L(e[t],I[t],i);O(r.x,r.y,-n)}}}const z=u+d;for(let t=0;t<C;t++){const e=h?L(w[t],N[t],z):w[t];M?(y.copy(v.normals[0]).multiplyScalar(e.x),x.copy(v.binormals[0]).multiplyScalar(e.y),_.copy(g[0]).add(y).add(x),O(_.x,_.y,_.z)):O(e.x,e.y,0)}for(let t=1;t<=o;t++)for(let e=0;e<C;e++){const n=h?L(w[e],N[e],z):w[e];M?(y.copy(v.normals[t]).multiplyScalar(n.x),x.copy(v.binormals[t]).multiplyScalar(n.y),_.copy(g[t]).add(y).add(x),O(_.x,_.y,_.z)):O(n.x,n.y,l/o*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=c*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=T.length;t<e;t++){const e=L(T[t],P[t],i);O(e.x,e.y,l+n)}for(let t=0,e=S.length;t<e;t++){const e=S[t];I=D[t];for(let t=0,r=e.length;t<r;t++){const r=L(e[t],I[t],i);M?O(r.x,r.y+g[o-1].y,g[o-1].x+n):O(r.x,r.y,l+n)}}}function F(t,e){let n=t.length;for(;--n>=0;){const i=n;let r=n-1;r<0&&(r=t.length-1);for(let t=0,n=o+2*p;t<n;t++){const n=C*t,s=C*(t+1);B(e+i+n,e+r+n,e+r+s,e+i+s)}}}function O(t,e,n){s.push(t),s.push(e),s.push(n)}function U(t,e,r){k(t),k(e),k(r);const s=i.length/3,a=m.generateTopUV(n,i,s-3,s-2,s-1);H(a[0]),H(a[1]),H(a[2])}function B(t,e,r,s){k(t),k(e),k(s),k(e),k(r),k(s);const a=i.length/3,o=m.generateSideWallUV(n,i,a-6,a-3,a-2,a-1);H(o[0]),H(o[1]),H(o[3]),H(o[1]),H(o[2]),H(o[3])}function k(t){i.push(s[3*t+0]),i.push(s[3*t+1]),i.push(s[3*t+2])}function H(t){r.push(t.x),r.push(t.y)}!function(){const t=i.length/3;if(h){let t=0,e=C*t;for(let t=0;t<A;t++){const n=E[t];U(n[2]+e,n[1]+e,n[0]+e)}t=o+2*p,e=C*t;for(let t=0;t<A;t++){const n=E[t];U(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<A;t++){const e=E[t];U(e[2],e[1],e[0])}for(let t=0;t<A;t++){const e=E[t];U(e[0]+C*o,e[1]+C*o,e[2]+C*o)}}n.addGroup(t,i.length/3-t,0)}(),function(){const t=i.length/3;let e=0;F(T,e),e+=T.length;for(let t=0,n=S.length;t<n;t++){const n=S[t];F(n,e),e+=n.length}n.addGroup(t,i.length/3-t,1)}()}this.setAttribute("position",new Jh(i,3)),this.setAttribute("uv",new Jh(r,2)),this.computeVertexNormals()}toJSON(){const t=super.toJSON();return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,i=t.length;e<i;e++){const i=t[e];n.shapes.push(i.uuid)}else n.shapes.push(t.uuid);void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON());return n}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}const i=t.options.extrudePath;return void 0!==i&&(t.options.extrudePath=(new Hf[i.type]).fromJSON(i)),new gm(n,t.options)}}const vm={generateTopUV:function(t,e,n,i,r){const s=e[3*n],a=e[3*n+1],o=e[3*i],l=e[3*i+1],h=e[3*r],c=e[3*r+1];return[new cl(s,a),new cl(o,l),new cl(h,c)]},generateSideWallUV:function(t,e,n,i,r,s){const a=e[3*n],o=e[3*n+1],l=e[3*n+2],h=e[3*i],c=e[3*i+1],u=e[3*i+2],d=e[3*r],p=e[3*r+1],f=e[3*r+2],m=e[3*s],g=e[3*s+1],v=e[3*s+2];return Math.abs(o-c)<Math.abs(a-h)?[new cl(a,1-l),new cl(h,1-u),new cl(d,1-f),new cl(m,1-v)]:[new cl(o,1-l),new cl(c,1-u),new cl(p,1-f),new cl(g,1-v)]}};class xm extends sc{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],s=[];let a=0,o=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(a,o,e),a+=o,o=0;function l(t){const a=i.length/3,l=t.extractPoints(e);let h=l.shape;const c=l.holes;!1===pm.isClockWise(h)&&(h=h.reverse());for(let t=0,e=c.length;t<e;t++){const e=c[t];!0===pm.isClockWise(e)&&(c[t]=e.reverse())}const u=pm.triangulateShape(h,c);for(let t=0,e=c.length;t<e;t++){const e=c[t];h=h.concat(e)}for(let t=0,e=h.length;t<e;t++){const e=h[t];i.push(e.x,e.y,0),r.push(0,0,1),s.push(e.x,e.y)}for(let t=0,e=u.length;t<e;t++){const e=u[t],i=e[0]+a,r=e[1]+a,s=e[2]+a;n.push(i,r,s),o+=3}}this.setIndex(n),this.setAttribute("position",new Jh(i,3)),this.setAttribute("normal",new Jh(r,3)),this.setAttribute("uv",new Jh(s,2))}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,i=t.length;n<i;n++){const i=t[n];e.shapes.push(i.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}return new xm(n,t.curveSegments)}}(class extends Fh{constructor(t){super(),this.type="ShadowMaterial",this.color=new Vh(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}).prototype.isShadowMaterial=!0;class ym extends Fh{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Vh(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Vh(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new cl(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}ym.prototype.isMeshStandardMaterial=!0;(class extends ym{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new cl(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return al(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenTint=new Vh(0),this.transmission=0,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationTint=new Vh(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularTint=new Vh(1,1,1),this.specularTintMap=null,this._clearcoat=0,this._transmission=0,this.setValues(t)}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheenTint.copy(t.sheenTint),this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationTint.copy(t.attenuationTint),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularTint.copy(t.specularTint),this.specularTintMap=t.specularTintMap,this}}).prototype.isMeshPhysicalMaterial=!0;(class extends Fh{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new Vh(16777215),this.specular=new Vh(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Vh(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new cl(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}).prototype.isMeshPhongMaterial=!0;(class extends Fh{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Vh(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Vh(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new cl(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}).prototype.isMeshToonMaterial=!0;(class extends Fh{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new cl(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}).prototype.isMeshNormalMaterial=!0;(class extends Fh{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new Vh(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Vh(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}).prototype.isMeshLambertMaterial=!0;(class extends Fh{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Vh(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new cl(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}).prototype.isMeshMatcapMaterial=!0;(class extends of{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}).prototype.isLineDashedMaterial=!0;const _m={arraySlice:function(t,e,n){return _m.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)},convertArray:function(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort((function(e,n){return t[e]-t[n]})),n},sortedArray:function(t,e,n){const i=t.length,r=new t.constructor(i);for(let s=0,a=0;a!==i;++s){const i=n[s]*e;for(let n=0;n!==e;++n)r[a++]=t[i+n]}return r},flattenJSON:function(t,e,n,i){let r=1,s=t[0];for(;void 0!==s&&void 0===s[i];)s=t[r++];if(void 0===s)return;let a=s[i];if(void 0!==a)if(Array.isArray(a))do{a=s[i],void 0!==a&&(e.push(s.time),n.push.apply(n,a)),s=t[r++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[i],void 0!==a&&(e.push(s.time),a.toArray(n,n.length)),s=t[r++]}while(void 0!==s);else do{a=s[i],void 0!==a&&(e.push(s.time),n.push(a)),s=t[r++]}while(void 0!==s)},subclip:function(t,e,n,i,r=30){const s=t.clone();s.name=e;const a=[];for(let t=0;t<s.tracks.length;++t){const e=s.tracks[t],o=e.getValueSize(),l=[],h=[];for(let t=0;t<e.times.length;++t){const s=e.times[t]*r;if(!(s<n||s>=i)){l.push(e.times[t]);for(let n=0;n<o;++n)h.push(e.values[t*o+n])}}0!==l.length&&(e.times=_m.convertArray(l,e.times.constructor),e.values=_m.convertArray(h,e.values.constructor),a.push(e))}s.tracks=a;let o=1/0;for(let t=0;t<s.tracks.length;++t)o>s.tracks[t].times[0]&&(o=s.tracks[t].times[0]);for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,i=30){i<=0&&(i=30);const r=n.tracks.length,s=e/i;for(let e=0;e<r;++e){const i=n.tracks[e],r=i.ValueTypeName;if("bool"===r||"string"===r)continue;const a=t.tracks.find((function(t){return t.name===i.name&&t.ValueTypeName===r}));if(void 0===a)continue;let o=0;const l=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let h=0;const c=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=c/3);const u=i.times.length-1;let d;if(s<=i.times[0]){const t=o,e=l-o;d=_m.arraySlice(i.values,t,e)}else if(s>=i.times[u]){const t=u*l+o,e=t+l-o;d=_m.arraySlice(i.values,t,e)}else{const t=i.createInterpolant(),e=o,n=l-o;t.evaluate(s),d=_m.arraySlice(t.resultBuffer,e,n)}if("quaternion"===r){(new _l).fromArray(d).normalize().conjugate().toArray(d)}const p=a.times.length;for(let t=0;t<p;++t){const e=t*c+h;if("quaternion"===r)_l.multiplyQuaternionsFlat(a.values,e,d,0,a.values,e);else{const t=c-2*h;for(let n=0;n<t;++n)a.values[e+n]-=d[n]}}}return t.blendMode=2501,t}};class Mm{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let s;n:{i:if(!(t<i)){for(let s=n+2;;){if(void 0===i){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,r)}if(n===s)break;if(r=i,i=e[++n],t<i)break e}s=e.length;break n}if(t>=r)break t;{const a=e[1];t<a&&(n=2,r=a);for(let s=n-2;;){if(void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===s)break;if(i=r,r=e[--n-1],t>=r)break e}s=n,n=0}}for(;n<s;){const i=n+s>>>1;t<e[i]?s=i:n=i+1}if(i=e[n],r=e[n-1],void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(void 0===i)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,r,t)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let t=0;t!==i;++t)e[t]=n[r+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Mm.prototype.beforeStart_=Mm.prototype.copySampleValue_,Mm.prototype.afterEnd_=Mm.prototype.copySampleValue_;class bm extends Mm{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Vo,endingEnd:Vo}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,s=t+1,a=i[r],o=i[s];if(void 0===a)switch(this.getSettings_().endingStart){case Wo:r=t,a=2*e-n;break;case jo:r=i.length-2,a=e+i[r]-i[r+1];break;default:r=t,a=n}if(void 0===o)switch(this.getSettings_().endingEnd){case Wo:s=t,o=2*n-e;break;case jo:s=1,o=n+i[1]-i[0];break;default:s=t-1,o=e}const l=.5*(n-e),h=this.valueSize;this._weightPrev=l/(e-a),this._weightNext=l/(o-n),this._offsetPrev=r*h,this._offsetNext=s*h}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,h=this._offsetPrev,c=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(n-e)/(i-e),f=p*p,m=f*p,g=-u*m+2*u*f-u*p,v=(1+u)*m+(-1.5-2*u)*f+(-.5+u)*p+1,x=(-1-d)*m+(1.5+d)*f+.5*p,y=d*m-d*f;for(let t=0;t!==a;++t)r[t]=g*s[h+t]+v*s[l+t]+x*s[o+t]+y*s[c+t];return r}}class wm extends Mm{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,h=(n-e)/(i-e),c=1-h;for(let t=0;t!==a;++t)r[t]=s[l+t]*c+s[o+t]*h;return r}}class Sm extends Mm{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class Em{constructor(t,e,n,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=_m.convertArray(e,this.TimeBufferType),this.values=_m.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:_m.convertArray(t.times,Array),values:_m.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new Sm(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new wm(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new bm(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case ko:e=this.InterpolantFactoryMethodDiscrete;break;case Ho:e=this.InterpolantFactoryMethodLinear;break;case Go:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ko;case this.InterpolantFactoryMethodLinear:return Ho;case this.InterpolantFactoryMethodSmooth:return Go}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<t;)++r;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==r||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const t=this.getValueSize();this.times=_m.arraySlice(n,r,s),this.values=_m.arraySlice(this.values,r*t,s*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==r;e++){const i=n[e];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,i),t=!1;break}if(null!==s&&s>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,i,s),t=!1;break}s=i}if(void 0!==i&&_m.isTypedArray(i))for(let e=0,n=i.length;e!==n;++e){const n=i[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=_m.arraySlice(this.times),e=_m.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===Go,r=t.length-1;let s=1;for(let a=1;a<r;++a){let r=!1;const o=t[a];if(o!==t[a+1]&&(1!==a||o!==t[0]))if(i)r=!0;else{const t=a*n,i=t-n,s=t+n;for(let a=0;a!==n;++a){const n=e[t+a];if(n!==e[i+a]||n!==e[s+a]){r=!0;break}}}if(r){if(a!==s){t[s]=t[a];const i=a*n,r=s*n;for(let t=0;t!==n;++t)e[r+t]=e[i+t]}++s}}if(r>0){t[s]=t[r];for(let t=r*n,i=s*n,a=0;a!==n;++a)e[i+a]=e[t+a];++s}return s!==t.length?(this.times=_m.arraySlice(t,0,s),this.values=_m.arraySlice(e,0,s*n)):(this.times=t,this.values=e),this}clone(){const t=_m.arraySlice(this.times,0),e=_m.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}Em.prototype.TimeBufferType=Float32Array,Em.prototype.ValueBufferType=Float32Array,Em.prototype.DefaultInterpolation=Ho;class Tm extends Em{}Tm.prototype.ValueTypeName="bool",Tm.prototype.ValueBufferType=Array,Tm.prototype.DefaultInterpolation=ko,Tm.prototype.InterpolantFactoryMethodLinear=void 0,Tm.prototype.InterpolantFactoryMethodSmooth=void 0;class Lm extends Em{}Lm.prototype.ValueTypeName="color";class Cm extends Em{}Cm.prototype.ValueTypeName="number";class Am extends Mm{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(n-e)/(i-e);let l=t*a;for(let t=l+a;l!==t;l+=4)_l.slerpFlat(r,0,s,l-a,s,l,o);return r}}class Rm extends Em{InterpolantFactoryMethodLinear(t){return new Am(this.times,this.values,this.getValueSize(),t)}}Rm.prototype.ValueTypeName="quaternion",Rm.prototype.DefaultInterpolation=Ho,Rm.prototype.InterpolantFactoryMethodSmooth=void 0;class Pm extends Em{}Pm.prototype.ValueTypeName="string",Pm.prototype.ValueBufferType=Array,Pm.prototype.DefaultInterpolation=ko,Pm.prototype.InterpolantFactoryMethodLinear=void 0,Pm.prototype.InterpolantFactoryMethodSmooth=void 0;class Dm extends Em{}Dm.prototype.ValueTypeName="vector";class Im{constructor(t,e=-1,n,i=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=sl(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let t=0,r=n.length;t!==r;++t)e.push(Nm(n[t]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,i=n.length;t!==i;++t)e.push(Em.toJSON(n[t]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,s=[];for(let t=0;t<r;t++){let a=[],o=[];a.push((t+r-1)%r,t,(t+1)%r),o.push(0,1,0);const l=_m.getKeyframeOrder(a);a=_m.sortedArray(a,1,l),o=_m.sortedArray(o,1,l),i||0!==a[0]||(a.push(r),o.push(o[0])),s.push(new Cm(".morphTargetInfluences["+e[t].name+"]",a,o).scale(1/n))}return new this(t,-1,s)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],s=n.name.match(r);if(s&&s.length>1){const t=s[1];let e=i[t];e||(i[t]=e=[]),e.push(n)}}const s=[];for(const t in i)s.push(this.CreateFromMorphTargetSequence(t,i[t],e,n));return s}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,i,r){if(0!==n.length){const s=[],a=[];_m.flattenJSON(n,s,a,i),0!==s.length&&r.push(new t(e,s,a))}},i=[],r=t.name||"default",s=t.fps||30,a=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const r=l[t].keys;if(r&&0!==r.length)if(r[0].morphTargets){const t={};let e;for(e=0;e<r.length;e++)if(r[e].morphTargets)for(let n=0;n<r[e].morphTargets.length;n++)t[r[e].morphTargets[n]]=-1;for(const n in t){const t=[],s=[];for(let i=0;i!==r[e].morphTargets.length;++i){const i=r[e];t.push(i.time),s.push(i.morphTarget===n?1:0)}i.push(new Cm(".morphTargetInfluence["+n+"]",t,s))}o=t.length*(s||1)}else{const s=".bones["+e[t].name+"]";n(Dm,s+".position",r,"pos",i),n(Rm,s+".quaternion",r,"rot",i),n(Dm,s+".scale",r,"scl",i)}}if(0===i.length)return null;return new this(r,o,i,a)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Nm(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Cm;case"vector":case"vector2":case"vector3":case"vector4":return Dm;case"color":return Lm;case"quaternion":return Rm;case"bool":case"boolean":return Tm;case"string":return Pm}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];_m.flattenJSON(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const zm={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};const Fm=new class{constructor(t,e,n){const i=this;let r,s=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){o++,!1===s&&void 0!==i.onStart&&i.onStart(t,a,o),s=!0},this.itemEnd=function(t){a++,void 0!==i.onProgress&&i.onProgress(t,a,o),a===o&&(s=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}}};class Om{constructor(t){this.manager=void 0!==t?t:Fm,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(i,r){n.load(t,i,e,r)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Um={};class Bm extends Om{constructor(t){super(t)}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=zm.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;if(void 0!==Um[t])return void Um[t].push({onLoad:e,onProgress:n,onError:i});const a=t.match(/^data:(.*?)(;base64)?,(.*)$/);let o;if(a){const n=a[1],s=!!a[2];let o=a[3];o=decodeURIComponent(o),s&&(o=atob(o));try{let i;const s=(this.responseType||"").toLowerCase();switch(s){case"arraybuffer":case"blob":const t=new Uint8Array(o.length);for(let e=0;e<o.length;e++)t[e]=o.charCodeAt(e);i="blob"===s?new Blob([t.buffer],{type:n}):t.buffer;break;case"document":const e=new DOMParser;i=e.parseFromString(o,n);break;case"json":i=JSON.parse(o);break;default:i=o}setTimeout((function(){e&&e(i),r.manager.itemEnd(t)}),0)}catch(e){setTimeout((function(){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}),0)}}else{Um[t]=[],Um[t].push({onLoad:e,onProgress:n,onError:i}),o=new XMLHttpRequest,o.open("GET",t,!0),o.addEventListener("load",(function(e){const n=this.response,i=Um[t];if(delete Um[t],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),zm.add(t,n);for(let t=0,e=i.length;t<e;t++){const e=i[t];e.onLoad&&e.onLoad(n)}r.manager.itemEnd(t)}else{for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onError&&n.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}}),!1),o.addEventListener("progress",(function(e){const n=Um[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onProgress&&i.onProgress(e)}}),!1),o.addEventListener("error",(function(e){const n=Um[t];delete Um[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}),!1),o.addEventListener("abort",(function(e){const n=Um[t];delete Um[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}),!1),void 0!==this.responseType&&(o.responseType=this.responseType),void 0!==this.withCredentials&&(o.withCredentials=this.withCredentials),o.overrideMimeType&&o.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const t in this.requestHeader)o.setRequestHeader(t,this.requestHeader[t]);o.send(null)}return r.manager.itemStart(t),o}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class km extends Om{constructor(t){super(t)}load(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=zm.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;const a=document.createElementNS("http://www.w3.org/1999/xhtml","img");function o(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1),zm.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(e){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(t),a.src=t,a}}class Hm extends Om{constructor(t){super(t)}load(t,e,n,i){const r=new Nc,s=new km(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let a=0;function o(n){s.load(t[n],(function(t){r.images[n]=t,a++,6===a&&(r.needsUpdate=!0,e&&e(r))}),void 0,i)}for(let e=0;e<t.length;++e)o(e);return r}}class Gm extends Om{constructor(t){super(t)}load(t,e,n,i){const r=new ml,s=new km(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,(function(n){r.image=n;const i=t.search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/);r.format=i?Fo:Oo,r.needsUpdate=!0,void 0!==e&&e(r)}),n,i),r}}class Vm extends wf{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new Of(e,t))}getPoint(t){const e=t*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=e){const t=n[i]-e,r=this.curves[i],s=r.getLength(),a=0===s?0:1-t/s;return r.getPointAt(a)}i++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],a=s&&s.isEllipseCurve?2*t:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?t*s.points.length:t,o=s.getPoints(a);for(let t=0;t<o.length;t++){const i=o[t];n&&n.equals(i)||(e.push(i),n=i)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new Hf[n.type]).fromJSON(n))}return this}}class Wm extends Vm{constructor(t){super(),this.type="Path",this.currentPoint=new cl,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new Of(this.currentPoint.clone(),new cl(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const r=new Uf(this.currentPoint.clone(),new cl(t,e),new cl(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,r,s){const a=new zf(this.currentPoint.clone(),new cl(t,e),new cl(n,i),new cl(r,s));return this.curves.push(a),this.currentPoint.set(r,s),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new kf(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,r,s){const a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+a,e+o,n,i,r,s),this}absarc(t,e,n,i,r,s){return this.absellipse(t,e,n,n,i,r,s),this}ellipse(t,e,n,i,r,s,a,o){const l=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+l,e+h,n,i,r,s,a,o),this}absellipse(t,e,n,i,r,s,a,o){const l=new Sf(t,e,n,i,r,s,a,o);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const h=l.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class jm extends Wm{constructor(t){super(t),this.uuid=sl(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new Wm).fromJSON(n))}return this}}class Xm extends wh{constructor(t,e=1){super(),this.type="Light",this.color=new Vh(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}Xm.prototype.isLight=!0;(class extends Xm{constructor(t,e,n){super(t,n),this.type="HemisphereLight",this.position.copy(wh.DefaultUp),this.updateMatrix(),this.groundColor=new Vh(e)}copy(t){return Xm.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}).prototype.isHemisphereLight=!0;const qm=new Kl,Ym=new Ml,Zm=new Ml;class Jm{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new cl(512,512),this.map=null,this.mapPass=null,this.matrix=new Kl,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Gc,this._frameExtents=new cl(1,1),this._viewportCount=1,this._viewports=[new vl(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Ym.setFromMatrixPosition(t.matrixWorld),e.position.copy(Ym),Zm.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Zm),e.updateMatrixWorld(),qm.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(qm),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Qm extends Jm{constructor(){super(new Pc(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=2*rl*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;n===e.fov&&i===e.aspect&&r===e.far||(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}Qm.prototype.isSpotLightShadow=!0;(class extends Xm{constructor(t,e,n=0,i=Math.PI/3,r=0,s=1){super(t,e),this.type="SpotLight",this.position.copy(wh.DefaultUp),this.updateMatrix(),this.target=new wh,this.distance=n,this.angle=i,this.penumbra=r,this.decay=s,this.shadow=new Qm}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}).prototype.isSpotLight=!0;const Km=new Kl,$m=new Ml,tg=new Ml;class eg extends Jm{constructor(){super(new Pc(90,1,.5,500)),this._frameExtents=new cl(4,2),this._viewportCount=6,this._viewports=[new vl(2,1,1,1),new vl(0,1,1,1),new vl(3,1,1,1),new vl(1,1,1,1),new vl(3,0,1,1),new vl(1,0,1,1)],this._cubeDirections=[new Ml(1,0,0),new Ml(-1,0,0),new Ml(0,0,1),new Ml(0,0,-1),new Ml(0,1,0),new Ml(0,-1,0)],this._cubeUps=[new Ml(0,1,0),new Ml(0,1,0),new Ml(0,1,0),new Ml(0,1,0),new Ml(0,0,1),new Ml(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),$m.setFromMatrixPosition(t.matrixWorld),n.position.copy($m),tg.copy(n.position),tg.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(tg),n.updateMatrixWorld(),i.makeTranslation(-$m.x,-$m.y,-$m.z),Km.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Km)}}eg.prototype.isPointLightShadow=!0;(class extends Xm{constructor(t,e,n=0,i=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new eg}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}).prototype.isPointLight=!0;class ng extends Jm{constructor(){super(new eu(-5,5,5,-5,.5,500))}}ng.prototype.isDirectionalLightShadow=!0;(class extends Xm{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(wh.DefaultUp),this.updateMatrix(),this.target=new wh,this.shadow=new ng}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}).prototype.isDirectionalLight=!0;(class extends Xm{constructor(t,e){super(t,e),this.type="AmbientLight"}}).prototype.isAmbientLight=!0;(class extends Xm{constructor(t,e,n=10,i=10){super(t,e),this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}).prototype.isRectAreaLight=!0;class ig{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new Ml)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*i),e.addScaledVector(s[2],.488603*r),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*i*1.092548),e.addScaledVector(s[5],i*r*1.092548),e.addScaledVector(s[6],.315392*(3*r*r-1)),e.addScaledVector(s[7],n*r*1.092548),e.addScaledVector(s[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*i),e.addScaledVector(s[2],1.023328*r),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*i),e.addScaledVector(s[5],.858086*i*r),e.addScaledVector(s[6],.743125*r*r-.247708),e.addScaledVector(s[7],.858086*n*r),e.addScaledVector(s[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+3*i);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+3*i);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}ig.prototype.isSphericalHarmonics3=!0;class rg extends Xm{constructor(t=new ig,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}rg.prototype.isLightProbe=!0;(class extends sc{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}).prototype.isInstancedBufferGeometry=!0;let sg;(class extends Om{constructor(t){super(t),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=zm.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader,fetch(t,a).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(r.options,{colorSpaceConversion:"none"}))})).then((function(n){zm.add(t,n),e&&e(n),r.manager.itemEnd(t)})).catch((function(e){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)})),r.manager.itemStart(t)}}).prototype.isImageBitmapLoader=!0;const ag=function(){return void 0===sg&&(sg=new(window.AudioContext||window.webkitAudioContext)),sg};class og extends Om{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new Bm(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(function(n){try{const t=n.slice(0);ag().decodeAudioData(t,(function(t){e(t)}))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}}(class extends rg{constructor(t,e,n=1){super(void 0,n);const i=(new Vh).set(t),r=(new Vh).set(e),s=new Ml(i.r,i.g,i.b),a=new Ml(r.r,r.g,r.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)}}).prototype.isHemisphereLightProbe=!0;(class extends rg{constructor(t,e=1){super(void 0,e);const n=(new Vh).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}).prototype.isAmbientLightProbe=!0;class lg{constructor(t,e,n){let i,r,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==i;++t)n[r+t]=n[t];s=e}else{s+=e;const t=e/s;this._mixBufferRegion(n,r,0,t,i)}this.cumulativeWeight=s}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const t=e*this._origIndex;this._mixBufferRegion(n,i,t,1-r,e)}s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let t=e,r=e+e;t!==r;++t)if(n[t]!==n[t+e]){a.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let t=n,r=i;t!==r;++t)e[t]=e[i+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let i=0;i!==r;++i)t[e+i]=t[n+i]}_slerp(t,e,n,i){_l.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const s=this._workIndex*r;_l.multiplyQuaternionsFlat(t,s,t,e,t,n),_l.slerpFlat(t,e,t,e,t,s,i)}_lerp(t,e,n,i,r){const s=1-i;for(let a=0;a!==r;++a){const r=e+a;t[r]=t[r]*s+t[n+a]*i}}_lerpAdditive(t,e,n,i,r){for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]+t[n+s]*i}}}const hg="\\[\\]\\.:\\/",cg=new RegExp("[\\[\\]\\.:\\/]","g"),ug="[^\\[\\]\\.:\\/]",dg="[^"+hg.replace("\\.","")+"]",pg=/((?:WC+[\/:])*)/.source.replace("WC",ug),fg=/(WCOD+)?/.source.replace("WCOD",dg),mg=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",ug),gg=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",ug),vg=new RegExp("^"+pg+fg+mg+gg+"$"),xg=["material","materials","bones"];class yg{constructor(t,e,n){this.path=e,this.parsedPath=n||yg.parseTrackName(e),this.node=yg.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new yg.Composite(t,e,n):new yg(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(cg,"")}static parseTrackName(t){const e=vg.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const t=n.nodeName.substring(i+1);-1!==xg.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let i=0;i<t.length;i++){const r=t[i];if(r.name===e||r.uuid===e)return r;const s=n(r.children);if(s)return s}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=yg.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let i=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===i){i=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==i){if(void 0===t[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[i]}}const s=t[i];if(void 0===s){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+i+" but it wasn't found.",t)}let a=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[r]&&(r=t.morphTargetDictionary[r])}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}yg.Composite=class{constructor(t,e,n){const i=n||yg.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];void 0!==i&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},yg.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},yg.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},yg.prototype.GetterByBindingType=[yg.prototype._getValue_direct,yg.prototype._getValue_array,yg.prototype._getValue_arrayElement,yg.prototype._getValue_toArray],yg.prototype.SetterByBindingTypeAndVersioning=[[yg.prototype._setValue_direct,yg.prototype._setValue_direct_setNeedsUpdate,yg.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[yg.prototype._setValue_array,yg.prototype._setValue_array_setNeedsUpdate,yg.prototype._setValue_array_setMatrixWorldNeedsUpdate],[yg.prototype._setValue_arrayElement,yg.prototype._setValue_arrayElement_setNeedsUpdate,yg.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[yg.prototype._setValue_fromArray,yg.prototype._setValue_fromArray_setNeedsUpdate,yg.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class _g{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,s=r.length,a=new Array(s),o={endingStart:Vo,endingEnd:Vo};for(let t=0;t!==s;++t){const e=r[t].createInterpolant(null);a[t]=e,e.settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,i=t._clip.duration,r=i/n,s=n/i;t.warp(1,r,e),this.warp(s,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,s=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=r,o[1]=r+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(null!==r){const i=(t-r)*n;if(i<0||0===n)return;this._startTime=null,e=n*i}e*=this._updateTimeScale(t);const s=this._updateTime(e),a=this._updateWeight(t);if(a>0){const t=this._interpolants,e=this._propertyBindings;if(2501===this.blendMode)for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulateAdditive(a);else for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulate(i,a)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;if(null!==n){e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const s=2202===n;if(0===t)return-1===r?i:s&&1==(1&r)?e-i:i;if(2200===n){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else{if(!(i<0)){this.time=i;break t}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===r&&(t>=0?(r=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),i>=e||i<0){const n=Math.floor(i/e);i-=e*n,r+=Math.abs(n);const a=this.repetitions-r;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===a){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(s&&1==(1&r))return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=Wo,i.endingEnd=Wo):(i.endingStart=t?this.zeroSlopeAtStart?Wo:Vo:jo,i.endingEnd=e?this.zeroSlopeAtEnd?Wo:Vo:jo)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;null===s&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const a=s.parameterPositions,o=s.sampleValues;return a[0]=r,o[0]=e,a[1]=r+t,o[1]=n,this}}(class extends el{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,s=t._propertyBindings,a=t._interpolants,o=n.uuid,l=this._bindingsByRootAndName;let h=l[o];void 0===h&&(h={},l[o]=h);for(let t=0;t!==r;++t){const r=i[t],l=r.name;let c=h[l];if(void 0!==c)s[t]=c;else{if(c=s[t],void 0!==c){null===c._cacheIndex&&(++c.referenceCount,this._addInactiveBinding(c,o,l));continue}const i=e&&e._propertyBindings[t].binding.parsedPath;c=new lg(yg.create(n,l,i),r.ValueTypeName,r.getValueSize()),++c.referenceCount,this._addInactiveBinding(c,o,l),s[t]=c}a[t].resultBuffer=c.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,i=this._actionsByClip[n];this._bindAction(t,i&&i.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let s=r[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=i.length,i.push(t),s.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,s=this._actionsByClip,a=s[r],o=a.knownActions,l=o[o.length-1],h=t._byClipCacheIndex;l._byClipCacheIndex=h,o[h]=l,o.pop(),t._byClipCacheIndex=null;delete a.actionByRoot[(t._localRoot||this._root).uuid],0===o.length&&delete s[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];void 0===s&&(s={},i[e]=s),s[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,a=s[i],o=e[e.length-1],l=t._cacheIndex;o._cacheIndex=l,e[l]=o,e.pop(),delete a[r],0===Object.keys(a).length&&delete s[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new wm(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let s="string"==typeof t?Im.findByName(i,t):t;const a=null!==s?s.uuid:t,o=this._actionsByClip[a];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:Xo),void 0!==o){const t=o.actionByRoot[r];if(void 0!==t&&t.blendMode===n)return t;l=o.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const h=new _g(this,s,e,n);return this._bindAction(h,l),this._addInactiveAction(h,a,r),h}existingAction(t,e){const n=e||this._root,i=n.uuid,r="string"==typeof t?Im.findByName(n,t):t,s=r?r.uuid:t,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[i]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),s=this._accuIndex^=1;for(let a=0;a!==n;++a){e[a]._update(i,t,r,s)}const a=this._bindings,o=this._nActiveBindings;for(let t=0;t!==o;++t)a[t].apply(s);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const t=r.knownActions;for(let n=0,i=t.length;n!==i;++n){const i=t[n];this._deactivateAction(i);const r=i._cacheIndex,s=e[e.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,s._cacheIndex=r,e[r]=s,e.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const i=n[t].actionByRoot[e];void 0!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}const i=this._bindingsByRootAndName[e];if(void 0!==i)for(const t in i){const e=i[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}).prototype._controlInterpolantsResultBuffer=new Float32Array(1);(class extends Pp{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}).prototype.isInstancedInterleavedBuffer=!0;(class extends wh{constructor(t){super(),this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}).prototype.isImmediateRenderObject=!0;const Mg=new Ml,bg=new Kl,wg=new Kl;function Sg(t){const e=[];t&&t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,Sg(t.children[n]));return e}const Eg=new Float32Array(1);new Int32Array(Eg.buffer),wf.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(wf.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},Wm.prototype.fromPoints=function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)},class extends gf{constructor(t=10,e=10,n=4473924,i=8947848){n=new Vh(n),i=new Vh(i);const r=e/2,s=t/e,a=t/2,o=[],l=[];for(let t=0,h=0,c=-a;t<=e;t++,c+=s){o.push(-a,0,c,a,0,c),o.push(c,0,-a,c,0,a);const e=t===r?n:i;e.toArray(l,h),h+=3,e.toArray(l,h),h+=3,e.toArray(l,h),h+=3,e.toArray(l,h),h+=3}const h=new sc;h.setAttribute("position",new Jh(o,3)),h.setAttribute("color",new Jh(l,3));super(h,new of({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},class extends gf{constructor(t){const e=Sg(t),n=new sc,i=[],r=[],s=new Vh(0,0,1),a=new Vh(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(a.r,a.g,a.b))}n.setAttribute("position",new Jh(i,3)),n.setAttribute("color",new Jh(r,3));super(n,new of({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");wg.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const r=e[t];r.parent&&r.parent.isBone&&(bg.multiplyMatrices(wg,r.matrixWorld),Mg.setFromMatrixPosition(bg),i.setXYZ(n,Mg.x,Mg.y,Mg.z),bg.multiplyMatrices(wg,r.parent.matrixWorld),Mg.setFromMatrixPosition(bg),i.setXYZ(n+1,Mg.x,Mg.y,Mg.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Om.prototype.extractUrlBase=function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),class{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}}.extractUrlBase(t)},Om.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Sl.prototype.center=function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},Sl.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Sl.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},Sl.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},Sl.prototype.size=function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)},Vl.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Gc.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},ul.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},ul.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},ul.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},ul.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},ul.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},ul.prototype.getInverse=function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},Kl.prototype.extractPosition=function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},Kl.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},Kl.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new Ml).setFromMatrixColumn(this,3)},Kl.prototype.setRotationFromQuaternion=function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},Kl.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Kl.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Kl.prototype.multiplyVector4=function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Kl.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Kl.prototype.rotateAxis=function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},Kl.prototype.crossVector=function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Kl.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Kl.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Kl.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Kl.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Kl.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Kl.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Kl.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Kl.prototype.makeFrustum=function(t,e,n,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,i,n,r,s)},Kl.prototype.getInverse=function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},Bc.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},_l.prototype.multiplyVector3=function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},_l.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},Ql.prototype.isIntersectionBox=function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},Ql.prototype.isIntersectionPlane=function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},Ql.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},Nh.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Nh.prototype.barycoordFromPoint=function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},Nh.prototype.midpoint=function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},Nh.prototypenormal=function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},Nh.prototype.plane=function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)},Nh.barycoordFromPoint=function(t,e,n,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Nh.getBarycoord(t,e,n,i,r)},Nh.normal=function(t,e,n,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Nh.getNormal(t,e,n,i)},jm.prototype.extractAllPoints=function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},jm.prototype.extrude=function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new gm(this,t)},jm.prototype.makeGeometry=function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new xm(this,t)},cl.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},cl.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},cl.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Ml.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},Ml.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},Ml.prototype.getPositionFromMatrix=function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},Ml.prototype.getScaleFromMatrix=function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},Ml.prototype.getColumnFromMatrix=function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},Ml.prototype.applyProjection=function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},Ml.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},Ml.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},Ml.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},vl.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},vl.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},wh.prototype.getChildByName=function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},wh.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},wh.prototype.translate=function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},wh.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},wh.prototype.applyMatrix=function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(wh.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),wc.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(wc.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),tf.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Pc.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(Xm.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(qh.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===$o},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage($o)}}}),qh.prototype.setDynamic=function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?$o:Ko),this},qh.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},qh.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},sc.prototype.addIndex=function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},sc.prototype.addAttribute=function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new qh(arguments[1],arguments[2])))},sc.prototype.addDrawCall=function(t,e,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},sc.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},sc.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},sc.prototype.removeAttribute=function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},sc.prototype.applyMatrix=function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(sc.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Pp.prototype.setDynamic=function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?$o:Ko),this},Pp.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},gm.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},gm.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},gm.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},Rp.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},Object.defineProperties(Fh.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Vh}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(Ac.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),Ap.prototype.clearTarget=function(t,e,n,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,n,i)},Ap.prototype.animate=function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},Ap.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},Ap.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},Ap.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},Ap.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},Ap.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},Ap.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},Ap.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},Ap.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},Ap.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},Ap.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},Ap.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},Ap.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},Ap.prototype.enableScissorTest=function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},Ap.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},Ap.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},Ap.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},Ap.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},Ap.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},Ap.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},Ap.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},Ap.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},Ap.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},Ap.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(Ap.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?Yo:qo}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(yp.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(xl.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),class extends wh{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}.prototype.load=function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return(new og).load(t,(function(t){e.setBuffer(t)})),this},Ic.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},Ic.prototype.clear=function(t,e,n,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,n,i)},pl.crossOrigin=void 0,pl.loadTexture=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new Gm;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},pl.loadTextureCube=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new Hm;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},pl.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},pl.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"132"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="132");class Tg extends He{constructor(t,e,n,i){const r=e.cellScale,s=i.container,a=e.cellSize,o=Math.cos(-n),l=Math.sin(-n),h=Math.cos(n),c=Math.sin(n),u=new $(a/s.clientWidth,a/s.clientHeight),d=new Float32Array([o,-l,l,o]);super({vertexShader:Ta.glyphVertexShader,fragmentShader:Ta.glyphFragmentShader,type:"CV.GlyphMaterial",uniforms:Object.assign({cellScale:{value:r},atlas:{value:e.getTexture()},rotate:{value:d},scale:{value:u}},t.materials.commonUniforms)}),this.rotation=n,this.alphaTest=.9,this.depthTest=!1,this.transparent=!0,this.type="CV.GlyphMaterial",this.atlas=e,this.scaleFactor=e.cellSize/2,this.toScreenSpace=new Ml(s.clientWidth/2,s.clientHeight/2,1),i.addEventListener("resized",(function(){p.uniforms.scale.value.set(a/s.clientWidth,a/s.clientHeight),p.toScreenSpace.set(s.clientWidth/2,s.clientHeight/2,1)}));const p=this;this.rotateVector=function(t){const e=t.x,n=t.y;t.x=h*e-c*n,t.y=c*e+h*n}}getAtlas(){return this.atlas}}class Lg extends He{constructor(t){const e=t.survey,n=e.modelLimits,i=n.min.z,r=n.max.z,s=t.cfg.value("saturatedGradient",!1)?"gradientHi":"gradientLow",a=t.materials.textureCache;super({vertexShader:Ta.heightVertexShader,fragmentShader:Ta.heightFragmentShader,type:"CV.HeightMaterial",uniforms:Object.assign({uLight:{value:e.lightDirection},minZ:{value:i},scaleZ:{value:1/(r-i)},cmap:{value:a.getTexture(s)}},t.materials.commonUniforms),defines:{USE_COLOR:!0}}),this.midRange=(r+i)/2}}const Cg=["uniform float minZ;","uniform float scaleZ;","varying float zMap;","varying vec2 vPosition;"].join("\n"),Ag=["vPosition = vec2( position.x, position.y );","zMap = saturate( ( position.z - minZ ) * scaleZ );"].join("\n"),Rg=["uniform sampler2D cmap;","varying float zMap;",Ta.commonTerrainCodePars].join("\n"),Pg=["diffuseColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) );","diffuseColor.a = opacity;",Ta.commonTerrainCodeColor].join("\n");class Dg extends ho{constructor(t){const e=t.survey,n=t.cfg,i=e.terrain,r=t.materials.textureCache;super();let s=n.themeValue("shading.hypsometric.min"),a=n.themeValue("shading.hypsometric.max");void 0===i.boundBox&&i.computeBoundingBox(),void 0===s&&(s=i.boundingBox.min.z),void 0===a&&(a=i.boundingBox.max.z),this.transparent=!0,this.onBeforeCompile=function(e){Object.assign(e.uniforms,t.materials.commonTerrainUniforms,{minZ:{value:s},scaleZ:{value:1/(a-s)},cmap:{value:r.getTexture("hypsometric")}}),this.editShader(e,Cg,Ag,Rg,Pg)},Object.defineProperty(this,"opacity",{get:function(){return t.materials.terrainOpacity}})}}class Ig extends Ns{constructor(t){super({color:16746632}),this.transparent=!0,Object.defineProperty(this,"opacity",{get:function(){return t.materials.terrainOpacity}})}}Object.assign(Ig.prototype,ho.prototype);class Ng extends Ca{constructor(t,e="height",n){const i=t.survey,r=t.cfg,s=r.value("saturatedGradient",!1)?"gradientHi":"gradientLow",a=t.materials.textureCache,o=i.modelLimits,l=o.max.z,h=o.min.z,c={};let u=null,d=null,p=null,f=null;i.terrain&&(u=i.terrain,u.boundingBox&&(d=u.boundingBox,p=d.getSize(new lt)));let m={};switch(e){case"height":c.CV_HEIGHT=!0,m={minZ:{value:h},scaleZ:{value:1/(l-h)},cmap:{value:a.getTexture(s)}};break;case"cursor":c.CV_CURSOR=!0,m={cursor:{value:0},cursorWidth:{value:5},baseColor:{value:r.themeColor("shading.cursorBase")},cursorColor:{value:r.themeColor("shading.cursor")}};break;case"depth":c.CV_DEPTH=!0,m=Object.assign({modelMin:{value:d.min},scaleX:{value:1/p.x},scaleY:{value:1/p.y},rangeZ:{value:p.z},depthScale:{value:1/(o.max.z-o.min.z)},cmap:{value:a.getTexture(s)},depthMap:{value:u.depthTexture}},t.materials.commonDepthUniforms);break;case"depth-cursor":f=o.max.z-o.min.z,c.CV_DEPTH_CURSOR=!0,m=Object.assign({modelMin:{value:d.min},scaleX:{value:1/p.x},scaleY:{value:1/p.y},rangeZ:{value:p.z},depthMap:{value:u.depthTexture},cursor:{value:f/2},cursorWidth:{value:5},baseColor:{value:r.themeColor("shading.cursorBase")},cursorColor:{value:r.themeColor("shading.cursor")}},t.materials.commonDepthUniforms);break;default:c.CV_BASIC=!0}n&&(c.USE_DASH=!0);super(t,{color:16777215,vertexColors:!0,dashSize:2,gapSize:2},c,m),this.halfRange=(o.max.z-o.min.z)/2,this.max=f}setCursor(t){let e;return e=null!==this.max?Math.max(Math.min(t,this.max),0):Math.max(Math.min(t,this.halfRange),-this.halfRange),this.uniforms.cursor.value=e,e}getCursor(){return this.uniforms.cursor.value}}const zg={inclination:[[255,255,0],[253,254,2],[251,253,4],[249,252,5],[247,251,7],[245,250,9],[243,249,11],[241,249,13],[239,248,14],[237,247,16],[235,246,18],[233,245,20],[231,244,22],[229,243,23],[227,242,25],[225,241,27],[223,240,29],[221,239,31],[219,238,32],[217,237,34],[215,237,36],[213,236,38],[211,235,40],[209,234,41],[207,233,43],[205,232,45],[203,231,47],[201,230,49],[199,229,50],[197,228,52],[195,227,54],[193,226,56],[191,226,58],[189,225,60],[187,224,61],[185,223,63],[183,222,65],[181,221,67],[179,220,69],[177,219,70],[175,218,72],[173,217,74],[171,216,76],[169,215,78],[167,214,79],[165,214,81],[163,213,83],[161,212,85],[159,211,87],[157,210,88],[155,209,90],[153,208,92],[151,207,94],[149,206,96],[147,205,97],[145,204,99],[143,203,101],[141,202,103],[139,202,105],[137,201,106],[135,200,108],[133,199,110],[131,198,112],[129,197,114],[126,196,115],[124,195,117],[122,194,119],[120,193,121],[118,192,123],[116,191,124],[114,191,126],[112,190,128],[110,189,130],[108,188,132],[106,187,133],[104,186,135],[102,185,137],[100,184,139],[98,183,141],[96,182,142],[94,181,144],[92,180,146],[90,179,148],[88,179,150],[86,178,151],[84,177,153],[82,176,155],[80,175,157],[78,174,159],[76,173,160],[74,172,162],[72,171,164],[70,170,166],[68,169,168],[66,168,169],[64,167,171],[62,167,173],[60,166,175],[58,165,177],[56,164,179],[54,163,180],[52,162,182],[50,161,184],[48,160,186],[46,159,188],[44,158,189],[42,157,191],[40,156,193],[38,156,195],[36,155,197],[34,154,198],[32,153,200],[30,152,202],[28,151,204],[26,150,206],[24,149,207],[22,148,209],[20,147,211],[18,146,213],[16,145,215],[14,144,216],[12,144,218],[10,143,220],[8,142,222],[6,141,224],[4,140,225],[2,139,227],[0,138,229]],gradientLow:[[235,99,111],[235,99,112],[234,99,113],[234,100,114],[233,100,114],[233,100,115],[232,100,116],[232,101,117],[231,101,118],[231,101,119],[230,101,119],[230,101,120],[230,102,121],[229,102,122],[229,102,123],[228,102,124],[228,103,124],[227,103,125],[227,103,126],[226,103,127],[226,103,128],[226,104,129],[225,104,129],[225,104,130],[224,104,131],[224,104,132],[223,105,133],[223,105,134],[222,105,134],[222,105,135],[221,106,136],[221,106,137],[221,106,138],[220,106,139],[220,106,139],[219,107,140],[219,107,141],[218,107,142],[218,107,143],[217,108,144],[217,108,144],[216,108,145],[216,108,146],[216,108,147],[215,109,148],[215,109,149],[214,109,149],[214,109,150],[213,110,151],[213,110,152],[212,110,153],[212,110,154],[211,110,154],[211,111,155],[211,111,156],[210,111,157],[210,111,158],[209,111,159],[209,112,159],[208,112,160],[208,112,161],[207,112,162],[207,113,163],[207,113,164],[206,113,164],[206,113,165],[205,113,166],[205,114,167],[204,114,168],[204,114,169],[203,114,169],[203,115,170],[202,115,171],[202,115,172],[201,115,172],[200,116,173],[199,116,173],[198,116,173],[197,117,174],[196,117,174],[194,118,174],[193,118,175],[192,118,175],[191,119,176],[190,119,176],[189,119,176],[188,120,177],[187,120,177],[186,121,177],[185,121,178],[184,121,178],[183,122,178],[181,122,179],[180,122,179],[179,123,179],[178,123,180],[177,124,180],[176,124,181],[175,124,181],[174,125,181],[173,125,182],[172,125,182],[171,126,182],[170,126,183],[168,126,183],[167,127,183],[166,127,184],[165,128,184],[164,128,184],[163,128,185],[162,129,185],[161,129,186],[160,129,186],[159,130,186],[158,130,187],[157,131,187],[155,131,187],[154,131,188],[153,132,188],[152,132,188],[151,132,189],[150,133,189],[149,133,189],[148,133,190],[147,134,190],[146,134,191],[145,135,191],[144,135,191],[142,135,192],[141,136,192],[140,136,192],[139,136,193],[138,137,193],[137,137,193],[136,138,194],[135,138,194],[134,138,194],[133,139,195],[132,139,195],[131,139,196],[129,140,196],[128,140,196],[127,141,197],[126,141,197],[125,141,197],[124,142,198],[123,142,198],[122,142,198],[120,142,197],[119,143,197],[117,143,197],[116,143,197],[114,143,196],[113,144,196],[111,144,196],[110,144,195],[108,144,195],[107,144,195],[105,145,195],[104,145,194],[102,145,194],[101,145,194],[100,146,193],[98,146,193],[97,146,193],[95,146,193],[94,146,192],[92,147,192],[91,147,192],[89,147,191],[88,147,191],[86,147,191],[85,148,191],[83,148,190],[82,148,190],[80,148,190],[79,149,189],[78,149,189],[76,149,189],[75,149,189],[73,149,188],[72,150,188],[70,150,188],[69,150,187],[67,150,187],[66,151,187],[64,151,186],[63,151,186],[61,151,186],[60,151,186],[59,152,185],[57,152,185],[56,152,185],[54,152,184],[53,153,184],[51,153,184],[50,153,184],[48,153,183],[47,153,183],[45,154,183],[44,154,182],[42,154,182],[41,154,182],[39,154,182],[38,155,181],[37,155,181],[35,155,181],[34,155,180],[32,156,180],[31,156,180],[29,156,180],[28,156,179],[26,156,179],[25,157,179],[23,157,178],[22,157,178],[20,157,178],[19,158,178],[17,158,177],[16,158,177],[16,158,176],[17,158,176],[17,158,175],[18,158,174],[18,158,174],[19,158,173],[19,158,172],[20,158,171],[20,158,171],[21,158,170],[21,158,169],[22,158,169],[22,159,168],[23,159,167],[23,159,167],[23,159,166],[24,159,165],[24,159,164],[25,159,164],[25,159,163],[26,159,162],[26,159,162],[27,159,161],[27,159,160],[28,159,160],[28,159,159],[29,159,158],[29,159,157],[30,159,157],[30,159,156],[30,159,155],[31,159,155],[31,159,154],[32,159,153],[32,159,153],[33,159,152],[33,160,151],[34,160,150],[34,160,150],[35,160,149],[35,160,148],[36,160,148],[36,160,147],[36,160,146],[37,160,146],[37,160,145],[38,160,144],[38,160,143],[39,160,143],[39,160,142],[40,160,141],[40,160,141],[41,160,140],[41,160,139],[42,160,139],[42,160,138],[43,160,137],[43,160,136],[43,160,136],[44,160,135],[44,161,134],[45,161,134],[45,161,133],[46,161,132],[46,161,132],[47,161,131],[47,161,130],[48,161,129],[48,161,129],[49,161,128],[49,161,127],[50,161,127],[50,161,126],[51,161,125],[52,161,125],[53,161,124],[54,161,123],[55,161,123],[56,161,122],[56,160,121],[57,160,121],[58,160,120],[59,160,120],[60,160,119],[61,160,118],[62,160,118],[63,160,117],[64,160,116],[65,160,116],[66,160,115],[67,160,114],[67,159,114],[68,159,113],[69,159,112],[70,159,112],[71,159,111],[72,159,111],[73,159,110],[74,159,109],[75,159,109],[76,159,108],[77,159,107],[78,159,107],[78,158,106],[79,158,105],[80,158,105],[81,158,104],[82,158,103],[83,158,103],[84,158,102],[85,158,102],[86,158,101],[87,158,100],[88,158,100],[89,158,99],[89,157,98],[90,157,98],[91,157,97],[92,157,96],[93,157,96],[94,157,95],[95,157,94],[96,157,94],[97,157,93],[98,157,93],[99,157,92],[100,157,91],[100,156,91],[101,156,90],[102,156,89],[103,156,89],[104,156,88],[105,156,87],[106,156,87],[107,156,86],[108,156,85],[109,156,85],[110,156,84],[111,156,84],[111,155,83],[112,155,82],[113,155,82],[114,155,81],[115,155,80],[116,155,80],[117,155,79],[118,155,79],[118,155,79],[119,154,78],[120,154,78],[121,154,78],[121,154,78],[122,154,78],[123,153,77],[123,153,77],[124,153,77],[125,153,77],[126,153,77],[126,152,77],[127,152,76],[128,152,76],[128,152,76],[129,152,76],[130,151,76],[131,151,75],[131,151,75],[132,151,75],[133,150,75],[133,150,75],[134,150,74],[135,150,74],[136,150,74],[136,149,74],[137,149,74],[138,149,73],[138,149,73],[139,149,73],[140,148,73],[141,148,73],[141,148,72],[142,148,72],[143,148,72],[143,147,72],[144,147,72],[145,147,72],[145,147,71],[146,147,71],[147,146,71],[148,146,71],[148,146,71],[149,146,70],[150,146,70],[150,145,70],[151,145,70],[152,145,70],[153,145,69],[153,145,69],[154,144,69],[155,144,69],[155,144,69],[156,144,68],[157,143,68],[158,143,68],[158,143,68],[159,143,68],[160,143,67],[160,142,67],[161,142,67],[162,142,67],[163,142,67],[163,142,67],[164,141,66],[165,141,66],[165,141,66],[166,141,66],[167,141,66],[168,140,65],[168,140,65],[169,140,65],[169,140,65],[170,140,66],[170,139,66],[171,139,66],[171,139,67],[172,139,67],[172,139,67],[172,138,68],[173,138,68],[173,138,68],[174,138,69],[174,138,69],[175,137,69],[175,137,70],[175,137,70],[176,137,70],[176,137,71],[177,136,71],[177,136,71],[177,136,72],[178,136,72],[178,135,72],[179,135,73],[179,135,73],[180,135,73],[180,135,74],[180,134,74],[181,134,74],[181,134,75],[182,134,75],[182,134,75],[183,133,76],[183,133,76],[183,133,76],[184,133,77],[184,133,77],[185,132,77],[185,132,77],[186,132,78],[186,132,78],[186,132,78],[187,131,79],[187,131,79],[188,131,79],[188,131,80],[189,131,80],[189,130,80],[189,130,81],[190,130,81],[190,130,81],[191,130,82],[191,129,82],[192,129,82],[192,129,83],[192,129,83],[193,128,83],[193,128,84],[194,128,84],[194,128,84],[194,128,85],[195,127,85],[195,127,85],[196,127,86],[196,127,86],[197,127,86],[197,126,87],[197,126,87],[198,126,87],[198,126,88],[199,126,88],[199,125,88],[200,125,89],[200,125,89]],gradientHi:[[167,1,221],[131,4,228],[74,2,231],[47,2,242],[2,27,247],[3,33,251],[4,39,254],[5,51,254],[6,75,254],[7,101,254],[8,127,238],[9,151,213],[10,177,168],[19,202,123],[30,227,78],[41,252,40],[72,254,36],[126,254,33],[167,254,30],[194,253,30],[220,224,29],[253,203,31],[254,176,25],[254,148,21],[254,120,18],[254,90,13],[254,61,9],[254,30,6],[254,2,2],[254,1,1],[254,1,1],[255,0,0]],survey:[[166,206,227],[31,120,180],[178,223,138],[51,160,44],[251,154,153],[227,26,28],[253,191,111],[255,127,0],[202,178,214],[106,61,154],[255,255,153]],depth:[[255,255,204],[255,255,203],[255,255,203],[255,254,202],[255,254,202],[255,254,201],[255,254,200],[255,253,200],[255,253,199],[255,253,199],[255,253,198],[255,252,197],[255,252,197],[255,252,196],[255,252,196],[255,251,195],[255,251,194],[255,251,194],[255,251,193],[255,250,193],[255,250,192],[255,250,191],[255,250,191],[255,249,190],[255,249,190],[255,249,189],[255,249,188],[255,248,188],[255,248,187],[255,248,187],[255,248,186],[255,247,185],[255,247,185],[255,247,184],[255,247,184],[255,246,183],[255,246,182],[255,246,182],[255,246,181],[255,245,180],[255,245,180],[255,245,179],[255,245,179],[255,244,178],[255,244,177],[255,244,177],[255,244,176],[255,243,176],[255,243,175],[255,243,174],[255,243,174],[255,242,173],[255,242,173],[255,242,172],[255,242,171],[255,241,171],[255,241,170],[255,241,170],[255,241,169],[255,240,168],[255,240,168],[255,240,167],[255,240,167],[255,239,166],[255,239,165],[255,239,165],[255,239,164],[255,238,164],[255,238,163],[255,238,162],[255,238,162],[255,237,161],[255,237,161],[255,237,160],[255,237,159],[255,236,159],[255,236,158],[255,236,158],[255,236,157],[255,235,157],[255,235,156],[255,235,155],[255,235,155],[255,234,154],[255,234,154],[255,234,153],[255,233,153],[255,233,152],[255,233,151],[255,233,151],[255,232,150],[255,232,150],[255,232,149],[255,232,148],[255,231,148],[255,231,147],[255,231,147],[255,230,146],[255,230,146],[255,230,145],[255,230,144],[255,229,144],[255,229,143],[255,229,143],[255,229,142],[255,228,142],[255,228,141],[255,228,140],[255,227,140],[255,227,139],[254,227,139],[254,227,138],[254,226,138],[254,226,137],[254,226,136],[254,225,136],[254,225,135],[254,225,135],[254,225,134],[254,224,134],[254,224,133],[254,224,132],[254,224,132],[254,223,131],[254,223,131],[254,223,130],[254,222,130],[254,222,129],[254,222,128],[254,222,128],[254,221,127],[254,221,127],[254,221,126],[254,221,125],[254,220,125],[254,220,124],[254,220,124],[254,219,123],[254,219,123],[254,219,122],[254,219,121],[254,218,121],[254,218,120],[254,218,120],[254,218,119],[254,217,119],[254,217,118],[254,216,117],[254,216,117],[254,215,116],[254,215,116],[254,214,115],[254,214,115],[254,213,114],[254,213,113],[254,212,113],[254,212,112],[254,211,112],[254,211,111],[254,210,111],[254,210,110],[254,209,109],[254,208,109],[254,208,108],[254,207,108],[254,207,107],[254,206,106],[254,206,106],[254,205,105],[254,205,105],[254,204,104],[254,204,104],[254,203,103],[254,203,102],[254,202,102],[254,202,101],[254,201,101],[254,200,100],[254,200,100],[254,199,99],[254,199,98],[254,198,98],[254,198,97],[254,197,97],[254,197,96],[254,196,96],[254,196,95],[254,195,94],[254,195,94],[254,194,93],[254,193,93],[254,193,92],[254,192,92],[254,192,91],[254,191,90],[254,191,90],[254,190,89],[254,190,89],[254,189,88],[254,189,88],[254,188,87],[254,188,86],[254,187,86],[254,187,85],[254,186,85],[254,185,84],[254,185,83],[254,184,83],[254,184,82],[254,183,82],[254,183,81],[254,182,81],[254,182,80],[254,181,79],[254,181,79],[254,180,78],[254,180,78],[254,179,77],[254,179,77],[254,178,76],[254,177,76],[254,177,76],[254,176,75],[254,176,75],[254,175,75],[254,175,75],[254,174,74],[254,174,74],[254,173,74],[254,173,74],[254,172,74],[254,172,73],[254,171,73],[254,171,73],[254,170,73],[254,170,72],[254,169,72],[254,169,72],[254,168,72],[254,168,72],[254,167,71],[254,167,71],[254,166,71],[254,166,71],[254,165,71],[254,165,70],[254,164,70],[254,164,70],[254,163,70],[254,163,69],[254,162,69],[254,162,69],[254,161,69],[254,161,69],[254,160,68],[254,160,68],[253,159,68],[253,159,68],[253,158,67],[253,158,67],[253,157,67],[253,157,67],[253,156,67],[253,156,66],[253,155,66],[253,155,66],[253,154,66],[253,154,65],[253,153,65],[253,153,65],[253,152,65],[253,152,65],[253,151,64],[253,151,64],[253,150,64],[253,150,64],[253,149,64],[253,149,63],[253,148,63],[253,148,63],[253,147,63],[253,147,62],[253,146,62],[253,146,62],[253,145,62],[253,145,62],[253,144,61],[253,144,61],[253,143,61],[253,143,61],[253,142,60],[253,142,60],[253,141,60],[253,140,60],[253,139,60],[253,138,59],[253,138,59],[253,137,59],[253,136,59],[253,135,58],[253,134,58],[253,133,58],[253,132,58],[253,132,57],[253,131,57],[253,130,57],[253,129,57],[253,128,56],[253,127,56],[253,126,56],[253,125,56],[253,125,55],[253,124,55],[253,123,55],[253,122,55],[253,121,54],[253,120,54],[253,119,54],[253,119,54],[253,118,53],[253,117,53],[253,116,53],[253,115,53],[253,114,52],[253,113,52],[253,113,52],[253,112,52],[253,111,51],[253,110,51],[252,109,51],[252,108,51],[252,107,50],[252,106,50],[252,106,50],[252,105,50],[252,104,49],[252,103,49],[252,102,49],[252,101,49],[252,100,48],[252,100,48],[252,99,48],[252,98,48],[252,97,47],[252,96,47],[252,95,47],[252,94,47],[252,94,46],[252,93,46],[252,92,46],[252,91,46],[252,90,45],[252,89,45],[252,88,45],[252,87,45],[252,87,44],[252,86,44],[252,85,44],[252,84,44],[252,83,43],[252,82,43],[252,81,43],[252,81,43],[252,80,42],[252,79,42],[252,78,42],[252,77,42],[251,77,42],[251,76,41],[251,75,41],[250,74,41],[250,74,41],[250,73,41],[249,72,40],[249,72,40],[249,71,40],[248,70,40],[248,69,40],[248,69,40],[247,68,39],[247,67,39],[247,67,39],[246,66,39],[246,65,39],[245,64,38],[245,64,38],[245,63,38],[244,62,38],[244,62,38],[244,61,37],[243,60,37],[243,59,37],[243,59,37],[242,58,37],[242,57,36],[242,57,36],[241,56,36],[241,55,36],[241,54,36],[240,54,35],[240,53,35],[240,52,35],[239,52,35],[239,51,35],[239,50,35],[238,50,34],[238,49,34],[238,48,34],[237,47,34],[237,47,34],[237,46,33],[236,45,33],[236,45,33],[236,44,33],[235,43,33],[235,42,32],[235,42,32],[234,41,32],[234,40,32],[234,40,32],[233,39,31],[233,38,31],[232,37,31],[232,37,31],[232,36,31],[231,35,30],[231,35,30],[231,34,30],[230,33,30],[230,32,30],[230,32,30],[229,31,29],[229,30,29],[229,30,29],[228,29,29],[228,28,29],[228,27,28],[227,27,28],[227,26,28],[226,26,28],[226,25,28],[225,25,28],[224,25,29],[224,24,29],[223,24,29],[222,24,29],[222,23,29],[221,23,29],[220,22,29],[219,22,30],[219,22,30],[218,21,30],[217,21,30],[217,21,30],[216,20,30],[215,20,30],[215,20,30],[214,19,31],[213,19,31],[213,19,31],[212,18,31],[211,18,31],[211,17,31],[210,17,31],[209,17,32],[209,16,32],[208,16,32],[207,16,32],[206,15,32],[206,15,32],[205,15,32],[204,14,33],[204,14,33],[203,14,33],[202,13,33],[202,13,33],[201,12,33],[200,12,33],[200,12,33],[199,11,34],[198,11,34],[198,11,34],[197,10,34],[196,10,34],[195,10,34],[195,9,34],[194,9,35],[193,9,35],[193,8,35],[192,8,35],[191,7,35],[191,7,35],[190,7,35],[189,6,36],[189,6,36],[188,6,36],[187,5,36],[187,5,36],[186,5,36],[185,4,36],[185,4,36],[184,4,37],[183,3,37],[182,3,37],[182,2,37],[181,2,37],[180,2,37],[180,1,37],[179,1,38],[178,1,38],[178,0,38],[177,0,38]],hypsometric:[[148,191,139],[148,191,139],[168,198,143],[168,198,143],[189,204,150],[189,204,150],[209,215,171],[209,215,171],[225,228,181],[225,228,181],[239,235,192],[239,235,192],[232,225,182],[232,225,182],[222,214,163],[222,214,163],[211,202,157],[211,202,157],[202,185,130],[202,185,130],[195,167,107],[195,167,107],[192,154,83],[192,154,83],[184,146,71],[184,146,71],[175,140,71],[175,140,71],[168,136,71],[168,136,71],[159,128,72],[159,128,72]]};class Fg{constructor(){const t=[];this.getColors=function(e){let n=t[e];if(void 0===n){const i=zg[e];void 0===i&&console.error("unknown colour scale requested "+e),n=i.map((t=>new te(t[0]/255,t[1]/255,t[2]/255))),t[e]=n}return n}}}class Og{constructor(){const t=[];this.getTexture=function(e){let n=t[e];if(void 0===n){if("disc"===e)n=(new ks).load("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg id='a' width='32mm' height='32mm' version='1.1' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' %3E%3Ccircle id='d' cx='16' cy='16' r='14' color='%23000000' fill='%23fff' fill-rule='evenodd' stroke-width='0'/%3E%3C/svg%3E%0A");else if("disc-outlined"===e)n=(new ks).load("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg id='a' width='32mm' height='32mm' version='1.1' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' %3E%3Ccircle id='d' cx='16' cy='16' r='14' color='%23000000' fill='%23fff' fill-rule='evenodd' stroke-width='1' stroke='%23000'/%3E%3C/svg%3E%0A");else{const t=zg[e];void 0===t&&console.error("unknown colour scale requested "+e),n=function(t){const e=Uint8Array.from(t.flat()),n=new As(e,t.length,1,D,T);return n.minFilter=S,n.magFilter=S,n.needsUpdate=!0,n}(t)}t[e]=n}return n}}}class Ug{constructor(t){const e=512,n=32,i=16,r=document.createElement("canvas"),s=" °☐ ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%,.-_/()[]'\"",a={};let o=s.length;if(this.cellScale=.0625,this.cellSize=n,o>256)return void console.error("too many glyphs for atlas");r||console.error("creating canvas for glyph atlas failed"),r.width=e,r.height=e;const l=r.getContext("2d");l||console.error("cannot obtain 2D canvas"),l.fillStyle=t.background||"rgba( 0, 0, 0, 0 )",l.fillRect(0,0,e,e),l.textAlign="left",l.font="28px "+t.font,l.fillStyle=t.color||"#ffffff";for(let t=0;t<o;t++)c(s.charAt(t),t);const h=new Rs(r);function c(t,e){const r=l.measureText(t).width/n,s=Math.floor(e/i)+1,o=e%i,h={row:(i-s)/i,column:o/i,width:r};return a[t]=h,l.fillText(t,n*o,n*s-7),h}h.minFilter=S,this.generateMipmaps=!1,this.getTexture=function(){return h},this.getGlyph=function(t){let e=a[t];if(void 0===e){if(o+1>256)return void console.warn("too many glyphs for atlas when adding ["+t+"]");e=c(t,o++),h.needsUpdate=!0}return e}}}function Bg(){const t=[];this.getAtlas=function(e){const n=JSON.stringify(e);let i=t[n];return void 0===i&&(i=new Ug(e),t[n]=i),i}}class kg extends bs{constructor(t){const e=t.cfg.themeValue("entrance_dot_size");super({map:t.materials.textureCache.getTexture("disc-outlined"),opacity:1,alphaTest:.8,sizeAttenuation:!1,transparent:!0,size:Math.max(e,Math.floor(e*t.container.clientWidth/1e3)),vertexColors:!0}),this.stencilWrite=!0,this.stencilZPass=H,t.viewer.addEventListener("resized",(t=>{this.size=Math.max(e,Math.floor(e*t.width/1e3))}))}}function Hg(t){const e=new Map,n=t.ctx,i=this,r=new Bg,s=new Set,a=new Set;let o={},l=0,h=1;const c=new Fg,u=new Og;this.colourCache=c,this.textureCache=u;const d=n.cfg.value("saturatedGradient",!1)||n.cfg.themeValue("saturatedGradient")?"gradientHi":"gradientLow",p=n.cfg.themeValue("shading.single");this.commonUniforms={fogColor:{value:n.cfg.themeColor("background")},fogDensity:{value:.0025},fogEnabled:{value:0},distanceTransparency:{value:0}},this.commonDepthUniforms={datumShift:{value:0}},this.commonTerrainUniforms={scale:{value:0},accuracy:{value:0},target:{value:new $},ringColor:{value:new te(16711680)}},this.terrainOpacity=.5,Object.defineProperty(this,"cursorHeight",{get:function(){return l},set:function(t){s.forEach((e=>l=e.setCursor(t)))}}),Object.defineProperty(this,"linewidth",{get:function(){return h},set:function(t){a.forEach((e=>{e.linewidth=t,h=t}))}});const f=this.commonUniforms.distanceTransparency;function m(t,n,i){let r=e.get(t);return void 0===r&&(r=function(t,n,i){return e.set(t,n),i&&(n.stencilWrite=!0,n.stencilZPass=H),n}(t,n(),i)),r}function g(t,e,n){const i=m(t,e,n);return o[t]=i,i}function v(t){i.commonDepthUniforms.datumShift.value=t.value}Object.defineProperty(this,"distanceTransparency",{get:function(){return f.value},set:function(t){f.value=t}}),this.getLine2Material=function(t={color:"green"}){return m("line2"+JSON.stringify(t),(function(){return new Ca(n,t)}),!0)},this.getSurveyLineMaterial=function(t="",e=!1){const i=g("survey-line-"+t+(e?"-dashed":""),(function(){return new Ng(n,t,e)}),!0);return"cursor"!==t&&"depth-cursor"!==t||s.add(i),a.add(i),i.linewidth=h,i},this.getHeightMaterial=function(){return g("height",(function(){return new Lg(n)}),!0)},this.getHypsometricMaterial=function(){return g("hypsometric",(function(){return new Dg(n)}))},this.getDepthMapMaterial=function(t){return new xo(t)},this.getDepthMaterial=function(){return g("depth",(function(){return new go(n)}),!0)},this.getCursorMaterial=function(){const t=g("cursor",(function(){return new oo(n)}),!0);return s.add(t),t},this.getDepthCursorMaterial=function(){const t=g("depthCursor",(function(){return new vo(n)}),!0);return s.add(t),t},this.getBezelMaterial=function(){let t;return t="flat"===n.cfg.themeValue("hud.bezelType")?function(){return new ln({color:n.cfg.themeValue("hud.bezel")})}:function(){return new zs({color:n.cfg.themeValue("hud.bezel"),specular:8947848})},m("bezel",t,!0)},this.getPlainMaterial=function(){return m("plain",(function(){return new ln({color:16777215,vertexColors:!0})}),!0)},this.getSurfaceMaterial=function(){return m("surface",(function(){return new Ns({color:p,vertexColors:!1})}),!0)},this.getEntrancePointMaterial=function(){return m("entrqnce",(function(){return new kg(n)}),!0)},this.getExtendedPointsMaterial=function(){return m("extendedPoints",(function(){return new yo(n)}),!0)},this.getMissingMaterial=function(){return m("missing",(function(){return new Ig(n)}))},this.getUnselectedMaterial=function(){return m("unselected",(function(){return new Ms({color:4473924,vertexColors:!0})}))},this.getUnselectedWallMaterial=function(){return m("unselectedWall",(function(){return new Ns({color:4473924,vertexColors:!0})}))},this.getScaleMaterial=function(){return m("scale",(function(){return new ln({color:16777215,map:u.getTexture(d)})}))},this.getContourMaterial=function(){return g("contour",(function(){return new mo(n)}))},this.getGlyphMaterial=function(e,i){const s=r.getAtlas(e);return m(JSON.stringify(e)+":"+i.toString(),(function(){return new Tg(n,s,i,t)}))},this.getClusterMaterial=function(t){return m("cluster"+t,(function(){return new lo(t)}),!0)},this.setTerrain=function(t){t.addEventListener("datumShiftChange",v)},this.flushCache=function(){s.clear(),a.clear();for(const t in o){o[t].dispose(),e.delete(t)}o={},n.glyphStringCache=new Map,l=0},this.setFog=function(t){i.commonUniforms.fogEnabled.value=t?1:0}}function Gg(t,e,n){this.colorMatrixLeft=(new tt).fromArray([1.0671679973602295,-.0016435992438346148,.0001777536963345483,-.028107794001698494,-.00019593400065787137,-.0002875397040043026,-.04279090091586113,15809757314855233e-21,-.00024287120322696865]),this.colorMatrixRight=(new tt).fromArray([-.0355340838432312,-.06440307199954987,.018319187685847282,-.10269022732973099,.8079727292060852,-.04835830628871918,.0001224992738571018,-.009558862075209618,.567823588848114]);const i=new Vn(-1,1,1,-1,0,1),r=new _s,s=new Ks;s.cameraL.layers.mask=4294967295,s.cameraR.layers.mask=4294967295;const a={minFilter:S,magFilter:w,format:I};void 0===e&&(e=512),void 0===n&&(n=512);const o=t.getPixelRatio(),l=new at(e*o,n*o,a),h=new at(e*o,n*o,a),c=new He({uniforms:{mapLeft:{value:l.texture},mapRight:{value:h.texture},colorMatrixLeft:{value:this.colorMatrixLeft},colorMatrixRight:{value:this.colorMatrixRight}},vertexShader:Ta.anaglyphVertexShader,fragmentShader:Ta.anaglyphFragmentShader}),u=new Tn(new ze(2,2),c);r.add(u),this.setLayers=function(t){s.cameraL.layers.mask=t,s.cameraR.layers.mask=t},this.setSize=function(e,n){t.setSize(e,n);const i=t.getPixelRatio();l.setSize(e*i,n*i),h.setSize(e*i,n*i)},this.setEyeSeparation=function(t){s.eyeSep=t},this.render=function(e,n){e.updateMatrixWorld(),null===n.parent&&n.updateMatrixWorld(),s.update(n),t.setRenderTarget(l),t.clear(),t.render(e,s.cameraL),t.setRenderTarget(h),t.clear(),t.render(e,s.cameraR),t.setRenderTarget(null),t.render(r,i)},this.dispose=function(){l&&l.dispose(),h&&h.dispose(),c&&c.dispose(),u&&u.geometry.dispose()}}function Vg(t,e,n){const i=t.container,r=i.clientWidth,s=i.clientHeight,a=new Vn(-r/2,r/2,s/2,-s/2,1,4e3),o=new On(t.cfg.themeValue("fieldOfView"),r/s,1,16e3),l=new $,h=this;n.add(o),n.add(a),g(o),g(a),this.activeCamera=o,this.mode=2;const c=new ln({side:1,colorWrite:!1});let u,d=.5,p=0;t.viewer.addEventListener("resized",(function(t){const e=t.width,n=t.height;a.zoom*=e/(a.right-a.left),a.left=-e/2,a.right=e/2,a.top=n/2,a.bottom=-n/2,a.updateProjectionMatrix(),o.aspect=e/n,o.updateProjectionMatrix(),null!==h.activeEffect&&h.activeEffect.setSize(e,n)}));const f=function(){e.render(n,h.activeCamera),e.getContext().flush(),p=e.info.render.frame},m=function(){const t=h.activeCamera;h.testCameraLayer(7)&&(t.layers.mask=129,n.overrideMaterial=c,e.render(n,t),n.overrideMaterial=null,t.layers.mask=u),e.render(n,t),e.getContext().flush(),p=e.info.render.frame};function g(t){t.zoom=1,t.layers.set(0),t.layers.enable(1),t.layers.enable(5)}this.maskedTerrain=!0,this.activeRenderer=m,this.activeEffect=null,this.resetCameras=function(){g(o),g(a)},this.setCameraLayer=function(t,e){e?(o.layers.enable(t),a.layers.enable(t)):(o.layers.disable(t),a.layers.disable(t)),u=this.activeCamera.layers.mask,null!==this.activeEffect&&this.activeEffect.setLayers(u)},this.testCameraLayer=function(t){return(u&1<<t)>0},this.setCamera=function(t,i){if(this.mode===t)return;let l,c=this.activeCamera;const u=c.position.clone().sub(i);null!==this.activeEffect&&this.activeEffect.dispose();let d=null;switch(t){case 3:if(d=new Gg(e,r,s),c.isPerspective)break;case 2:l=4*s*Math.tan(j*o.fov/2)/a.zoom/2,u.setLength(l),c=o;break;case 1:l=u.length(),a.zoom=2*s*Math.tan(j*o.fov/2)/l,c=a;break;default:return void console.warn("unknown camera mode",t)}null!==d?(d.setLayers(c.layers.mask),this.activeRenderer=function(){d.render(n,h.activeCamera)}):this.maskedTerrain?this.activeRenderer=m:this.activeRenderer=f,c.position.copy(u.add(i)),c.updateProjectionMatrix(),c.lookAt(i),this.activeCamera=c,this.activeEffect=d,this.mode=t},this.getLastFrame=function(){return p},this.getMouse=function(t,e){const n=i.getBoundingClientRect();return l.set((t-n.left)/i.clientWidth*2-1,-(e-n.top)/i.clientHeight*2+1),l},Object.defineProperties(this,{eyeSeparation:{get:function(){return d},set:function(t){d=t,null!==this.activeEffect&&this.activeEffect.setEyeSeparation(.064+.06*(t-.5))}},focalLength:{get:function(){return o.getFocalLength()},set:function(t){o.setFocalLength(t)}}})}function Wg(t,e){const n=t.cfg,i=new lt,r=new lt,s=new Ys(16777215),a=new Zs(16777215,.3),o=n.themeAngle("lighting.inclination"),l=n.themeAngle("lighting.azimuth")-Math.PI/2;i.setFromSpherical(new la(1,o,l)),i.applyAxisAngle(new lt(1,0,0),Math.PI/2),r.copy(i),s.position.copy(i),e.addStatic(s),e.addStatic(a),this.setRotation=function(t){r.copy(i),r.applyAxisAngle(Se.DefaultUp,t.z),s.position.copy(r),s.updateMatrix()},Object.defineProperty(this,"directionalLighting",{get:function(){return s.visible},set:function(t){s.visible=t,a.intensity=t?.3:1}})}const jg=new lt,Xg=new lt,qg=new lt,Yg=new Ut,Zg=new he;class Jg{constructor(t,e){const i=new lt,r=new lt,s=new ot;let a=1,o=0,l=!1,h=0,c=0,u=!1,d=null,p=0;function f(e,n){const i=t.cameraManager.activeCamera;jg.copy(e).sub(r).normalize();const a=jg.dot(Se.DefaultUp);Math.abs(a)>.99999&&void 0!==n&&e.add(n.multiplyScalar(.02*jg.z)),Yg.lookAt(e,r,Se.DefaultUp),s.setFromRotationMatrix(Yg).normalize(),h=Math.round(2*Math.acos(Math.abs(Y(s.dot(i.quaternion),-1,1)))*X)}function m(){t.autoRotate?t.update():d&&(d(),0==--o&&(d=null,function(){const e=t.cameraManager.activeCamera;t.target.copy(r),h>0&&e.position.copy(i);u=!1,h=0,p=0,t.update(),t.enabled=!0,t.end()}())),u&&(p=window.requestAnimationFrame(m))}function g(){const n=t.cameraManager.activeCamera,l=t.target,c=1-(o-1)/o;h||(n.position.lerp(i,c),n.zoom=n.zoom+(a-n.zoom)*c,n.isOrthographicCamera&&n.updateProjectionMatrix(),n.lookAt(l.lerp(r,c))),n.quaternion.slerp(s,c),e()}function v(t){o=Math.max(1,Math.round(90*Math.abs(t)/Math.PI)),c=t/o,u=!0,m()}function x(){t.rotateLeft(c)}function y(){t.rotateUp(c)}this.prepare=function(e,s){if(u)return this;const o=Xg,c=qg,p=t.cameraManager.activeCamera,m=p.position;if(l=!1,void 0===s){if(function(e){t.cameraManager.activeCamera.getWorldDirection(jg);const n=Math.abs(jg.x),i=Math.abs(jg.y),r=Math.abs(jg.z);n>i&&n>r?e.set(Math.sign(jg.x),0,0):i>r?e.set(0,Math.sign(jg.y),0):e.set(0,0,Math.sign(jg.z))}(o),0!==o.z){Zg.setFromQuaternion(p.quaternion);switch(Math.round(2*(Zg.z+Math.PI)/Math.PI)){case 0:case 4:c.set(0,1,0);break;case 1:c.set(-1,0,0);break;case 2:c.set(0,-1,0);break;case 3:c.set(1,0,0);break;default:c.set(0,-1,0)}}}else o.copy(s),c.set(0,-1,0);const v=function(t,e,i){const r=e.getSize(jg);let s,a,o,l=n,h=1;void 0===i||0!==i.z?(s=r.x,a=r.y,o=r.z):0!==i.x?(s=r.y,a=r.z,o=r.x):(s=r.x,a=r.z,o=r.y);if(t.isPerspectiveCamera){const e=2*Math.tan(.5*j*t.getEffectiveFOV()),n=a/e,i=1/t.aspect*s/e;l=1.1*Math.max(n,i)+o/2,0===l&&(l=100)}else{const e=(t.right-t.left)/s,n=(t.top-t.bottom)/a;h=1*Math.min(e,n)/1.1}return{zoom:h,elevation:l}}(p,e,o);e.getCenter(r),a=v.zoom,i.copy(r).add(o.negate().multiplyScalar(v.elevation));const x=m.distanceTo(i);return f(i,c),x<.1*i.z?l=0===h:h=0,d=g,this},this.preparePoint=function(e){if(u)return this;const n=t.cameraManager.activeCamera;return r.copy(e),i.copy(n.position),f(n.position),l=0===h,d=g,this},this.start=function(e){u||l||(o=e?h>0?Math.max(1,Math.round(h/2)):30:1,t.enabled=!1,u=!0,m())},this.cancel=function(){0!==p&&window.cancelAnimationFrame(p),u&&(o=1,u=!1,p=0,m(),t.enabled=!0,t.autoRotate=!1)},this.setAzimuthAngle=function(e){if(u||t.autoRotate)return this;let n=t.getAzimuthalAngle()-e;const i=Math.abs(n);i>Math.PI&&(n=2*Math.PI-i),d=x,v(n)},this.setPolarAngle=function(e){if(u)return this;d=y,v(t.getPolarAngle()-e)},this.setAutoRotate=function(e){if(e){if(u)return;t.autoRotate=!0,u=!0,d=!1,m()}else t.autoRotate&&(u=!1),t.autoRotate=!1,t.enabled=!0,p=0}}}function Qg(t,e){return void 0===t?"file set":t.split(".").shift()+"."+e}function Kg(t){return"data:text/json;charset=utf8,"+encodeURIComponent(JSON.stringify(t,null,"\t"))}function $g(t,e,n,i){void 0===n?(this.id=0,this.maxId=0,this.root=this,this.parent=null,this.pathCache=[],this.idCache=[]):(this.root=n,this.parent=i,this.id=null===e?++n.maxId:e,i.children.push(this)),this.boundingBox=new ut,this.name=t||"",this.children=[],this.type=0}$g.prototype.sorted=!1,$g.prototype.traverse=function(t){if(t(this),void 0===this.children)return;const e=this.children;for(let n=0;n<e.length;n++)e[n].traverse(t)},$g.prototype.traverseDepthFirst=function(t){const e=this.children;for(let n=0;n<e.length;n++)e[n].traverseDepthFirst(t);t(this)},$g.prototype.forEachChild=function(t){this.children.forEach((e=>t(e)))},$g.prototype.addById=function(t,e){const n=this.root,i=new $g(t,e,n,this);return n.maxId=Math.max(n.maxId,e),this.root.idCache[e]=i,i},$g.prototype.addPath=function(t){const e=t.split(".");let n=this.getByPathArray(e);if(0===e.length)return n;for(;e.length>0;){const t=new $g(e.shift(),null,this.root,n);this.root.pathCache[t.getPath()]=t,n=t}return n},$g.prototype.addLeaf=function(t,e,n,i){const r=this.root;if(n.root=r,n.id=++r.maxId,n.type=e,i&&(n.comments=i),1===t.length)return n.name=t[0],n.parent=this,this.children.push(n),n;const s=[];let a;for(;void 0===a&&t.length>1;)s.unshift(t.pop()),a=this.root.pathCache[t.join(".")];if(void 0!==a)return n.name=s.join("."),n.parent=a,a.children.push(n),n;if(t=t.concat(s),a=this.getByPathArray(t),0===t.length)return a;for(;t.length>1;){const e=new $g(t.shift(),null,this.root,e)}return n.name=t.shift(),n.parent=a,a.children.push(a),n},$g.prototype.addLeafById=function(t,e,n,i,r){const s=this.root;return i.type=n,i.name=t,i.id=e,i.parent=this,this.children.push(i),r&&(i.comments=r),s.maxId=Math.max(s.maxId,e),this.root.idCache[e]=i,i},$g.prototype.findById=function(t){if(this.id===t)return this;const e=this.root.idCache[t];if(void 0!==e)return e;for(let e=0,n=this.children.length;e<n;e++){const n=this.children[e].findById(t);if(n)return n}},$g.prototype.getByPath=function(t){if(!t)return;const e=t.split(".");let n,i=this.getByPathArray(e);if(0!==e.length){const e=t.split(".");if(e.length-2<0)return;const r=e.slice(0,e.length-2),s=e.slice(e.length-2,e.length).join(".");i=this.getByPathArray(n=r.concat(s))}return 0===e.length||0===n.length?i:void 0},$g.prototype.getByPathArray=function(t){let e=this.root,n=!0;for(;n&&t.length>0;){n=!1;for(let i=0,r=e.children.length;i<r;i++){const r=e.children[i];if(r.name===t[0]){e=r,t.shift(),n=!0;break}}}return e},$g.prototype.getPath=function(t){const e=[];let n=this;void 0===t&&(t=this.root);do{e.push(n.name),n=n.parent}while(n!==t&&null!==n);return e.reverse().join(".")},$g.prototype.getSubtreeIds=function(t){return this.traverse((function(e){t.add(e.id)})),t},$g.prototype.getIdByPath=function(t){const e=t.split("."),n=this.getByPathArray(e);return 0===e.length?n.id:void 0},$g.prototype.trim=function(t){const e=t.shift(),n=this.children;let i;if(void 0!==e){for(let t=0;t<n.length&&(i=n[t],i.name!==e);t++);this.children=[i],i.trim(t)}},$g.prototype.isStation=function(){return 0!==this.type};class tv extends lt{constructor(t,e,n){super(t,e,n),this.id=0,this.parent=null,this.name=null}correctedDistanceTo(t){const e=this.x-t.x,n=this.y-t.y,i=(this.z-t.z)*tv.scaleFactor;return Math.hypot(e,n,i)}}function ev(t){this.fileName=t,this.groups=[],this.section=null}var nv;if(tv.scaleFactor=1,tv.prototype.connections=0,tv.prototype.splays=0,tv.prototype.shortestPath=1/0,tv.prototype.children=[],Object.assign(tv.prototype,$g.prototype),ev.prototype.constructor=ev,ev.prototype.type="arraybuffer",ev.prototype.parse=function(t,e,n,i,r){t.metadata=n,this.section=i,this.progress=r,this.groups=[],this.cave=t,this.stationMap=new Map,this.dataStream=e;let s=0;l(),this.version=l();const a=h();l();const o=void 0===a[1]?null:a[1];return console.log("Survex .3d version ",this.version),this.pos=s,t.setCRS(o).then((()=>this.parse2()));function l(){return h()[0]}function h(){const t=new Uint8Array(e,0),n=[];let i,r=[];do{i=t[s++],10===i||0===i?(n.push(String.fromCharCode.apply(null,r).trim()),r=[]):r.push(i)}while(10!==i);return n}},ev.prototype.parse2=function(){const t=this.cave,e=this.pos;switch(this.version){case"Bv0.01":this.handleOld(this.dataStream,e,1);break;case"v3":case"v4":case"v5":case"v6":case"v7":case"v8":this.handleVx(this.dataStream,e,Number(this.version.charAt(1)),this.section);break;default:throw new Error("unsupported .3d version "+this.version)}return null!==this.section&&t.surveyTree.trim(this.section.split(".")),t.addStations(this.stationMap),t.addLineSegments(this.groups),t},ev.prototype.handleOld=function(t,e,n){const i=this.cave,r=i.surveyTree,s=i.projection,a=i.limits,o=this.groups,l=this.stationMap,h=[],c=new Map,u=new DataView(t,0),d=new Uint8Array(t,0),p=d.length;let f="";let m=[],g=new tv;function v(t){throw new Error("unhandled command: "+t.toString(16)+" @ "+e.toString(16))}for(let t=0;t<256;t++)h[t]=v;h[0]=x,h[-1]=x,h[1]=function(){return console.log("SKIP"),!1},h[2]=y,h[3]=y,h[4]=function(){const t=b();if(g=t,1===n&&2===u.getInt32(e,!0))return!0;m.length>1&&o.push(m);return m=[],m.push({coords:t}),!0},h[5]=function(){const t=b();return m.push({coords:t,type:1,survey:0}),g.connections++,t.connections++,g=t,!0},h[6]=function(){return console.log("LABEL_V2"),!1},h[7]=function(){return console.log("LABEL_V3"),!1};for(let t=64;t<128;t++)h[t]=_;for(let t=128;t<256;t++)h[t]=M;if(1===n)for(;e<p;){const t=u.getInt32(e,!0);if(e+=4,!h[t]())break}else for(alert("Unsupported version"+n);e<p&&h[d[e]](d[e++]););o.push(m);for(let t=0,e=o.length;t<e;t++){const e=o[t];for(let t=0,n=e.length;t<n;t++){const n=e[t],i=n.coords,r=c.get(i);void 0!==r&&(n.survey=r.parent.id)}}function x(){return!0}function y(){const t=[];let n=d[e++];for(;10!==n;)t.push(n),n=d[e++];92===t[0]&&t.shift(),f=String.fromCharCode.apply(null,t);const i=r.addLeaf(f.split("."),1,g);return c.set(g,i),!0}function _(){return console.log("LABEL_V4"),!1}function M(){return console.log("LINE_V2"),!1}function b(){const n=new DataView(t,e);let i=new tv(n.getInt32(0,!0)/100,n.getInt32(4,!0)/100,n.getInt32(8,!0)/100);e+=12;const r=i.x+","+i.y+","+i.z,o=l.get(r);if(void 0!==o)i=o;else{if(null!==s){const t=s.forward({x:i.x,y:i.y});i.x=t.x,i.y=t.y}a.expandByPoint(i),l.set(r,i)}return i}},ev.prototype.handleVx=function(t,e,n,i){const r=this.cave,s=r.surveyTree,a=r.messages,o=r.projection,l=r.limits,h=this.groups,c=[],d=this.stationMap,p=[],f=new Map,m=new Uint8Array(t,0),g=new DataView(t,0),v=m.length,x={x:0,y:0};let y,_,M=[],b="",w=[],S=0,E=!1,T=new tv,L=null,C=null,A=!1,R=null===i,P=!1;function D(t){throw new Error("unhandled command: "+t.toString(16)+" @ "+e.toString(16))}for(let t=0;t<256;t++)p[t]=D;if(8===n){p[0]=U,p[1]=U,p[2]=U,p[3]=U,p[4]=U,p[15]=H,p[16]=B,p[17]=function(){return e+=2,!0},p[18]=function(){return e+=3,!0},p[19]=function(){return e+=4,!0},p[31]=G,p[48]=W,p[49]=W,p[50]=j,p[51]=j;for(let t=64;t<128;t++)p[t]=k;for(let t=128;t<256;t++)p[t]=V;_=function(t){if(32&t)return!1;let n=m[e++],r=0,s=0;0!==n?(s=n>>4,r=15&n):(n=m[e++],255!==n?s=n:(s=g.getUint32(e,!0),e+=4),n=m[e++],255!==n?r=n:(r=g.getUint32(e,!0),e+=4));if(0===r&&0===s)return;s&&(b=b.slice(0,-s));r&&(b+=String.fromCharCode.apply(null,m.subarray(e,e+=r)));A=!0,null!==i&&(R=b.startsWith(i));return},e++}else{for(let t=1;t<15;t++)p[t]=F;p[15]=H;for(let t=16;t<32;t++)p[t]=O;p[0]=function(){b&&(b="");return!0},p[32]=function(){return e+=2,!0},p[33]=function(){return e+=3,!0},p[35]=function(){return e+=4,!0},p[36]=B,p[34]=G,p[48]=W,p[49]=W,p[50]=j,p[51]=j;for(let t=64;t<128;t++)p[t]=V;for(let t=128;t<192;t++)p[t]=k;_=function(){let t=0;switch(m[e]){case 254:t=g.getUint16(e,!0)+m[e],e+=2;break;case 255:t=g.getUint32(e,!0),e+=4;break;default:t=m[e++]}if(0===t)return;b+=String.fromCharCode.apply(null,m.subarray(e,e+=t)),A=!0,null!==i&&(R=b.startsWith(i));return}}n>=4&&n<=6&&(p[32]=function(){return e+=4,!0},p[33]=function(){return e+=8,!0});const I=Math.round(v/10);let N=0;for(;e<v&&(N++==I&&(N=0,this.progress(Math.round(25*e/v)+75)),p[m[e]](m[e++])););w.length>1&&c.push(w);const z=r.xGroups;return c.forEach((t=>{t.length>1&&z.push(t)})),d.forEach((t=>l.expandByPoint(t))),void h.push(M);function F(t){b=b.slice(0,-16),"."===b.charAt(b.length-1)&&(b=b.slice(0,-1));const e=b.split(".");return e.splice(-t),b=e.join("."),b&&(b+="."),A=!0,!0}function O(t){const e=t-15;return b=b.slice(0,-e),A=!0,!0}function U(){return!0}function B(){return!0}function k(t){const n=63&t;if(_(n),A&&""!==b&&(S=s.addPath(b).id,A=!1),R){E&&(M.push({coords:T}),E=!1);const t=q();if(t===T)return!0;0==(7&n)?(T.connections++,t.connections++,M.push({coords:t,type:1,survey:S})):4&n?(T.splays++,M.push({coords:t,type:2,survey:S}),t.splays=-1):1&n?M.push({coords:t,type:3,survey:S}):2&n&&M.push({coords:t,type:u,survey:S}),T=t}else E&&(Y(),E=!1),e+=12;return!0}function H(){return M.length>1&&h.push(M),M=[],!R&&E&&Y(),T=q(),E=!0,!0}function G(){return e+=20,!0}function V(t){const n=127&t;if(_(0),!(14&n)||32&n||!R)return e+=12,!0;const i=q(),r=b.split(".");return f.set(b,s.addLeaf(r,4&n?2:1,i)),!0}function W(n){const i=1&n;_(i);const r=new DataView(t,e);return e+=8,X(i,{l:r.getInt16(0,!0)/100,r:r.getInt16(2,!0)/100,u:r.getInt16(4,!0)/100,d:r.getInt16(6,!0)/100})}function j(n){const i=1&n;_(i);const r=new DataView(t,e);return e+=16,X(i,{l:r.getInt32(0,!0)/100,r:r.getInt32(0,!0)/100,u:r.getInt32(0,!0)/100,d:r.getInt32(0,!0)/100})}function X(t,e){if(null!==i&&!b.startsWith(i))return!0;const n=f.get(b);if(!n)return!0;const r=n.parent.id;w.push({start:C,end:n,lrud:e,survey:r,type:2}),n.type=4|n.type;let s=!1;return t?s=!0:1===n.connections&&w.length>1&&0===!T.connections?(y={station:n,text:"LRUD fault"},0===n.splays?(s=!0,a.push(y)):P=!0):P&&0!==n.connections&&(a.push(y),P=!1),s?(w.length>0&&c.push(w),C=null,w=[],P=!1):C=n,!0}function q(){const n=new DataView(t,e);L=String.fromCharCode.apply(null,m.subarray(e,e+12));let i=new tv(n.getInt32(0,!0)/100,n.getInt32(4,!0)/100,n.getInt32(8,!0)/100);e+=12;const r=d.get(L);if(void 0!==r)i=r;else{if(null!==o){x.x=i.x,x.y=i.y;const t=o.forward(x);i.x=t.x,i.y=t.y}d.set(L,i)}return i}function Y(){T.connections||d.delete(L)}},ev.prototype.getLineSegments=function(){const t=[],e=this.groups;for(let n=0,i=e.length;n<i;n++){const i=e[n];for(let e=0,n=i.length-1;e<n;e++){const n=i[e],r=i[e+1],s=n.coords,a=r.coords;t.push({from:s,to:a,type:r.type,survey:r.survey})}}return t},ev.prototype.getTerrainDimensions=function(){return{lines:0,samples:0}},ev.prototype.getTerrainBitmap=function(){return!1},void 0===(nv=self||window).TextDecoder){var iv=function(){};iv.prototype.decode=function(t){const e=t.length;let n="";for(let i=0;i<e;i++)n+="%"+t[i].toString(16);return decodeURIComponent(n)},nv.TextDecoder=iv}var rv=0;function sv(t){this.fileName=t}sv.prototype.constructor=sv,sv.prototype.type="arraybuffer",sv.prototype.parse=function(t,e,n,i,r){rv+=1e5,t.metadata=n,t.setCRS(null);const s=t.lineSegments,a=t.surveyTree,o=t.limits,l=t.projection,h=[],c={},d=null!==l,p=new TextDecoder("utf-8");let f=e;const m=f.byteLength,g=rv,v=[];let x,y=0;const _=new DataView(f,0);let M,b,w=0;const S={x:0,y:0};for(;y<m;)E();return f=null,t.addStations(v),t.addXsects(h),Promise.resolve(t);function E(){const t=T(),e=T(),n=T(),i=T();let s;switch(x=y+e,t){case 1:s=R;break;case 2:s=P;break;case 3:s=D;break;case 4:s=z;break;case 5:s=F;break;case 6:s=U;break;default:throw new Error("unknown chunk header. type : ",t)}for(let t=0;t<n;t++)s();r(Math.round(25*y/m)+75),y+=i}function T(){const t=_.getUint32(y,!0);return y+=4,t}function L(){const t=_.getFloat64(y,!0);return y+=8,t}function C(){return{position:T(),size:T()}}function A(t){const e=new Uint8Array(f,x+t.position,t.size-1);return p.decode(e)}function R(){const t=T(),e=C(),n=T(),r=C();if(M!==n&&(b=a.findById(void 0===M?0:n+g),M=n,void 0===b&&(b=a)),n!==t){const n=b.addById(A(e),t+g);if(null===n)throw new Error("error constructing survey tree for",A(r));null!==i&&n.getPath()===i&&(w=t)}}function P(){const t=T(),e=T(),n=C(),i=C(),r=T(),s=function(){const t=new tv(L(),L(),L());if(null!==l){S.x=t.x,S.y=t.y;const e=l.forward(S);t.x=e.x,t.y=e.y}return o.expandByPoint(t),t}();v[t]=s,M!==e&&(b=a.findById(e+g),M=e);const h=0===n.size?"["+t+"]":A(n),c=i.size>0?A(i):null;b.addLeafById(h,-(t+g),2&r?2:1,s,c)}function D(){const t=T(),e=T();let n,i,r,o;e>t?(n=t,i=e,r=I(),o=I()):(n=e,i=t,o=N(),r=N());const l=T(),c=T(),d=T();if(y+=8,0!==w&&d!==w)return;let p;if(0===l)p=1;else if(8&l||22&l)p=2;else if(1&l)p=3;else{if(!(2&l))return void console.log("unexpected flags"+l);p=u}const f=v[n],m=v[i],x=d+g;if(0!==c&&1===p){const t=a.findById(-i-g);t.type=4|t.type,h.push({m_from:n,m_to:i,start:f,end:m,fromLRUD:r,lrud:o,survey:x,type:c})}f.equals(m)||(1===p&&(f.connections++,m.connections++),s.push({from:f,to:m,type:p,survey:x}))}function I(){return{l:L(),r:L(),u:L(),d:L()}}function N(){return{r:L(),l:L(),u:L(),d:L()}}function z(){T();const e=T(),n=T(),i=C(),r=T(),s=C(),a={vertices:[],faces:[],survey:e+g};let o,l,h;if(0!==w&&e!==w)return;const c=new DataView(f,x+i.position);for(l=0;l<n;l++){const t=24*l;a.vertices.push(new lt(c.getFloat64(t,!0),c.getFloat64(t+8,!0),c.getFloat64(t+16,!0)))}const u=new DataView(f,x+s.position);for(l=0;l<r;l++){const t=12*l,e=[u.getUint32(t,!0),u.getUint32(t+4,!0),u.getUint32(t+8,!0)];if(e[0]!=e[1]&&e[0]!=e[2]&&e[1]!=e[2]){t:if(void 0!==o){for(h=0;h<3;h++)if(e[h]===o[(h+2)%3]&&e[(h+1)%3]===o[(h+3)%3]){e.reverse();break t}for(h=0;h<3;h++)if(e[h]===o[h]&&e[(h+1)%3]===o[(h+1)%3]){e.reverse();break t}for(h=0;h<3;h++)if(e[h]===o[(h+1)%3]&&e[(h+1)%3]===o[(h+2)%3]){e.reverse();break t}}a.faces.push(e),o=e}}t.scraps.push(a)}function F(){T();const e=T(),n=T(),i=C(),r=O();if(d)return;const s=f.slice(y,y+i.size),a=new Float64Array(s,0);c.dtm={data:a,samples:e,lines:n,calib:r},t.terrains.push(c),t.hasTerrain=!0}function O(){return{xOrigin:L(),yOrigin:L(),xx:L(),xy:L(),yx:L(),yy:L()}}function U(){T(),T();const t=C(),e=O();d||(c.bitmap={image:B(t),calib:e})}function B(t){const e=new Uint8Array(f,x+t.position,t.size),n=e[0],i=e[1];let r;if(255===n&&216===i)r="image/jpeg";else{if(137!==n||80!==i)return"";r="image/png"}const s=new Blob([e],{type:r});return URL.createObjectURL(s)}};const av=12*.0254;class ov{constructor(t){this.fileName=t,this.type="text"}parse(t,e,n){t.metadata=n,t.setCRS(null);const i=t.surveyTree,r=t.limits,s=t.projection,a=new Map,o=[],l=[],h=[],c=e.split(/[\n\r]+/),u=c.length;let d,p,f,m,g,v=[],x=[],y=0,_=-1,M="root";for(let t=0;t<u;t++){const e=c[t].split(/\s+/),n=e[0].charAt(0);switch(n){case"M":x.length>1&&h.push(x),x=[],_=-1;case"D":if(d=e[4].substring(1),v[2]=d,g=b(e),m=g.stationIndex,x.push({coords:g,type:1,survey:y}),0===g.connections){const t=void 0===e[13]?null:e.slice(13).join(" ");i.addLeaf(v,1,g,t)}if(g.connections++,"P"===e[5]){let t=+e[6],n=+e[7],i=+e[8],r=+e[9],s=0;if(t<0&&(t=0,s++),n<0&&(n=0,s++),i<0&&(i=0,s++),r<0&&(r=0,s++),4!==s){f={l:t*av,u:n*av,d:i*av,r:r*av};const e=-1!==_?l[_]:null;o.push({m_from:_,m_to:m,start:e,end:g,lrud:f,survey:y,type:2})}_=m}break;case"N":p=e[0].substring(1),v=[M,p],y=i.addPath(M+"."+p).id;break;case"Z":case"F":case"L":case"X":case"O":case"G":case"P":case"R":case"C":case"":break;case"S":M=c[t].substring(1);break;default:console.log("unknown command ",n)}}return x.length>1&&h.push(x),t.addStations(l),t.addLineSegments(h),t.addXsects(o),Promise.resolve(t);function b(t){const e=t[1]+":"+t[2]+":"+t[3],n=a.get(e);let i;if(void 0!==n)i=n;else{if(i=new tv(+t[2]*av,+t[1]*av,+t[3]*av),null!==s){const t=s.forward({x:i.x,y:i.y});i.x=t.x,i.y=t.y}i.stationIndex=l.length,l.push(i),a.set(e,i),r.expandByPoint(i)}return i}}}var lv=6378137,hv=.0066943799901413165,cv=484813681109536e-20,uv=Math.PI/2,dv=1e-10,pv=.017453292519943295,fv=57.29577951308232,mv=Math.PI/4,gv=2*Math.PI,vv=3.14159265359,xv={greenwich:0,lisbon:-9.131906111111,paris:2.337229166667,bogota:-74.080916666667,madrid:-3.687938888889,rome:12.452333333333,bern:7.439583333333,jakarta:106.807719444444,ferro:-17.666666666667,brussels:4.367975,stockholm:18.058277777778,athens:23.7163375,oslo:10.722916666667},yv={ft:{to_meter:.3048},"us-ft":{to_meter:1200/3937}},_v=/[\s_\-\/\(\)]/g;function Mv(t,e){if(t[e])return t[e];for(var n,i=Object.keys(t),r=e.toLowerCase().replace(_v,""),s=-1;++s<i.length;)if((n=i[s]).toLowerCase().replace(_v,"")===r)return t[n]}function bv(t){var e,n,i,r={},s=t.split("+").map((function(t){return t.trim()})).filter((function(t){return t})).reduce((function(t,e){var n=e.split("=");return n.push(!0),t[n[0].toLowerCase()]=n[1],t}),{}),a={proj:"projName",datum:"datumCode",rf:function(t){r.rf=parseFloat(t)},lat_0:function(t){r.lat0=t*pv},lat_1:function(t){r.lat1=t*pv},lat_2:function(t){r.lat2=t*pv},lat_ts:function(t){r.lat_ts=t*pv},lon_0:function(t){r.long0=t*pv},lon_1:function(t){r.long1=t*pv},lon_2:function(t){r.long2=t*pv},alpha:function(t){r.alpha=parseFloat(t)*pv},gamma:function(t){r.rectified_grid_angle=parseFloat(t)},lonc:function(t){r.longc=t*pv},x_0:function(t){r.x0=parseFloat(t)},y_0:function(t){r.y0=parseFloat(t)},k_0:function(t){r.k0=parseFloat(t)},k:function(t){r.k0=parseFloat(t)},a:function(t){r.a=parseFloat(t)},b:function(t){r.b=parseFloat(t)},r_a:function(){r.R_A=!0},zone:function(t){r.zone=parseInt(t,10)},south:function(){r.utmSouth=!0},towgs84:function(t){r.datum_params=t.split(",").map((function(t){return parseFloat(t)}))},to_meter:function(t){r.to_meter=parseFloat(t)},units:function(t){r.units=t;var e=Mv(yv,t);e&&(r.to_meter=e.to_meter)},from_greenwich:function(t){r.from_greenwich=t*pv},pm:function(t){var e=Mv(xv,t);r.from_greenwich=(e||parseFloat(t))*pv},nadgrids:function(t){"@null"===t?r.datumCode="none":r.nadgrids=t},axis:function(t){var e="ewnsud";3===t.length&&-1!==e.indexOf(t.substr(0,1))&&-1!==e.indexOf(t.substr(1,1))&&-1!==e.indexOf(t.substr(2,1))&&(r.axis=t)},approx:function(){r.approx=!0}};for(e in s)n=s[e],e in a?"function"==typeof(i=a[e])?i(n):r[i]=n:r[e]=n;return"string"==typeof r.datumCode&&"WGS84"!==r.datumCode&&(r.datumCode=r.datumCode.toLowerCase()),r}var wv=/\s/,Sv=/[A-Za-z]/,Ev=/[A-Za-z84]/,Tv=/[,\]]/,Lv=/[\d\.E\-\+]/;function Cv(t){if("string"!=typeof t)throw new Error("not a string");this.text=t.trim(),this.level=0,this.place=0,this.root=null,this.stack=[],this.currentObject=null,this.state=1}function Av(t,e,n){Array.isArray(e)&&(n.unshift(e),e=null);var i=e?{}:t,r=n.reduce((function(t,e){return Rv(e,t),t}),i);e&&(t[e]=r)}function Rv(t,e){if(Array.isArray(t)){var n=t.shift();if("PARAMETER"===n&&(n=t.shift()),1===t.length)return Array.isArray(t[0])?(e[n]={},void Rv(t[0],e[n])):void(e[n]=t[0]);if(t.length)if("TOWGS84"!==n){if("AXIS"===n)return n in e||(e[n]=[]),void e[n].push(t);var i;switch(Array.isArray(n)||(e[n]={}),n){case"UNIT":case"PRIMEM":case"VERT_DATUM":return e[n]={name:t[0].toLowerCase(),convert:t[1]},void(3===t.length&&Rv(t[2],e[n]));case"SPHEROID":case"ELLIPSOID":return e[n]={name:t[0],a:t[1],rf:t[2]},void(4===t.length&&Rv(t[3],e[n]));case"PROJECTEDCRS":case"PROJCRS":case"GEOGCS":case"GEOCCS":case"PROJCS":case"LOCAL_CS":case"GEODCRS":case"GEODETICCRS":case"GEODETICDATUM":case"EDATUM":case"ENGINEERINGDATUM":case"VERT_CS":case"VERTCRS":case"VERTICALCRS":case"COMPD_CS":case"COMPOUNDCRS":case"ENGINEERINGCRS":case"ENGCRS":case"FITTED_CS":case"LOCAL_DATUM":case"DATUM":return t[0]=["name",t[0]],void Av(e,n,t);default:for(i=-1;++i<t.length;)if(!Array.isArray(t[i]))return Rv(t,e[n]);return Av(e,n,t)}}else e[n]=t;else e[n]=!0}else e[t]=!0}Cv.prototype.readCharicter=function(){var t=this.text[this.place++];if(4!==this.state)for(;wv.test(t);){if(this.place>=this.text.length)return;t=this.text[this.place++]}switch(this.state){case 1:return this.neutral(t);case 2:return this.keyword(t);case 4:return this.quoted(t);case 5:return this.afterquote(t);case 3:return this.number(t);case-1:return}},Cv.prototype.afterquote=function(t){if('"'===t)return this.word+='"',void(this.state=4);if(Tv.test(t))return this.word=this.word.trim(),void this.afterItem(t);throw new Error("havn't handled \""+t+'" in afterquote yet, index '+this.place)},Cv.prototype.afterItem=function(t){return","===t?(null!==this.word&&this.currentObject.push(this.word),this.word=null,void(this.state=1)):"]"===t?(this.level--,null!==this.word&&(this.currentObject.push(this.word),this.word=null),this.state=1,this.currentObject=this.stack.pop(),void(this.currentObject||(this.state=-1))):void 0},Cv.prototype.number=function(t){if(!Lv.test(t)){if(Tv.test(t))return this.word=parseFloat(this.word),void this.afterItem(t);throw new Error("havn't handled \""+t+'" in number yet, index '+this.place)}this.word+=t},Cv.prototype.quoted=function(t){'"'!==t?this.word+=t:this.state=5},Cv.prototype.keyword=function(t){if(Ev.test(t))this.word+=t;else{if("["===t){var e=[];return e.push(this.word),this.level++,null===this.root?this.root=e:this.currentObject.push(e),this.stack.push(this.currentObject),this.currentObject=e,void(this.state=1)}if(!Tv.test(t))throw new Error("havn't handled \""+t+'" in keyword yet, index '+this.place);this.afterItem(t)}},Cv.prototype.neutral=function(t){if(Sv.test(t))return this.word=t,void(this.state=2);if('"'===t)return this.word="",void(this.state=4);if(Lv.test(t))return this.word=t,void(this.state=3);if(!Tv.test(t))throw new Error("havn't handled \""+t+'" in neutral yet, index '+this.place);this.afterItem(t)},Cv.prototype.output=function(){for(;this.place<this.text.length;)this.readCharicter();if(-1===this.state)return this.root;throw new Error('unable to parse string "'+this.text+'". State is '+this.state)};function Pv(t){return.017453292519943295*t}function Dv(t){var e=new Cv(t).output(),n=e.shift(),i=e.shift();e.unshift(["name",i]),e.unshift(["type",n]);var r={};return Rv(e,r),function(t){if("GEOGCS"===t.type?t.projName="longlat":"LOCAL_CS"===t.type?(t.projName="identity",t.local=!0):"object"==typeof t.PROJECTION?t.projName=Object.keys(t.PROJECTION)[0]:t.projName=t.PROJECTION,t.AXIS){for(var e="",n=0,i=t.AXIS.length;n<i;++n){var r=[t.AXIS[n][0].toLowerCase(),t.AXIS[n][1].toLowerCase()];-1!==r[0].indexOf("north")||("y"===r[0]||"lat"===r[0])&&"north"===r[1]?e+="n":-1!==r[0].indexOf("south")||("y"===r[0]||"lat"===r[0])&&"south"===r[1]?e+="s":-1!==r[0].indexOf("east")||("x"===r[0]||"lon"===r[0])&&"east"===r[1]?e+="e":-1===r[0].indexOf("west")&&("x"!==r[0]&&"lon"!==r[0]||"west"!==r[1])||(e+="w")}2===e.length&&(e+="u"),3===e.length&&(t.axis=e)}t.UNIT&&(t.units=t.UNIT.name.toLowerCase(),"metre"===t.units&&(t.units="meter"),t.UNIT.convert&&("GEOGCS"===t.type?t.DATUM&&t.DATUM.SPHEROID&&(t.to_meter=t.UNIT.convert*t.DATUM.SPHEROID.a):t.to_meter=t.UNIT.convert));var s=t.GEOGCS;function a(e){return e*(t.to_meter||1)}"GEOGCS"===t.type&&(s=t),s&&(s.DATUM?t.datumCode=s.DATUM.name.toLowerCase():t.datumCode=s.name.toLowerCase(),"d_"===t.datumCode.slice(0,2)&&(t.datumCode=t.datumCode.slice(2)),"new_zealand_geodetic_datum_1949"!==t.datumCode&&"new_zealand_1949"!==t.datumCode||(t.datumCode="nzgd49"),"wgs_1984"!==t.datumCode&&"world_geodetic_system_1984"!==t.datumCode||("Mercator_Auxiliary_Sphere"===t.PROJECTION&&(t.sphere=!0),t.datumCode="wgs84"),"_ferro"===t.datumCode.slice(-6)&&(t.datumCode=t.datumCode.slice(0,-6)),"_jakarta"===t.datumCode.slice(-8)&&(t.datumCode=t.datumCode.slice(0,-8)),~t.datumCode.indexOf("belge")&&(t.datumCode="rnb72"),s.DATUM&&s.DATUM.SPHEROID&&(t.ellps=s.DATUM.SPHEROID.name.replace("_19","").replace(/[Cc]larke\_18/,"clrk"),"international"===t.ellps.toLowerCase().slice(0,13)&&(t.ellps="intl"),t.a=s.DATUM.SPHEROID.a,t.rf=parseFloat(s.DATUM.SPHEROID.rf,10)),s.DATUM&&s.DATUM.TOWGS84&&(t.datum_params=s.DATUM.TOWGS84),~t.datumCode.indexOf("osgb_1936")&&(t.datumCode="osgb36"),~t.datumCode.indexOf("osni_1952")&&(t.datumCode="osni52"),(~t.datumCode.indexOf("tm65")||~t.datumCode.indexOf("geodetic_datum_of_1965"))&&(t.datumCode="ire65"),"ch1903+"===t.datumCode&&(t.datumCode="ch1903"),~t.datumCode.indexOf("israel")&&(t.datumCode="isr93")),t.b&&!isFinite(t.b)&&(t.b=t.a),[["standard_parallel_1","Standard_Parallel_1"],["standard_parallel_1","Latitude of 1st standard parallel"],["standard_parallel_2","Standard_Parallel_2"],["standard_parallel_2","Latitude of 2nd standard parallel"],["false_easting","False_Easting"],["false_easting","False easting"],["false-easting","Easting at false origin"],["false_northing","False_Northing"],["false_northing","False northing"],["false_northing","Northing at false origin"],["central_meridian","Central_Meridian"],["central_meridian","Longitude of natural origin"],["central_meridian","Longitude of false origin"],["latitude_of_origin","Latitude_Of_Origin"],["latitude_of_origin","Central_Parallel"],["latitude_of_origin","Latitude of natural origin"],["latitude_of_origin","Latitude of false origin"],["scale_factor","Scale_Factor"],["k0","scale_factor"],["latitude_of_center","Latitude_Of_Center"],["latitude_of_center","Latitude_of_center"],["lat0","latitude_of_center",Pv],["longitude_of_center","Longitude_Of_Center"],["longitude_of_center","Longitude_of_center"],["longc","longitude_of_center",Pv],["x0","false_easting",a],["y0","false_northing",a],["long0","central_meridian",Pv],["lat0","latitude_of_origin",Pv],["lat0","standard_parallel_1",Pv],["lat1","standard_parallel_1",Pv],["lat2","standard_parallel_2",Pv],["azimuth","Azimuth"],["alpha","azimuth",Pv],["srsCode","name"]].forEach((function(e){return function(t,e){var n=e[0],i=e[1];!(n in t)&&i in t&&(t[n]=t[i],3===e.length&&(t[n]=e[2](t[n])))}(t,e)})),t.long0||!t.longc||"Albers_Conic_Equal_Area"!==t.projName&&"Lambert_Azimuthal_Equal_Area"!==t.projName||(t.long0=t.longc),t.lat_ts||!t.lat1||"Stereographic_South_Pole"!==t.projName&&"Polar Stereographic (variant B)"!==t.projName||(t.lat0=Pv(t.lat1>0?90:-90),t.lat_ts=t.lat1)}(r),r}function Iv(t){var e=this;if(2===arguments.length){var n=arguments[1];"string"==typeof n?"+"===n.charAt(0)?Iv[t]=bv(arguments[1]):Iv[t]=Dv(arguments[1]):Iv[t]=n}else if(1===arguments.length){if(Array.isArray(t))return t.map((function(t){Array.isArray(t)?Iv.apply(e,t):Iv(t)}));if("string"==typeof t){if(t in Iv)return Iv[t]}else"EPSG"in t?Iv["EPSG:"+t.EPSG]=t:"ESRI"in t?Iv["ESRI:"+t.ESRI]=t:"IAU2000"in t?Iv["IAU2000:"+t.IAU2000]=t:console.log(t);return}}!function(t){t("EPSG:4326","+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"),t("EPSG:4269","+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"),t("EPSG:3857","+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"),t.WGS84=t["EPSG:4326"],t["EPSG:3785"]=t["EPSG:3857"],t.GOOGLE=t["EPSG:3857"],t["EPSG:900913"]=t["EPSG:3857"],t["EPSG:102113"]=t["EPSG:3857"]}(Iv);var Nv=["PROJECTEDCRS","PROJCRS","GEOGCS","GEOCCS","PROJCS","LOCAL_CS","GEODCRS","GEODETICCRS","GEODETICDATUM","ENGCRS","ENGINEERINGCRS"];var zv=["3857","900913","3785","102113"];function Fv(t){if(!function(t){return"string"==typeof t}(t))return t;if(function(t){return t in Iv}(t))return Iv[t];if(function(t){return Nv.some((function(e){return t.indexOf(e)>-1}))}(t)){var e=Dv(t);if(function(t){var e=Mv(t,"authority");if(e){var n=Mv(e,"epsg");return n&&zv.indexOf(n)>-1}}(e))return Iv["EPSG:3857"];var n=function(t){var e=Mv(t,"extension");if(e)return Mv(e,"proj4")}(e);return n?bv(n):e}return function(t){return"+"===t[0]}(t)?bv(t):void 0}function Ov(t,e){var n,i;if(t=t||{},!e)return t;for(i in e)void 0!==(n=e[i])&&(t[i]=n);return t}function Uv(t,e,n){var i=t*e;return n/Math.sqrt(1-i*i)}function Bv(t){return t<0?-1:1}function kv(t){return Math.abs(t)<=vv?t:t-Bv(t)*gv}function Hv(t,e,n){var i=t*n,r=.5*t;return i=Math.pow((1-i)/(1+i),r),Math.tan(.5*(uv-e))/i}function Gv(t,e){for(var n,i,r=.5*t,s=uv-2*Math.atan(e),a=0;a<=15;a++)if(n=t*Math.sin(s),s+=i=uv-2*Math.atan(e*Math.pow((1-n)/(1+n),r))-s,Math.abs(i)<=1e-10)return s;return-9999}function Vv(t){return t}var Wv=[{init:function(){var t=this.b/this.a;this.es=1-t*t,"x0"in this||(this.x0=0),"y0"in this||(this.y0=0),this.e=Math.sqrt(this.es),this.lat_ts?this.sphere?this.k0=Math.cos(this.lat_ts):this.k0=Uv(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)):this.k0||(this.k?this.k0=this.k:this.k0=1)},forward:function(t){var e,n,i=t.x,r=t.y;if(r*fv>90&&r*fv<-90&&i*fv>180&&i*fv<-180)return null;if(Math.abs(Math.abs(r)-uv)<=dv)return null;if(this.sphere)e=this.x0+this.a*this.k0*kv(i-this.long0),n=this.y0+this.a*this.k0*Math.log(Math.tan(mv+.5*r));else{var s=Math.sin(r),a=Hv(this.e,r,s);e=this.x0+this.a*this.k0*kv(i-this.long0),n=this.y0-this.a*this.k0*Math.log(a)}return t.x=e,t.y=n,t},inverse:function(t){var e,n,i=t.x-this.x0,r=t.y-this.y0;if(this.sphere)n=uv-2*Math.atan(Math.exp(-r/(this.a*this.k0)));else{var s=Math.exp(-r/(this.a*this.k0));if(-9999===(n=Gv(this.e,s)))return null}return e=kv(this.long0+i/(this.a*this.k0)),t.x=e,t.y=n,t},names:["Mercator","Popular Visualisation Pseudo Mercator","Mercator_1SP","Mercator_Auxiliary_Sphere","merc"]},{init:function(){},forward:Vv,inverse:Vv,names:["longlat","identity"]}],jv={},Xv=[];function qv(t,e){var n=Xv.length;return t.names?(Xv[n]=t,t.names.forEach((function(t){jv[t.toLowerCase()]=n})),this):(console.log(e),!0)}var Yv={start:function(){Wv.forEach(qv)},add:qv,get:function(t){if(!t)return!1;var e=t.toLowerCase();return void 0!==jv[e]&&Xv[jv[e]]?Xv[jv[e]]:void 0}},Zv={MERIT:{a:6378137,rf:298.257,ellipseName:"MERIT 1983"},SGS85:{a:6378136,rf:298.257,ellipseName:"Soviet Geodetic System 85"},GRS80:{a:6378137,rf:298.257222101,ellipseName:"GRS 1980(IUGG, 1980)"},IAU76:{a:6378140,rf:298.257,ellipseName:"IAU 1976"},airy:{a:6377563.396,b:6356256.91,ellipseName:"Airy 1830"},APL4:{a:6378137,rf:298.25,ellipseName:"Appl. Physics. 1965"},NWL9D:{a:6378145,rf:298.25,ellipseName:"Naval Weapons Lab., 1965"},mod_airy:{a:6377340.189,b:6356034.446,ellipseName:"Modified Airy"},andrae:{a:6377104.43,rf:300,ellipseName:"Andrae 1876 (Den., Iclnd.)"},aust_SA:{a:6378160,rf:298.25,ellipseName:"Australian Natl & S. Amer. 1969"},GRS67:{a:6378160,rf:298.247167427,ellipseName:"GRS 67(IUGG 1967)"},bessel:{a:6377397.155,rf:299.1528128,ellipseName:"Bessel 1841"},bess_nam:{a:6377483.865,rf:299.1528128,ellipseName:"Bessel 1841 (Namibia)"},clrk66:{a:6378206.4,b:6356583.8,ellipseName:"Clarke 1866"},clrk80:{a:6378249.145,rf:293.4663,ellipseName:"Clarke 1880 mod."},clrk58:{a:6378293.645208759,rf:294.2606763692654,ellipseName:"Clarke 1858"},CPM:{a:6375738.7,rf:334.29,ellipseName:"Comm. des Poids et Mesures 1799"},delmbr:{a:6376428,rf:311.5,ellipseName:"Delambre 1810 (Belgium)"},engelis:{a:6378136.05,rf:298.2566,ellipseName:"Engelis 1985"},evrst30:{a:6377276.345,rf:300.8017,ellipseName:"Everest 1830"},evrst48:{a:6377304.063,rf:300.8017,ellipseName:"Everest 1948"},evrst56:{a:6377301.243,rf:300.8017,ellipseName:"Everest 1956"},evrst69:{a:6377295.664,rf:300.8017,ellipseName:"Everest 1969"},evrstSS:{a:6377298.556,rf:300.8017,ellipseName:"Everest (Sabah & Sarawak)"},fschr60:{a:6378166,rf:298.3,ellipseName:"Fischer (Mercury Datum) 1960"},fschr60m:{a:6378155,rf:298.3,ellipseName:"Fischer 1960"},fschr68:{a:6378150,rf:298.3,ellipseName:"Fischer 1968"},helmert:{a:6378200,rf:298.3,ellipseName:"Helmert 1906"},hough:{a:6378270,rf:297,ellipseName:"Hough"},intl:{a:6378388,rf:297,ellipseName:"International 1909 (Hayford)"},kaula:{a:6378163,rf:298.24,ellipseName:"Kaula 1961"},lerch:{a:6378139,rf:298.257,ellipseName:"Lerch 1979"},mprts:{a:6397300,rf:191,ellipseName:"Maupertius 1738"},new_intl:{a:6378157.5,b:6356772.2,ellipseName:"New International 1967"},plessis:{a:6376523,rf:6355863,ellipseName:"Plessis 1817 (France)"},krass:{a:6378245,rf:298.3,ellipseName:"Krassovsky, 1942"},SEasia:{a:6378155,b:6356773.3205,ellipseName:"Southeast Asia"},walbeck:{a:6376896,b:6355834.8467,ellipseName:"Walbeck"},WGS60:{a:6378165,rf:298.3,ellipseName:"WGS 60"},WGS66:{a:6378145,rf:298.25,ellipseName:"WGS 66"},WGS7:{a:6378135,rf:298.26,ellipseName:"WGS 72"}},Jv=Zv.WGS84={a:6378137,rf:298.257223563,ellipseName:"WGS 84"};Zv.sphere={a:6370997,b:6370997,ellipseName:"Normal Sphere (r=6370997)"};var Qv={};Qv.wgs84={towgs84:"0,0,0",ellipse:"WGS84",datumName:"WGS84"},Qv.ch1903={towgs84:"674.374,15.056,405.346",ellipse:"bessel",datumName:"swiss"},Qv.ggrs87={towgs84:"-199.87,74.79,246.62",ellipse:"GRS80",datumName:"Greek_Geodetic_Reference_System_1987"},Qv.nad83={towgs84:"0,0,0",ellipse:"GRS80",datumName:"North_American_Datum_1983"},Qv.nad27={nadgrids:"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",ellipse:"clrk66",datumName:"North_American_Datum_1927"},Qv.potsdam={towgs84:"598.1,73.7,418.2,0.202,0.045,-2.455,6.7",ellipse:"bessel",datumName:"Potsdam Rauenberg 1950 DHDN"},Qv.carthage={towgs84:"-263.0,6.0,431.0",ellipse:"clark80",datumName:"Carthage 1934 Tunisia"},Qv.hermannskogel={towgs84:"577.326,90.129,463.919,5.137,1.474,5.297,2.4232",ellipse:"bessel",datumName:"Hermannskogel"},Qv.osni52={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"airy",datumName:"Irish National"},Qv.ire65={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"mod_airy",datumName:"Ireland 1965"},Qv.rassadiran={towgs84:"-133.63,-157.5,-158.62",ellipse:"intl",datumName:"Rassadiran"},Qv.nzgd49={towgs84:"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",ellipse:"intl",datumName:"New Zealand Geodetic Datum 1949"},Qv.osgb36={towgs84:"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",ellipse:"airy",datumName:"Airy 1830"},Qv.s_jtsk={towgs84:"589,76,480",ellipse:"bessel",datumName:"S-JTSK (Ferro)"},Qv.beduaram={towgs84:"-106,-87,188",ellipse:"clrk80",datumName:"Beduaram"},Qv.gunung_segara={towgs84:"-403,684,41",ellipse:"bessel",datumName:"Gunung Segara Jakarta"},Qv.rnb72={towgs84:"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",ellipse:"intl",datumName:"Reseau National Belge 1972"};var Kv={};function $v(t){if(0===t.length)return null;var e="@"===t[0];return e&&(t=t.slice(1)),"null"===t?{name:"null",mandatory:!e,grid:null,isNull:!0}:{name:t,mandatory:!e,grid:Kv[t]||null,isNull:!1}}function tx(t){return t/3600*Math.PI/180}function ex(t,e,n){return String.fromCharCode.apply(null,new Uint8Array(t.buffer.slice(e,n)))}function nx(t){return t.map((function(t){return[tx(t.longitudeShift),tx(t.latitudeShift)]}))}function ix(t,e,n){return{name:ex(t,e+8,e+16).trim(),parent:ex(t,e+24,e+24+8).trim(),lowerLatitude:t.getFloat64(e+72,n),upperLatitude:t.getFloat64(e+88,n),lowerLongitude:t.getFloat64(e+104,n),upperLongitude:t.getFloat64(e+120,n),latitudeInterval:t.getFloat64(e+136,n),longitudeInterval:t.getFloat64(e+152,n),gridNodeCount:t.getInt32(e+168,n)}}function rx(t,e,n,i){for(var r=e+176,s=[],a=0;a<n.gridNodeCount;a++){var o={latitudeShift:t.getFloat32(r+16*a,i),longitudeShift:t.getFloat32(r+16*a+4,i),latitudeAccuracy:t.getFloat32(r+16*a+8,i),longitudeAccuracy:t.getFloat32(r+16*a+12,i)};s.push(o)}return s}function sx(t,e){if(!(this instanceof sx))return new sx(t);e=e||function(t){if(t)throw t};var n=Fv(t);if("object"==typeof n){var i=sx.projections.get(n.projName);if(i){if(n.datumCode&&"none"!==n.datumCode){var r=Mv(Qv,n.datumCode);r&&(n.datum_params=n.datum_params||(r.towgs84?r.towgs84.split(","):null),n.ellps=r.ellipse,n.datumName=r.datumName?r.datumName:n.datumCode)}n.k0=n.k0||1,n.axis=n.axis||"enu",n.ellps=n.ellps||"wgs84",n.lat1=n.lat1||n.lat0;var s,a,o,l,h,c,u,d=function(t,e,n,i,r){if(!t){var s=Mv(Zv,i);s||(s=Jv),t=s.a,e=s.b,n=s.rf}return n&&!e&&(e=(1-1/n)*t),(0===n||Math.abs(t-e)<dv)&&(r=!0,e=t),{a:t,b:e,rf:n,sphere:r}}(n.a,n.b,n.rf,n.ellps,n.sphere),p=(s=d.a,a=d.b,d.rf,o=n.R_A,c=((l=s*s)-(h=a*a))/l,u=0,o?(l=(s*=1-c*(.16666666666666666+c*(.04722222222222222+.022156084656084655*c)))*s,c=0):u=Math.sqrt(c),{es:c,e:u,ep2:(l-h)/h}),f=function(t){return void 0===t?null:t.split(",").map($v)}(n.nadgrids),m=n.datum||function(t,e,n,i,r,s,a){var o={};return o.datum_type=void 0===t||"none"===t?5:4,e&&(o.datum_params=e.map(parseFloat),0===o.datum_params[0]&&0===o.datum_params[1]&&0===o.datum_params[2]||(o.datum_type=1),o.datum_params.length>3&&(0===o.datum_params[3]&&0===o.datum_params[4]&&0===o.datum_params[5]&&0===o.datum_params[6]||(o.datum_type=2,o.datum_params[3]*=cv,o.datum_params[4]*=cv,o.datum_params[5]*=cv,o.datum_params[6]=o.datum_params[6]/1e6+1))),a&&(o.datum_type=3,o.grids=a),o.a=n,o.b=i,o.es=r,o.ep2=s,o}(n.datumCode,n.datum_params,d.a,d.b,p.es,p.ep2,f);Ov(this,n),Ov(this,i),this.a=d.a,this.b=d.b,this.rf=d.rf,this.sphere=d.sphere,this.es=p.es,this.e=p.e,this.ep2=p.ep2,this.datum=m,this.init(),e(null,this)}else e(t)}else e(t)}function ax(t,e,n){var i,r,s,a,o=t.x,l=t.y,h=t.z?t.z:0;if(l<-uv&&l>-1.001*uv)l=-uv;else if(l>uv&&l<1.001*uv)l=uv;else{if(l<-uv)return{x:-1/0,y:-1/0,z:t.z};if(l>uv)return{x:1/0,y:1/0,z:t.z}}return o>Math.PI&&(o-=2*Math.PI),r=Math.sin(l),a=Math.cos(l),s=r*r,{x:((i=n/Math.sqrt(1-e*s))+h)*a*Math.cos(o),y:(i+h)*a*Math.sin(o),z:(i*(1-e)+h)*r}}function ox(t,e,n,i){var r,s,a,o,l,h,c,u,d,p,f,m,g,v,x,y=1e-12,_=t.x,M=t.y,b=t.z?t.z:0;if(r=Math.sqrt(_*_+M*M),s=Math.sqrt(_*_+M*M+b*b),r/n<y){if(v=0,s/n<y)return uv,x=-i,{x:t.x,y:t.y,z:t.z}}else v=Math.atan2(M,_);a=b/s,u=(o=r/s)*(1-e)*(l=1/Math.sqrt(1-e*(2-e)*o*o)),d=a*l,g=0;do{g++,h=e*(c=n/Math.sqrt(1-e*d*d))/(c+(x=r*u+b*d-c*(1-e*d*d))),m=(f=a*(l=1/Math.sqrt(1-h*(2-h)*o*o)))*u-(p=o*(1-h)*l)*d,u=p,d=f}while(m*m>1e-24&&g<30);return{x:v,y:Math.atan(f/Math.abs(p)),z:x}}function lx(t){return 1===t||2===t}function hx(t,e,n){if(function(t,e){return t.datum_type===e.datum_type&&!(t.a!==e.a||Math.abs(t.es-e.es)>5e-11)&&(1===t.datum_type?t.datum_params[0]===e.datum_params[0]&&t.datum_params[1]===e.datum_params[1]&&t.datum_params[2]===e.datum_params[2]:2!==t.datum_type||t.datum_params[0]===e.datum_params[0]&&t.datum_params[1]===e.datum_params[1]&&t.datum_params[2]===e.datum_params[2]&&t.datum_params[3]===e.datum_params[3]&&t.datum_params[4]===e.datum_params[4]&&t.datum_params[5]===e.datum_params[5]&&t.datum_params[6]===e.datum_params[6])}(t,e))return n;if(5===t.datum_type||5===e.datum_type)return n;var i=t.a,r=t.es;if(3===t.datum_type){if(0!==cx(t,!1,n))return;i=lv,r=hv}var s=e.a,a=e.b,o=e.es;if(3===e.datum_type&&(s=lv,a=6356752.314,o=hv),r===o&&i===s&&!lx(t.datum_type)&&!lx(e.datum_type))return n;if((n=ax(n,r,i),lx(t.datum_type)&&(n=function(t,e,n){if(1===e)return{x:t.x+n[0],y:t.y+n[1],z:t.z+n[2]};if(2===e){var i=n[0],r=n[1],s=n[2],a=n[3],o=n[4],l=n[5],h=n[6];return{x:h*(t.x-l*t.y+o*t.z)+i,y:h*(l*t.x+t.y-a*t.z)+r,z:h*(-o*t.x+a*t.y+t.z)+s}}}(n,t.datum_type,t.datum_params)),lx(e.datum_type)&&(n=function(t,e,n){if(1===e)return{x:t.x-n[0],y:t.y-n[1],z:t.z-n[2]};if(2===e){var i=n[0],r=n[1],s=n[2],a=n[3],o=n[4],l=n[5],h=n[6],c=(t.x-i)/h,u=(t.y-r)/h,d=(t.z-s)/h;return{x:c+l*u-o*d,y:-l*c+u+a*d,z:o*c-a*u+d}}}(n,e.datum_type,e.datum_params)),n=ox(n,o,s,a),3===e.datum_type)&&0!==cx(e,!0,n))return;return n}function cx(t,e,n){if(null===t.grids||0===t.grids.length)return console.log("Grid shift grids not found"),-1;for(var i={x:-n.x,y:n.y},r={x:Number.NaN,y:Number.NaN},s=[],a=0;a<t.grids.length;a++){var o=t.grids[a];if(s.push(o.name),o.isNull){r=i;break}if(null!==o.grid){var l=o.grid.subgrids[0],h=(Math.abs(l.del[1])+Math.abs(l.del[0]))/1e4,c=l.ll[0]-h,u=l.ll[1]-h,d=l.ll[0]+(l.lim[0]-1)*l.del[0]+h,p=l.ll[1]+(l.lim[1]-1)*l.del[1]+h;if(!(u>i.y||c>i.x||p<i.y||d<i.x||(r=ux(i,e,l),isNaN(r.x))))break}else if(o.mandatory)return console.log("Unable to find mandatory grid '"+o.name+"'"),-1}return isNaN(r.x)?(console.log("Failed to find a grid shift table for location '"+-i.x*fv+" "+i.y*fv+" tried: '"+s+"'"),-1):(n.x=-r.x,n.y=r.y,0)}function ux(t,e,n){var i={x:Number.NaN,y:Number.NaN};if(isNaN(t.x))return i;var r={x:t.x,y:t.y};r.x-=n.ll[0],r.y-=n.ll[1],r.x=kv(r.x-Math.PI)+Math.PI;var s=dx(r,n);if(e){if(isNaN(s.x))return i;s.x=r.x-s.x,s.y=r.y-s.y;var a,o,l=9;do{if(o=dx(s,n),isNaN(o.x)){console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");break}a={x:r.x-(o.x+s.x),y:r.y-(o.y+s.y)},s.x+=a.x,s.y+=a.y}while(l--&&Math.abs(a.x)>1e-12&&Math.abs(a.y)>1e-12);if(l<0)return console.log("Inverse grid shift iterator failed to converge."),i;i.x=kv(s.x+n.ll[0]),i.y=s.y+n.ll[1]}else isNaN(s.x)||(i.x=t.x+s.x,i.y=t.y+s.y);return i}function dx(t,e){var n,i={x:t.x/e.del[0],y:t.y/e.del[1]},r=Math.floor(i.x),s=Math.floor(i.y),a=i.x-1*r,o=i.y-1*s,l={x:Number.NaN,y:Number.NaN};if(r<0||r>=e.lim[0])return l;if(s<0||s>=e.lim[1])return l;n=s*e.lim[0]+r;var h=e.cvs[n][0],c=e.cvs[n][1];n++;var u=e.cvs[n][0],d=e.cvs[n][1];n+=e.lim[0];var p=e.cvs[n][0],f=e.cvs[n][1];n--;var m=e.cvs[n][0],g=e.cvs[n][1],v=a*o,x=a*(1-o),y=(1-a)*(1-o),_=(1-a)*o;return l.x=y*h+x*u+_*m+v*p,l.y=y*c+x*d+_*g+v*f,l}function px(t,e,n){var i,r,s,a=n.x,o=n.y,l=n.z||0,h={};for(s=0;s<3;s++)if(!e||2!==s||void 0!==n.z)switch(0===s?(i=a,r=-1!=="ew".indexOf(t.axis[s])?"x":"y"):1===s?(i=o,r=-1!=="ns".indexOf(t.axis[s])?"y":"x"):(i=l,r="z"),t.axis[s]){case"e":h[r]=i;break;case"w":h[r]=-i;break;case"n":h[r]=i;break;case"s":h[r]=-i;break;case"u":void 0!==n[r]&&(h.z=i);break;case"d":void 0!==n[r]&&(h.z=-i);break;default:return null}return h}function fx(t){var e={x:t[0],y:t[1]};return t.length>2&&(e.z=t[2]),t.length>3&&(e.m=t[3]),e}function mx(t){if("function"==typeof Number.isFinite){if(Number.isFinite(t))return;throw new TypeError("coordinates must be finite numbers")}if("number"!=typeof t||t!=t||!isFinite(t))throw new TypeError("coordinates must be finite numbers")}function gx(t,e,n,i){var r;if(Array.isArray(n)&&(n=fx(n)),function(t){mx(t.x),mx(t.y)}(n),t.datum&&e.datum&&function(t,e){return(1===t.datum.datum_type||2===t.datum.datum_type)&&"WGS84"!==e.datumCode||(1===e.datum.datum_type||2===e.datum.datum_type)&&"WGS84"!==t.datumCode}(t,e)&&(n=gx(t,r=new sx("WGS84"),n,i),t=r),i&&"enu"!==t.axis&&(n=px(t,!1,n)),"longlat"===t.projName)n={x:n.x*pv,y:n.y*pv,z:n.z||0};else if(t.to_meter&&(n={x:n.x*t.to_meter,y:n.y*t.to_meter,z:n.z||0}),!(n=t.inverse(n)))return;if(t.from_greenwich&&(n.x+=t.from_greenwich),n=hx(t.datum,e.datum,n))return e.from_greenwich&&(n={x:n.x-e.from_greenwich,y:n.y,z:n.z||0}),"longlat"===e.projName?n={x:n.x*fv,y:n.y*fv,z:n.z||0}:(n=e.forward(n),e.to_meter&&(n={x:n.x/e.to_meter,y:n.y/e.to_meter,z:n.z||0})),i&&"enu"!==e.axis?px(e,!0,n):n}sx.projections=Yv,sx.projections.start();var vx=sx("WGS84");function xx(t,e,n,i){var r,s,a;return Array.isArray(n)?(r=gx(t,e,n,i)||{x:NaN,y:NaN},n.length>2?void 0!==t.name&&"geocent"===t.name||void 0!==e.name&&"geocent"===e.name?"number"==typeof r.z?[r.x,r.y,r.z].concat(n.splice(3)):[r.x,r.y,n[2]].concat(n.splice(3)):[r.x,r.y].concat(n.splice(2)):[r.x,r.y]):(s=gx(t,e,n,i),2===(a=Object.keys(n)).length||a.forEach((function(i){if(void 0!==t.name&&"geocent"===t.name||void 0!==e.name&&"geocent"===e.name){if("x"===i||"y"===i||"z"===i)return}else if("x"===i||"y"===i)return;s[i]=n[i]})),s)}function yx(t){return t instanceof sx?t:t.oProj?t.oProj:sx(t)}function _x(t,e,n){t=yx(t);var i,r=!1;return void 0===e?(e=t,t=vx,r=!0):(void 0!==e.x||Array.isArray(e))&&(n=e,e=t,t=vx,r=!0),e=yx(e),n?xx(t,e,n):(i={forward:function(n,i){return xx(t,e,n,i)},inverse:function(n,i){return xx(e,t,n,i)}},r&&(i.oProj=e),i)}var Mx="AJSAJS",bx="AFAFAF",wx=65,Sx=73,Ex=79,Tx=86,Lx=90,Cx={forward:Ax,inverse:function(t){var e=Ix(Fx(t.toUpperCase()));if(e.lat&&e.lon)return[e.lon,e.lat,e.lon,e.lat];return[e.left,e.bottom,e.right,e.top]},toPoint:Rx};function Ax(t,e){return e=e||5,function(t,e){var n="00000"+t.easting,i="00000"+t.northing;return t.zoneNumber+t.zoneLetter+(p=t.easting,f=t.northing,m=t.zoneNumber,g=zx(m),v=Math.floor(p/1e5),x=Math.floor(f/1e5)%20,r=v,s=x,a=g,o=a-1,l=Mx.charCodeAt(o),h=bx.charCodeAt(o),c=l+r-1,u=h+s,d=!1,c>Lx&&(c=c-Lx+wx-1,d=!0),(c===Sx||l<Sx&&c>Sx||(c>Sx||l<Sx)&&d)&&c++,(c===Ex||l<Ex&&c>Ex||(c>Ex||l<Ex)&&d)&&++c===Sx&&c++,c>Lx&&(c=c-Lx+wx-1),u>Tx?(u=u-Tx+wx-1,d=!0):d=!1,(u===Sx||h<Sx&&u>Sx||(u>Sx||h<Sx)&&d)&&u++,(u===Ex||h<Ex&&u>Ex||(u>Ex||h<Ex)&&d)&&++u===Sx&&u++,u>Tx&&(u=u-Tx+wx-1),String.fromCharCode(c)+String.fromCharCode(u))+n.substr(n.length-5,e)+i.substr(i.length-5,e);var r,s,a,o,l,h,c,u,d;var p,f,m,g,v,x}(function(t){var e,n,i,r,s,a,o,l,h=t.lat,c=t.lon,u=6378137,d=.00669438,p=.9996,f=Px(h),m=Px(c);l=Math.floor((c+180)/6)+1,180===c&&(l=60);h>=56&&h<64&&c>=3&&c<12&&(l=32);h>=72&&h<84&&(c>=0&&c<9?l=31:c>=9&&c<21?l=33:c>=21&&c<33?l=35:c>=33&&c<42&&(l=37));o=Px(6*(l-1)-180+3),e=d/(1-d),n=u/Math.sqrt(1-d*Math.sin(f)*Math.sin(f)),i=Math.tan(f)*Math.tan(f),r=e*Math.cos(f)*Math.cos(f),s=Math.cos(f)*(m-o),a=u*((1-d/4-3*d*d/64-5*d*d*d/256)*f-(3*d/8+3*d*d/32+45*d*d*d/1024)*Math.sin(2*f)+(15*d*d/256+45*d*d*d/1024)*Math.sin(4*f)-35*d*d*d/3072*Math.sin(6*f));var g=p*n*(s+(1-i+r)*s*s*s/6+(5-18*i+i*i+72*r-58*e)*s*s*s*s*s/120)+5e5,v=p*(a+n*Math.tan(f)*(s*s/2+(5-i+9*r+4*r*r)*s*s*s*s/24+(61-58*i+i*i+600*r-330*e)*s*s*s*s*s*s/720));h<0&&(v+=1e7);return{northing:Math.round(v),easting:Math.round(g),zoneNumber:l,zoneLetter:Nx(h)}}({lat:t[1],lon:t[0]}),e)}function Rx(t){var e=Ix(Fx(t.toUpperCase()));return e.lat&&e.lon?[e.lon,e.lat]:[(e.left+e.right)/2,(e.top+e.bottom)/2]}function Px(t){return t*(Math.PI/180)}function Dx(t){return t/Math.PI*180}function Ix(t){var e=t.northing,n=t.easting,i=t.zoneLetter,r=t.zoneNumber;if(r<0||r>60)return null;var s,a,o,l,h,c,u,d,p,f=.9996,m=6378137,g=.00669438,v=(1-Math.sqrt(.99330562))/(1+Math.sqrt(.99330562)),x=n-5e5,y=e;i<"N"&&(y-=1e7),u=6*(r-1)-180+3,s=.006739496752268451,p=(d=y/f/6367449.145945056)+(3*v/2-27*v*v*v/32)*Math.sin(2*d)+(21*v*v/16-55*v*v*v*v/32)*Math.sin(4*d)+151*v*v*v/96*Math.sin(6*d),a=m/Math.sqrt(1-g*Math.sin(p)*Math.sin(p)),o=Math.tan(p)*Math.tan(p),l=s*Math.cos(p)*Math.cos(p),h=.99330562*m/Math.pow(1-g*Math.sin(p)*Math.sin(p),1.5),c=x/(a*f);var _=p-a*Math.tan(p)/h*(c*c/2-(5+3*o+10*l-4*l*l-9*s)*c*c*c*c/24+(61+90*o+298*l+45*o*o-1.6983531815716497-3*l*l)*c*c*c*c*c*c/720);_=Dx(_);var M,b=(c-(1+2*o+l)*c*c*c/6+(5-2*l+28*o-3*l*l+8*s+24*o*o)*c*c*c*c*c/120)/Math.cos(p);if(b=u+Dx(b),t.accuracy){var w=Ix({northing:t.northing+t.accuracy,easting:t.easting+t.accuracy,zoneLetter:t.zoneLetter,zoneNumber:t.zoneNumber});M={top:w.lat,right:w.lon,bottom:_,left:b}}else M={lat:_,lon:b};return M}function Nx(t){var e="Z";return 84>=t&&t>=72?e="X":72>t&&t>=64?e="W":64>t&&t>=56?e="V":56>t&&t>=48?e="U":48>t&&t>=40?e="T":40>t&&t>=32?e="S":32>t&&t>=24?e="R":24>t&&t>=16?e="Q":16>t&&t>=8?e="P":8>t&&t>=0?e="N":0>t&&t>=-8?e="M":-8>t&&t>=-16?e="L":-16>t&&t>=-24?e="K":-24>t&&t>=-32?e="J":-32>t&&t>=-40?e="H":-40>t&&t>=-48?e="G":-48>t&&t>=-56?e="F":-56>t&&t>=-64?e="E":-64>t&&t>=-72?e="D":-72>t&&t>=-80&&(e="C"),e}function zx(t){var e=t%6;return 0===e&&(e=6),e}function Fx(t){if(t&&0===t.length)throw"MGRSPoint coverting from nothing";for(var e,n=t.length,i=null,r="",s=0;!/[A-Z]/.test(e=t.charAt(s));){if(s>=2)throw"MGRSPoint bad conversion from: "+t;r+=e,s++}var a=parseInt(r,10);if(0===s||s+3>n)throw"MGRSPoint bad conversion from: "+t;var o=t.charAt(s++);if(o<="A"||"B"===o||"Y"===o||o>="Z"||"I"===o||"O"===o)throw"MGRSPoint zone letter "+o+" not handled: "+t;i=t.substring(s,s+=2);for(var l=zx(a),h=function(t,e){var n=Mx.charCodeAt(e-1),i=1e5,r=!1;for(;n!==t.charCodeAt(0);){if(++n===Sx&&n++,n===Ex&&n++,n>Lx){if(r)throw"Bad character: "+t;n=wx,r=!0}i+=1e5}return i}(i.charAt(0),l),c=function(t,e){if(t>"V")throw"MGRSPoint given invalid Northing "+t;var n=bx.charCodeAt(e-1),i=0,r=!1;for(;n!==t.charCodeAt(0);){if(++n===Sx&&n++,n===Ex&&n++,n>Tx){if(r)throw"Bad character: "+t;n=wx,r=!0}i+=1e5}return i}(i.charAt(1),l);c<Ox(o);)c+=2e6;var u=n-s;if(u%2!=0)throw"MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"+t;var d,p,f,m=u/2,g=0,v=0;return m>0&&(d=1e5/Math.pow(10,m),p=t.substring(s,s+m),g=parseFloat(p)*d,f=t.substring(s+m),v=parseFloat(f)*d),{easting:g+h,northing:v+c,zoneLetter:o,zoneNumber:a,accuracy:d}}function Ox(t){var e;switch(t){case"C":e=11e5;break;case"D":e=2e6;break;case"E":e=28e5;break;case"F":e=37e5;break;case"G":e=46e5;break;case"H":e=55e5;break;case"J":e=64e5;break;case"K":e=73e5;break;case"L":e=82e5;break;case"M":e=91e5;break;case"N":e=0;break;case"P":e=8e5;break;case"Q":e=17e5;break;case"R":e=26e5;break;case"S":e=35e5;break;case"T":e=44e5;break;case"U":e=53e5;break;case"V":e=62e5;break;case"W":e=7e6;break;case"X":e=79e5;break;default:e=-1}if(e>=0)return e;throw"Invalid zone letter: "+t}function Ux(t,e,n){if(!(this instanceof Ux))return new Ux(t,e,n);if(Array.isArray(t))this.x=t[0],this.y=t[1],this.z=t[2]||0;else if("object"==typeof t)this.x=t.x,this.y=t.y,this.z=t.z||0;else if("string"==typeof t&&void 0===e){var i=t.split(",");this.x=parseFloat(i[0],10),this.y=parseFloat(i[1],10),this.z=parseFloat(i[2],10)||0}else this.x=t,this.y=e,this.z=n||0;console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")}Ux.fromMGRS=function(t){return new Ux(Rx(t))},Ux.prototype.toMGRS=function(t){return Ax([this.x,this.y],t)};var Bx=.046875,kx=.01953125,Hx=.01068115234375;function Gx(t){var e=[];e[0]=1-t*(.25+t*(Bx+t*(kx+t*Hx))),e[1]=t*(.75-t*(Bx+t*(kx+t*Hx)));var n=t*t;return e[2]=n*(.46875-t*(.013020833333333334+.007120768229166667*t)),n*=t,e[3]=n*(.3645833333333333-.005696614583333333*t),e[4]=n*t*.3076171875,e}function Vx(t,e,n,i){return n*=e,e*=e,i[0]*t-n*(i[1]+e*(i[2]+e*(i[3]+e*i[4])))}function Wx(t,e,n){for(var i=1/(1-e),r=t,s=20;s;--s){var a=Math.sin(r),o=1-e*a*a;if(r-=o=(Vx(r,a,Math.cos(r),n)-t)*(o*Math.sqrt(o))*i,Math.abs(o)<dv)return r}return r}var jx={init:function(){this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.es&&(this.en=Gx(this.es),this.ml0=Vx(this.lat0,Math.sin(this.lat0),Math.cos(this.lat0),this.en))},forward:function(t){var e,n,i,r=t.x,s=t.y,a=kv(r-this.long0),o=Math.sin(s),l=Math.cos(s);if(this.es){var h=l*a,c=Math.pow(h,2),u=this.ep2*Math.pow(l,2),d=Math.pow(u,2),p=Math.abs(l)>dv?Math.tan(s):0,f=Math.pow(p,2),m=Math.pow(f,2);e=1-this.es*Math.pow(o,2),h/=Math.sqrt(e);var g=Vx(s,o,l,this.en);n=this.a*(this.k0*h*(1+c/6*(1-f+u+c/20*(5-18*f+m+14*u-58*f*u+c/42*(61+179*m-m*f-479*f)))))+this.x0,i=this.a*(this.k0*(g-this.ml0+o*a*h/2*(1+c/12*(5-f+9*u+4*d+c/30*(61+m-58*f+270*u-330*f*u+c/56*(1385+543*m-m*f-3111*f))))))+this.y0}else{var v=l*Math.sin(a);if(Math.abs(Math.abs(v)-1)<dv)return 93;if(n=.5*this.a*this.k0*Math.log((1+v)/(1-v))+this.x0,i=l*Math.cos(a)/Math.sqrt(1-Math.pow(v,2)),(v=Math.abs(i))>=1){if(v-1>dv)return 93;i=0}else i=Math.acos(i);s<0&&(i=-i),i=this.a*this.k0*(i-this.lat0)+this.y0}return t.x=n,t.y=i,t},inverse:function(t){var e,n,i,r,s=(t.x-this.x0)*(1/this.a),a=(t.y-this.y0)*(1/this.a);if(this.es)if(n=Wx(e=this.ml0+a/this.k0,this.es,this.en),Math.abs(n)<uv){var o=Math.sin(n),l=Math.cos(n),h=Math.abs(l)>dv?Math.tan(n):0,c=this.ep2*Math.pow(l,2),u=Math.pow(c,2),d=Math.pow(h,2),p=Math.pow(d,2);e=1-this.es*Math.pow(o,2);var f=s*Math.sqrt(e)/this.k0,m=Math.pow(f,2);i=n-(e*=h)*m/(1-this.es)*.5*(1-m/12*(5+3*d-9*c*d+c-4*u-m/30*(61+90*d-252*c*d+45*p+46*c-m/56*(1385+3633*d+4095*p+1574*p*d)))),r=kv(this.long0+f*(1-m/6*(1+2*d+c-m/20*(5+28*d+24*p+8*c*d+6*c-m/42*(61+662*d+1320*p+720*p*d))))/l)}else i=uv*Bv(a),r=0;else{var g=Math.exp(s/this.k0),v=.5*(g-1/g),x=this.lat0+a/this.k0,y=Math.cos(x);e=Math.sqrt((1-Math.pow(y,2))/(1+Math.pow(v,2))),i=Math.asin(e),a<0&&(i=-i),r=0===v&&0===y?0:kv(Math.atan2(v,y)+this.long0)}return t.x=r,t.y=i,t},names:["Fast_Transverse_Mercator","Fast Transverse Mercator"]};function Xx(t){var e=Math.exp(t);return e=(e-1/e)/2}function qx(t,e){t=Math.abs(t),e=Math.abs(e);var n=Math.max(t,e),i=Math.min(t,e)/(n||1);return n*Math.sqrt(1+Math.pow(i,2))}function Yx(t){var e=Math.abs(t);return e=function(t){var e=1+t,n=e-1;return 0===n?t:t*Math.log(e)/n}(e*(1+e/(qx(1,e)+1))),t<0?-e:e}function Zx(t,e){for(var n,i=2*Math.cos(2*e),r=t.length-1,s=t[r],a=0;--r>=0;)n=i*s-a+t[r],a=s,s=n;return e+n*Math.sin(2*e)}function Jx(t,e,n){for(var i,r,s=Math.sin(e),a=Math.cos(e),o=Xx(n),l=function(t){var e=Math.exp(t);return(e+1/e)/2}(n),h=2*a*l,c=-2*s*o,u=t.length-1,d=t[u],p=0,f=0,m=0;--u>=0;)i=f,r=p,d=h*(f=d)-i-c*(p=m)+t[u],m=c*f-r+h*p;return[(h=s*l)*d-(c=a*o)*m,h*m+c*d]}var Qx={init:function(){if(!this.approx&&(isNaN(this.es)||this.es<=0))throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');this.approx&&(jx.init.apply(this),this.forward=jx.forward,this.inverse=jx.inverse),this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.cgb=[],this.cbg=[],this.utg=[],this.gtu=[];var t=this.es/(1+Math.sqrt(1-this.es)),e=t/(2-t),n=e;this.cgb[0]=e*(2+e*(-2/3+e*(e*(116/45+e*(26/45+e*(-2854/675)))-2))),this.cbg[0]=e*(e*(2/3+e*(4/3+e*(-82/45+e*(32/45+e*(4642/4725)))))-2),n*=e,this.cgb[1]=n*(7/3+e*(e*(-227/45+e*(2704/315+e*(2323/945)))-1.6)),this.cbg[1]=n*(5/3+e*(-16/15+e*(-13/9+e*(904/315+e*(-1522/945))))),n*=e,this.cgb[2]=n*(56/15+e*(-136/35+e*(-1262/105+e*(73814/2835)))),this.cbg[2]=n*(-26/15+e*(34/21+e*(1.6+e*(-12686/2835)))),n*=e,this.cgb[3]=n*(4279/630+e*(-332/35+e*(-399572/14175))),this.cbg[3]=n*(1237/630+e*(e*(-24832/14175)-2.4)),n*=e,this.cgb[4]=n*(4174/315+e*(-144838/6237)),this.cbg[4]=n*(-734/315+e*(109598/31185)),n*=e,this.cgb[5]=n*(601676/22275),this.cbg[5]=n*(444337/155925),n=Math.pow(e,2),this.Qn=this.k0/(1+e)*(1+n*(1/4+n*(1/64+n/256))),this.utg[0]=e*(e*(2/3+e*(-37/96+e*(1/360+e*(81/512+e*(-96199/604800)))))-.5),this.gtu[0]=e*(.5+e*(-2/3+e*(5/16+e*(41/180+e*(-127/288+e*(7891/37800)))))),this.utg[1]=n*(-1/48+e*(-1/15+e*(437/1440+e*(-46/105+e*(1118711/3870720))))),this.gtu[1]=n*(13/48+e*(e*(557/1440+e*(281/630+e*(-1983433/1935360)))-.6)),n*=e,this.utg[2]=n*(-17/480+e*(37/840+e*(209/4480+e*(-5569/90720)))),this.gtu[2]=n*(61/240+e*(-103/140+e*(15061/26880+e*(167603/181440)))),n*=e,this.utg[3]=n*(-4397/161280+e*(11/504+e*(830251/7257600))),this.gtu[3]=n*(49561/161280+e*(-179/168+e*(6601661/7257600))),n*=e,this.utg[4]=n*(-4583/161280+e*(108847/3991680)),this.gtu[4]=n*(34729/80640+e*(-3418889/1995840)),n*=e,this.utg[5]=n*(-20648693/638668800),this.gtu[5]=.6650675310896665*n;var i=Zx(this.cbg,this.lat0);this.Zb=-this.Qn*(i+function(t,e){for(var n,i=2*Math.cos(e),r=t.length-1,s=t[r],a=0;--r>=0;)n=i*s-a+t[r],a=s,s=n;return Math.sin(e)*n}(this.gtu,2*i))},forward:function(t){var e=kv(t.x-this.long0),n=t.y;n=Zx(this.cbg,n);var i=Math.sin(n),r=Math.cos(n),s=Math.sin(e),a=Math.cos(e);n=Math.atan2(i,a*r),e=Math.atan2(s*r,qx(i,r*a)),e=Yx(Math.tan(e));var o,l,h=Jx(this.gtu,2*n,2*e);return n+=h[0],e+=h[1],Math.abs(e)<=2.623395162778?(o=this.a*(this.Qn*e)+this.x0,l=this.a*(this.Qn*n+this.Zb)+this.y0):(o=1/0,l=1/0),t.x=o,t.y=l,t},inverse:function(t){var e,n,i=(t.x-this.x0)*(1/this.a),r=(t.y-this.y0)*(1/this.a);if(r=(r-this.Zb)/this.Qn,i/=this.Qn,Math.abs(i)<=2.623395162778){var s=Jx(this.utg,2*r,2*i);r+=s[0],i+=s[1],i=Math.atan(Xx(i));var a=Math.sin(r),o=Math.cos(r),l=Math.sin(i),h=Math.cos(i);r=Math.atan2(a*h,qx(l,h*o)),e=kv((i=Math.atan2(l,h*o))+this.long0),n=Zx(this.cgb,r)}else e=1/0,n=1/0;return t.x=e,t.y=n,t},names:["Extended_Transverse_Mercator","Extended Transverse Mercator","etmerc","Transverse_Mercator","Transverse Mercator","tmerc"]};var Kx={init:function(){var t=function(t,e){if(void 0===t){if((t=Math.floor(30*(kv(e)+Math.PI)/Math.PI)+1)<0)return 0;if(t>60)return 60}return t}(this.zone,this.long0);if(void 0===t)throw new Error("unknown utm zone");this.lat0=0,this.long0=(6*Math.abs(t)-183)*pv,this.x0=5e5,this.y0=this.utmSouth?1e7:0,this.k0=.9996,Qx.init.apply(this),this.forward=Qx.forward,this.inverse=Qx.inverse},names:["Universal Transverse Mercator System","utm"],dependsOn:"etmerc"};function $x(t,e){return Math.pow((1-t)/(1+t),e)}var ty={init:function(){var t=Math.sin(this.lat0),e=Math.cos(this.lat0);e*=e,this.rc=Math.sqrt(1-this.es)/(1-this.es*t*t),this.C=Math.sqrt(1+this.es*e*e/(1-this.es)),this.phic0=Math.asin(t/this.C),this.ratexp=.5*this.C*this.e,this.K=Math.tan(.5*this.phic0+mv)/(Math.pow(Math.tan(.5*this.lat0+mv),this.C)*$x(this.e*t,this.ratexp))},forward:function(t){var e=t.x,n=t.y;return t.y=2*Math.atan(this.K*Math.pow(Math.tan(.5*n+mv),this.C)*$x(this.e*Math.sin(n),this.ratexp))-uv,t.x=this.C*e,t},inverse:function(t){for(var e=t.x/this.C,n=t.y,i=Math.pow(Math.tan(.5*n+mv)/this.K,1/this.C),r=20;r>0&&(n=2*Math.atan(i*$x(this.e*Math.sin(t.y),-.5*this.e))-uv,!(Math.abs(n-t.y)<1e-14));--r)t.y=n;return r?(t.x=e,t.y=n,t):null},names:["gauss"]};var ey={init:function(){ty.init.apply(this),this.rc&&(this.sinc0=Math.sin(this.phic0),this.cosc0=Math.cos(this.phic0),this.R2=2*this.rc,this.title||(this.title="Oblique Stereographic Alternative"))},forward:function(t){var e,n,i,r;return t.x=kv(t.x-this.long0),ty.forward.apply(this,[t]),e=Math.sin(t.y),n=Math.cos(t.y),i=Math.cos(t.x),r=this.k0*this.R2/(1+this.sinc0*e+this.cosc0*n*i),t.x=r*n*Math.sin(t.x),t.y=r*(this.cosc0*e-this.sinc0*n*i),t.x=this.a*t.x+this.x0,t.y=this.a*t.y+this.y0,t},inverse:function(t){var e,n,i,r,s;if(t.x=(t.x-this.x0)/this.a,t.y=(t.y-this.y0)/this.a,t.x/=this.k0,t.y/=this.k0,s=Math.sqrt(t.x*t.x+t.y*t.y)){var a=2*Math.atan2(s,this.R2);e=Math.sin(a),n=Math.cos(a),r=Math.asin(n*this.sinc0+t.y*e*this.cosc0/s),i=Math.atan2(t.x*e,s*this.cosc0*n-t.y*this.sinc0*e)}else r=this.phic0,i=0;return t.x=i,t.y=r,ty.inverse.apply(this,[t]),t.x=kv(t.x+this.long0),t},names:["Stereographic_North_Pole","Oblique_Stereographic","Polar_Stereographic","sterea","Oblique Stereographic Alternative","Double_Stereographic"]};var ny={init:function(){this.coslat0=Math.cos(this.lat0),this.sinlat0=Math.sin(this.lat0),this.sphere?1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=dv&&(this.k0=.5*(1+Bv(this.lat0)*Math.sin(this.lat_ts))):(Math.abs(this.coslat0)<=dv&&(this.lat0>0?this.con=1:this.con=-1),this.cons=Math.sqrt(Math.pow(1+this.e,1+this.e)*Math.pow(1-this.e,1-this.e)),1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=dv&&(this.k0=.5*this.cons*Uv(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts))/Hv(this.e,this.con*this.lat_ts,this.con*Math.sin(this.lat_ts))),this.ms1=Uv(this.e,this.sinlat0,this.coslat0),this.X0=2*Math.atan(this.ssfn_(this.lat0,this.sinlat0,this.e))-uv,this.cosX0=Math.cos(this.X0),this.sinX0=Math.sin(this.X0))},forward:function(t){var e,n,i,r,s,a,o=t.x,l=t.y,h=Math.sin(l),c=Math.cos(l),u=kv(o-this.long0);return Math.abs(Math.abs(o-this.long0)-Math.PI)<=dv&&Math.abs(l+this.lat0)<=dv?(t.x=NaN,t.y=NaN,t):this.sphere?(e=2*this.k0/(1+this.sinlat0*h+this.coslat0*c*Math.cos(u)),t.x=this.a*e*c*Math.sin(u)+this.x0,t.y=this.a*e*(this.coslat0*h-this.sinlat0*c*Math.cos(u))+this.y0,t):(n=2*Math.atan(this.ssfn_(l,h,this.e))-uv,r=Math.cos(n),i=Math.sin(n),Math.abs(this.coslat0)<=dv?(s=Hv(this.e,l*this.con,this.con*h),a=2*this.a*this.k0*s/this.cons,t.x=this.x0+a*Math.sin(o-this.long0),t.y=this.y0-this.con*a*Math.cos(o-this.long0),t):(Math.abs(this.sinlat0)<dv?(e=2*this.a*this.k0/(1+r*Math.cos(u)),t.y=e*i):(e=2*this.a*this.k0*this.ms1/(this.cosX0*(1+this.sinX0*i+this.cosX0*r*Math.cos(u))),t.y=e*(this.cosX0*i-this.sinX0*r*Math.cos(u))+this.y0),t.x=e*r*Math.sin(u)+this.x0,t))},inverse:function(t){var e,n,i,r,s;t.x-=this.x0,t.y-=this.y0;var a=Math.sqrt(t.x*t.x+t.y*t.y);if(this.sphere){var o=2*Math.atan(a/(2*this.a*this.k0));return e=this.long0,n=this.lat0,a<=dv?(t.x=e,t.y=n,t):(n=Math.asin(Math.cos(o)*this.sinlat0+t.y*Math.sin(o)*this.coslat0/a),e=Math.abs(this.coslat0)<dv?this.lat0>0?kv(this.long0+Math.atan2(t.x,-1*t.y)):kv(this.long0+Math.atan2(t.x,t.y)):kv(this.long0+Math.atan2(t.x*Math.sin(o),a*this.coslat0*Math.cos(o)-t.y*this.sinlat0*Math.sin(o))),t.x=e,t.y=n,t)}if(Math.abs(this.coslat0)<=dv){if(a<=dv)return n=this.lat0,e=this.long0,t.x=e,t.y=n,t;t.x*=this.con,t.y*=this.con,i=a*this.cons/(2*this.a*this.k0),n=this.con*Gv(this.e,i),e=this.con*kv(this.con*this.long0+Math.atan2(t.x,-1*t.y))}else r=2*Math.atan(a*this.cosX0/(2*this.a*this.k0*this.ms1)),e=this.long0,a<=dv?s=this.X0:(s=Math.asin(Math.cos(r)*this.sinX0+t.y*Math.sin(r)*this.cosX0/a),e=kv(this.long0+Math.atan2(t.x*Math.sin(r),a*this.cosX0*Math.cos(r)-t.y*this.sinX0*Math.sin(r)))),n=-1*Gv(this.e,Math.tan(.5*(uv+s)));return t.x=e,t.y=n,t},names:["stere","Stereographic_South_Pole","Polar Stereographic (variant B)"],ssfn_:function(t,e,n){return e*=n,Math.tan(.5*(uv+t))*Math.pow((1-e)/(1+e),.5*n)}};var iy={init:function(){var t=this.lat0;this.lambda0=this.long0;var e=Math.sin(t),n=this.a,i=1/this.rf,r=2*i-Math.pow(i,2),s=this.e=Math.sqrt(r);this.R=this.k0*n*Math.sqrt(1-r)/(1-r*Math.pow(e,2)),this.alpha=Math.sqrt(1+r/(1-r)*Math.pow(Math.cos(t),4)),this.b0=Math.asin(e/this.alpha);var a=Math.log(Math.tan(Math.PI/4+this.b0/2)),o=Math.log(Math.tan(Math.PI/4+t/2)),l=Math.log((1+s*e)/(1-s*e));this.K=a-this.alpha*o+this.alpha*s/2*l},forward:function(t){var e=Math.log(Math.tan(Math.PI/4-t.y/2)),n=this.e/2*Math.log((1+this.e*Math.sin(t.y))/(1-this.e*Math.sin(t.y))),i=-this.alpha*(e+n)+this.K,r=2*(Math.atan(Math.exp(i))-Math.PI/4),s=this.alpha*(t.x-this.lambda0),a=Math.atan(Math.sin(s)/(Math.sin(this.b0)*Math.tan(r)+Math.cos(this.b0)*Math.cos(s))),o=Math.asin(Math.cos(this.b0)*Math.sin(r)-Math.sin(this.b0)*Math.cos(r)*Math.cos(s));return t.y=this.R/2*Math.log((1+Math.sin(o))/(1-Math.sin(o)))+this.y0,t.x=this.R*a+this.x0,t},inverse:function(t){for(var e=t.x-this.x0,n=t.y-this.y0,i=e/this.R,r=2*(Math.atan(Math.exp(n/this.R))-Math.PI/4),s=Math.asin(Math.cos(this.b0)*Math.sin(r)+Math.sin(this.b0)*Math.cos(r)*Math.cos(i)),a=Math.atan(Math.sin(i)/(Math.cos(this.b0)*Math.cos(i)-Math.sin(this.b0)*Math.tan(r))),o=this.lambda0+a/this.alpha,l=0,h=s,c=-1e3,u=0;Math.abs(h-c)>1e-7;){if(++u>20)return;l=1/this.alpha*(Math.log(Math.tan(Math.PI/4+s/2))-this.K)+this.e*Math.log(Math.tan(Math.PI/4+Math.asin(this.e*Math.sin(h))/2)),c=h,h=2*Math.atan(Math.exp(l))-Math.PI/2}return t.x=o,t.y=h,t},names:["somerc"]},ry=1e-7;var sy={init:function(){var t,e,n,i,r,s,a,o,l,h,c,u,d,p=0,f=0,m=0,g=0,v=0,x=0,y=0;this.no_off=(d="object"==typeof(u=this).PROJECTION?Object.keys(u.PROJECTION)[0]:u.PROJECTION,"no_uoff"in u||"no_off"in u||-1!==["Hotine_Oblique_Mercator","Hotine_Oblique_Mercator_Azimuth_Natural_Origin"].indexOf(d)),this.no_rot="no_rot"in this;var _=!1;"alpha"in this&&(_=!0);var M=!1;if("rectified_grid_angle"in this&&(M=!0),_&&(y=this.alpha),M&&(p=this.rectified_grid_angle*pv),_||M)f=this.longc;else if(m=this.long1,v=this.lat1,g=this.long2,x=this.lat2,Math.abs(v-x)<=ry||(t=Math.abs(v))<=ry||Math.abs(t-uv)<=ry||Math.abs(Math.abs(this.lat0)-uv)<=ry||Math.abs(Math.abs(x)-uv)<=ry)throw new Error;var b=1-this.es;e=Math.sqrt(b),Math.abs(this.lat0)>dv?(o=Math.sin(this.lat0),n=Math.cos(this.lat0),t=1-this.es*o*o,this.B=n*n,this.B=Math.sqrt(1+this.es*this.B*this.B/b),this.A=this.B*this.k0*e/t,(r=(i=this.B*e/(n*Math.sqrt(t)))*i-1)<=0?r=0:(r=Math.sqrt(r),this.lat0<0&&(r=-r)),this.E=r+=i,this.E*=Math.pow(Hv(this.e,this.lat0,o),this.B)):(this.B=1/e,this.A=this.k0,this.E=i=r=1),_||M?(_?(c=Math.asin(Math.sin(y)/i),M||(p=y)):(c=p,y=Math.asin(i*Math.sin(c))),this.lam0=f-Math.asin(.5*(r-1/r)*Math.tan(c))/this.B):(s=Math.pow(Hv(this.e,v,Math.sin(v)),this.B),a=Math.pow(Hv(this.e,x,Math.sin(x)),this.B),r=this.E/s,l=(a-s)/(a+s),h=((h=this.E*this.E)-a*s)/(h+a*s),(t=m-g)<-Math.pi?g-=gv:t>Math.pi&&(g+=gv),this.lam0=kv(.5*(m+g)-Math.atan(h*Math.tan(.5*this.B*(m-g))/l)/this.B),c=Math.atan(2*Math.sin(this.B*kv(m-this.lam0))/(r-1/r)),p=y=Math.asin(i*Math.sin(c))),this.singam=Math.sin(c),this.cosgam=Math.cos(c),this.sinrot=Math.sin(p),this.cosrot=Math.cos(p),this.rB=1/this.B,this.ArB=this.A*this.rB,this.BrA=1/this.ArB,this.A,this.B,this.no_off?this.u_0=0:(this.u_0=Math.abs(this.ArB*Math.atan(Math.sqrt(i*i-1)/Math.cos(y))),this.lat0<0&&(this.u_0=-this.u_0)),r=.5*c,this.v_pole_n=this.ArB*Math.log(Math.tan(mv-r)),this.v_pole_s=this.ArB*Math.log(Math.tan(mv+r))},forward:function(t){var e,n,i,r,s,a,o,l,h={};if(t.x=t.x-this.lam0,Math.abs(Math.abs(t.y)-uv)>dv){if(e=.5*((s=this.E/Math.pow(Hv(this.e,t.y,Math.sin(t.y)),this.B))-(a=1/s)),n=.5*(s+a),r=Math.sin(this.B*t.x),i=(e*this.singam-r*this.cosgam)/n,Math.abs(Math.abs(i)-1)<dv)throw new Error;l=.5*this.ArB*Math.log((1-i)/(1+i)),a=Math.cos(this.B*t.x),o=Math.abs(a)<ry?this.A*t.x:this.ArB*Math.atan2(e*this.cosgam+r*this.singam,a)}else l=t.y>0?this.v_pole_n:this.v_pole_s,o=this.ArB*t.y;return this.no_rot?(h.x=o,h.y=l):(o-=this.u_0,h.x=l*this.cosrot+o*this.sinrot,h.y=o*this.cosrot-l*this.sinrot),h.x=this.a*h.x+this.x0,h.y=this.a*h.y+this.y0,h},inverse:function(t){var e,n,i,r,s,a,o,l={};if(t.x=(t.x-this.x0)*(1/this.a),t.y=(t.y-this.y0)*(1/this.a),this.no_rot?(n=t.y,e=t.x):(n=t.x*this.cosrot-t.y*this.sinrot,e=t.y*this.cosrot+t.x*this.sinrot+this.u_0),r=.5*((i=Math.exp(-this.BrA*n))-1/i),s=.5*(i+1/i),o=((a=Math.sin(this.BrA*e))*this.cosgam+r*this.singam)/s,Math.abs(Math.abs(o)-1)<dv)l.x=0,l.y=o<0?-uv:uv;else{if(l.y=this.E/Math.sqrt((1+o)/(1-o)),l.y=Gv(this.e,Math.pow(l.y,1/this.B)),l.y===1/0)throw new Error;l.x=-this.rB*Math.atan2(r*this.cosgam-a*this.singam,Math.cos(this.BrA*e))}return l.x+=this.lam0,l},names:["Hotine_Oblique_Mercator","Hotine Oblique Mercator","Hotine_Oblique_Mercator_Azimuth_Natural_Origin","Hotine_Oblique_Mercator_Two_Point_Natural_Origin","Hotine_Oblique_Mercator_Azimuth_Center","Oblique_Mercator","omerc"]};var ay={init:function(){if(this.lat2||(this.lat2=this.lat1),this.k0||(this.k0=1),this.x0=this.x0||0,this.y0=this.y0||0,!(Math.abs(this.lat1+this.lat2)<dv)){var t=this.b/this.a;this.e=Math.sqrt(1-t*t);var e=Math.sin(this.lat1),n=Math.cos(this.lat1),i=Uv(this.e,e,n),r=Hv(this.e,this.lat1,e),s=Math.sin(this.lat2),a=Math.cos(this.lat2),o=Uv(this.e,s,a),l=Hv(this.e,this.lat2,s),h=Hv(this.e,this.lat0,Math.sin(this.lat0));Math.abs(this.lat1-this.lat2)>dv?this.ns=Math.log(i/o)/Math.log(r/l):this.ns=e,isNaN(this.ns)&&(this.ns=e),this.f0=i/(this.ns*Math.pow(r,this.ns)),this.rh=this.a*this.f0*Math.pow(h,this.ns),this.title||(this.title="Lambert Conformal Conic")}},forward:function(t){var e=t.x,n=t.y;Math.abs(2*Math.abs(n)-Math.PI)<=dv&&(n=Bv(n)*(uv-2e-10));var i,r,s=Math.abs(Math.abs(n)-uv);if(s>dv)i=Hv(this.e,n,Math.sin(n)),r=this.a*this.f0*Math.pow(i,this.ns);else{if((s=n*this.ns)<=0)return null;r=0}var a=this.ns*kv(e-this.long0);return t.x=this.k0*(r*Math.sin(a))+this.x0,t.y=this.k0*(this.rh-r*Math.cos(a))+this.y0,t},inverse:function(t){var e,n,i,r,s,a=(t.x-this.x0)/this.k0,o=this.rh-(t.y-this.y0)/this.k0;this.ns>0?(e=Math.sqrt(a*a+o*o),n=1):(e=-Math.sqrt(a*a+o*o),n=-1);var l=0;if(0!==e&&(l=Math.atan2(n*a,n*o)),0!==e||this.ns>0){if(n=1/this.ns,i=Math.pow(e/(this.a*this.f0),n),-9999===(r=Gv(this.e,i)))return null}else r=-uv;return s=kv(l/this.ns+this.long0),t.x=s,t.y=r,t},names:["Lambert Tangential Conformal Conic Projection","Lambert_Conformal_Conic","Lambert_Conformal_Conic_1SP","Lambert_Conformal_Conic_2SP","lcc"]};var oy={init:function(){this.a=6377397.155,this.es=.006674372230614,this.e=Math.sqrt(this.es),this.lat0||(this.lat0=.863937979737193),this.long0||(this.long0=.4334234309119251),this.k0||(this.k0=.9999),this.s45=.785398163397448,this.s90=2*this.s45,this.fi0=this.lat0,this.e2=this.es,this.e=Math.sqrt(this.e2),this.alfa=Math.sqrt(1+this.e2*Math.pow(Math.cos(this.fi0),4)/(1-this.e2)),this.uq=1.04216856380474,this.u0=Math.asin(Math.sin(this.fi0)/this.alfa),this.g=Math.pow((1+this.e*Math.sin(this.fi0))/(1-this.e*Math.sin(this.fi0)),this.alfa*this.e/2),this.k=Math.tan(this.u0/2+this.s45)/Math.pow(Math.tan(this.fi0/2+this.s45),this.alfa)*this.g,this.k1=this.k0,this.n0=this.a*Math.sqrt(1-this.e2)/(1-this.e2*Math.pow(Math.sin(this.fi0),2)),this.s0=1.37008346281555,this.n=Math.sin(this.s0),this.ro0=this.k1*this.n0/Math.tan(this.s0),this.ad=this.s90-this.uq},forward:function(t){var e,n,i,r,s,a,o,l=t.x,h=t.y,c=kv(l-this.long0);return e=Math.pow((1+this.e*Math.sin(h))/(1-this.e*Math.sin(h)),this.alfa*this.e/2),n=2*(Math.atan(this.k*Math.pow(Math.tan(h/2+this.s45),this.alfa)/e)-this.s45),i=-c*this.alfa,r=Math.asin(Math.cos(this.ad)*Math.sin(n)+Math.sin(this.ad)*Math.cos(n)*Math.cos(i)),s=Math.asin(Math.cos(n)*Math.sin(i)/Math.cos(r)),a=this.n*s,o=this.ro0*Math.pow(Math.tan(this.s0/2+this.s45),this.n)/Math.pow(Math.tan(r/2+this.s45),this.n),t.y=o*Math.cos(a)/1,t.x=o*Math.sin(a)/1,this.czech||(t.y*=-1,t.x*=-1),t},inverse:function(t){var e,n,i,r,s,a,o,l=t.x;t.x=t.y,t.y=l,this.czech||(t.y*=-1,t.x*=-1),s=Math.sqrt(t.x*t.x+t.y*t.y),r=Math.atan2(t.y,t.x)/Math.sin(this.s0),i=2*(Math.atan(Math.pow(this.ro0/s,1/this.n)*Math.tan(this.s0/2+this.s45))-this.s45),e=Math.asin(Math.cos(this.ad)*Math.sin(i)-Math.sin(this.ad)*Math.cos(i)*Math.cos(r)),n=Math.asin(Math.cos(i)*Math.sin(r)/Math.cos(e)),t.x=this.long0-n/this.alfa,a=e,o=0;var h=0;do{t.y=2*(Math.atan(Math.pow(this.k,-1/this.alfa)*Math.pow(Math.tan(e/2+this.s45),1/this.alfa)*Math.pow((1+this.e*Math.sin(a))/(1-this.e*Math.sin(a)),this.e/2))-this.s45),Math.abs(a-t.y)<1e-10&&(o=1),a=t.y,h+=1}while(0===o&&h<15);return h>=15?null:t},names:["Krovak","krovak"]};function ly(t,e,n,i,r){return t*r-e*Math.sin(2*r)+n*Math.sin(4*r)-i*Math.sin(6*r)}function hy(t){return 1-.25*t*(1+t/16*(3+1.25*t))}function cy(t){return.375*t*(1+.25*t*(1+.46875*t))}function uy(t){return.05859375*t*t*(1+.75*t)}function dy(t){return t*t*t*(35/3072)}function py(t,e,n){var i=e*n;return t/Math.sqrt(1-i*i)}function fy(t){return Math.abs(t)<uv?t:t-Bv(t)*Math.PI}function my(t,e,n,i,r){var s,a;s=t/e;for(var o=0;o<15;o++)if(s+=a=(t-(e*s-n*Math.sin(2*s)+i*Math.sin(4*s)-r*Math.sin(6*s)))/(e-2*n*Math.cos(2*s)+4*i*Math.cos(4*s)-6*r*Math.cos(6*s)),Math.abs(a)<=1e-10)return s;return NaN}var gy={init:function(){this.sphere||(this.e0=hy(this.es),this.e1=cy(this.es),this.e2=uy(this.es),this.e3=dy(this.es),this.ml0=this.a*ly(this.e0,this.e1,this.e2,this.e3,this.lat0))},forward:function(t){var e,n,i=t.x,r=t.y;if(i=kv(i-this.long0),this.sphere)e=this.a*Math.asin(Math.cos(r)*Math.sin(i)),n=this.a*(Math.atan2(Math.tan(r),Math.cos(i))-this.lat0);else{var s=Math.sin(r),a=Math.cos(r),o=py(this.a,this.e,s),l=Math.tan(r)*Math.tan(r),h=i*Math.cos(r),c=h*h,u=this.es*a*a/(1-this.es);e=o*h*(1-c*l*(1/6-(8-l+8*u)*c/120)),n=this.a*ly(this.e0,this.e1,this.e2,this.e3,r)-this.ml0+o*s/a*c*(.5+(5-l+6*u)*c/24)}return t.x=e+this.x0,t.y=n+this.y0,t},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var e,n,i=t.x/this.a,r=t.y/this.a;if(this.sphere){var s=r+this.lat0;e=Math.asin(Math.sin(s)*Math.cos(i)),n=Math.atan2(Math.tan(i),Math.cos(s))}else{var a=my(this.ml0/this.a+r,this.e0,this.e1,this.e2,this.e3);if(Math.abs(Math.abs(a)-uv)<=dv)return t.x=this.long0,t.y=uv,r<0&&(t.y*=-1),t;var o=py(this.a,this.e,Math.sin(a)),l=o*o*o/this.a/this.a*(1-this.es),h=Math.pow(Math.tan(a),2),c=i*this.a/o,u=c*c;e=a-o*Math.tan(a)/l*c*c*(.5-(1+3*h)*c*c/24),n=c*(1-u*(h/3+(1+3*h)*h*u/15))/Math.cos(a)}return t.x=kv(n+this.long0),t.y=fy(e),t},names:["Cassini","Cassini_Soldner","cass"]};function vy(t,e){var n;return t>1e-7?(1-t*t)*(e/(1-(n=t*e)*n)-.5/t*Math.log((1-n)/(1+n))):2*e}var xy=.3333333333333333,yy=.17222222222222222,_y=.10257936507936508,My=.06388888888888888,by=.0664021164021164,wy=.016415012942191543;var Sy={init:function(){var t,e=Math.abs(this.lat0);if(Math.abs(e-uv)<dv?this.mode=this.lat0<0?this.S_POLE:this.N_POLE:Math.abs(e)<dv?this.mode=this.EQUIT:this.mode=this.OBLIQ,this.es>0)switch(this.qp=vy(this.e,1),this.mmf=.5/(1-this.es),this.apa=function(t){var e,n=[];return n[0]=t*xy,e=t*t,n[0]+=e*yy,n[1]=e*My,e*=t,n[0]+=e*_y,n[1]+=e*by,n[2]=e*wy,n}(this.es),this.mode){case this.N_POLE:case this.S_POLE:this.dd=1;break;case this.EQUIT:this.rq=Math.sqrt(.5*this.qp),this.dd=1/this.rq,this.xmf=1,this.ymf=.5*this.qp;break;case this.OBLIQ:this.rq=Math.sqrt(.5*this.qp),t=Math.sin(this.lat0),this.sinb1=vy(this.e,t)/this.qp,this.cosb1=Math.sqrt(1-this.sinb1*this.sinb1),this.dd=Math.cos(this.lat0)/(Math.sqrt(1-this.es*t*t)*this.rq*this.cosb1),this.ymf=(this.xmf=this.rq)/this.dd,this.xmf*=this.dd}else this.mode===this.OBLIQ&&(this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0))},forward:function(t){var e,n,i,r,s,a,o,l,h,c,u=t.x,d=t.y;if(u=kv(u-this.long0),this.sphere){if(s=Math.sin(d),c=Math.cos(d),i=Math.cos(u),this.mode===this.OBLIQ||this.mode===this.EQUIT){if((n=this.mode===this.EQUIT?1+c*i:1+this.sinph0*s+this.cosph0*c*i)<=dv)return null;e=(n=Math.sqrt(2/n))*c*Math.sin(u),n*=this.mode===this.EQUIT?s:this.cosph0*s-this.sinph0*c*i}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(i=-i),Math.abs(d+this.lat0)<dv)return null;n=mv-.5*d,e=(n=2*(this.mode===this.S_POLE?Math.cos(n):Math.sin(n)))*Math.sin(u),n*=i}}else{switch(o=0,l=0,h=0,i=Math.cos(u),r=Math.sin(u),s=Math.sin(d),a=vy(this.e,s),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(o=a/this.qp,l=Math.sqrt(1-o*o)),this.mode){case this.OBLIQ:h=1+this.sinb1*o+this.cosb1*l*i;break;case this.EQUIT:h=1+l*i;break;case this.N_POLE:h=uv+d,a=this.qp-a;break;case this.S_POLE:h=d-uv,a=this.qp+a}if(Math.abs(h)<dv)return null;switch(this.mode){case this.OBLIQ:case this.EQUIT:h=Math.sqrt(2/h),n=this.mode===this.OBLIQ?this.ymf*h*(this.cosb1*o-this.sinb1*l*i):(h=Math.sqrt(2/(1+l*i)))*o*this.ymf,e=this.xmf*h*l*r;break;case this.N_POLE:case this.S_POLE:a>=0?(e=(h=Math.sqrt(a))*r,n=i*(this.mode===this.S_POLE?h:-h)):e=n=0}}return t.x=this.a*e+this.x0,t.y=this.a*n+this.y0,t},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var e,n,i,r,s,a,o,l,h,c,u=t.x/this.a,d=t.y/this.a;if(this.sphere){var p,f=0,m=0;if((n=.5*(p=Math.sqrt(u*u+d*d)))>1)return null;switch(n=2*Math.asin(n),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(m=Math.sin(n),f=Math.cos(n)),this.mode){case this.EQUIT:n=Math.abs(p)<=dv?0:Math.asin(d*m/p),u*=m,d=f*p;break;case this.OBLIQ:n=Math.abs(p)<=dv?this.lat0:Math.asin(f*this.sinph0+d*m*this.cosph0/p),u*=m*this.cosph0,d=(f-Math.sin(n)*this.sinph0)*p;break;case this.N_POLE:d=-d,n=uv-n;break;case this.S_POLE:n-=uv}e=0!==d||this.mode!==this.EQUIT&&this.mode!==this.OBLIQ?Math.atan2(u,d):0}else{if(o=0,this.mode===this.OBLIQ||this.mode===this.EQUIT){if(u/=this.dd,d*=this.dd,(a=Math.sqrt(u*u+d*d))<dv)return t.x=this.long0,t.y=this.lat0,t;r=2*Math.asin(.5*a/this.rq),i=Math.cos(r),u*=r=Math.sin(r),this.mode===this.OBLIQ?(o=i*this.sinb1+d*r*this.cosb1/a,s=this.qp*o,d=a*this.cosb1*i-d*this.sinb1*r):(o=d*r/a,s=this.qp*o,d=a*i)}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(d=-d),!(s=u*u+d*d))return t.x=this.long0,t.y=this.lat0,t;o=1-s/this.qp,this.mode===this.S_POLE&&(o=-o)}e=Math.atan2(u,d),l=Math.asin(o),h=this.apa,c=l+l,n=l+h[0]*Math.sin(c)+h[1]*Math.sin(c+c)+h[2]*Math.sin(c+c+c)}return t.x=kv(this.long0+e),t.y=n,t},names:["Lambert Azimuthal Equal Area","Lambert_Azimuthal_Equal_Area","laea"],S_POLE:1,N_POLE:2,EQUIT:3,OBLIQ:4};function Ey(t){return Math.abs(t)>1&&(t=t>1?1:-1),Math.asin(t)}var Ty={init:function(){Math.abs(this.lat1+this.lat2)<dv||(this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e3=Math.sqrt(this.es),this.sin_po=Math.sin(this.lat1),this.cos_po=Math.cos(this.lat1),this.t1=this.sin_po,this.con=this.sin_po,this.ms1=Uv(this.e3,this.sin_po,this.cos_po),this.qs1=vy(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat2),this.cos_po=Math.cos(this.lat2),this.t2=this.sin_po,this.ms2=Uv(this.e3,this.sin_po,this.cos_po),this.qs2=vy(this.e3,this.sin_po,this.cos_po),this.sin_po=Math.sin(this.lat0),this.cos_po=Math.cos(this.lat0),this.t3=this.sin_po,this.qs0=vy(this.e3,this.sin_po,this.cos_po),Math.abs(this.lat1-this.lat2)>dv?this.ns0=(this.ms1*this.ms1-this.ms2*this.ms2)/(this.qs2-this.qs1):this.ns0=this.con,this.c=this.ms1*this.ms1+this.ns0*this.qs1,this.rh=this.a*Math.sqrt(this.c-this.ns0*this.qs0)/this.ns0)},forward:function(t){var e=t.x,n=t.y;this.sin_phi=Math.sin(n),this.cos_phi=Math.cos(n);var i=vy(this.e3,this.sin_phi,this.cos_phi),r=this.a*Math.sqrt(this.c-this.ns0*i)/this.ns0,s=this.ns0*kv(e-this.long0),a=r*Math.sin(s)+this.x0,o=this.rh-r*Math.cos(s)+this.y0;return t.x=a,t.y=o,t},inverse:function(t){var e,n,i,r,s,a;return t.x-=this.x0,t.y=this.rh-t.y+this.y0,this.ns0>=0?(e=Math.sqrt(t.x*t.x+t.y*t.y),i=1):(e=-Math.sqrt(t.x*t.x+t.y*t.y),i=-1),r=0,0!==e&&(r=Math.atan2(i*t.x,i*t.y)),i=e*this.ns0/this.a,this.sphere?a=Math.asin((this.c-i*i)/(2*this.ns0)):(n=(this.c-i*i)/this.ns0,a=this.phi1z(this.e3,n)),s=kv(r/this.ns0+this.long0),t.x=s,t.y=a,t},names:["Albers_Conic_Equal_Area","Albers","aea"],phi1z:function(t,e){var n,i,r,s,a=Ey(.5*e);if(t<dv)return a;for(var o=t*t,l=1;l<=25;l++)if(a+=s=.5*(r=1-(i=t*(n=Math.sin(a)))*i)*r/Math.cos(a)*(e/(1-o)-n/r+.5/t*Math.log((1-i)/(1+i))),Math.abs(s)<=1e-7)return a;return null}};var Ly={init:function(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0),this.infinity_dist=1e3*this.a,this.rc=1},forward:function(t){var e,n,i,r,s,a,o,l=t.x,h=t.y;return i=kv(l-this.long0),e=Math.sin(h),n=Math.cos(h),r=Math.cos(i),1,(s=this.sin_p14*e+this.cos_p14*n*r)>0||Math.abs(s)<=dv?(a=this.x0+1*this.a*n*Math.sin(i)/s,o=this.y0+1*this.a*(this.cos_p14*e-this.sin_p14*n*r)/s):(a=this.x0+this.infinity_dist*n*Math.sin(i),o=this.y0+this.infinity_dist*(this.cos_p14*e-this.sin_p14*n*r)),t.x=a,t.y=o,t},inverse:function(t){var e,n,i,r,s,a;return t.x=(t.x-this.x0)/this.a,t.y=(t.y-this.y0)/this.a,t.x/=this.k0,t.y/=this.k0,(e=Math.sqrt(t.x*t.x+t.y*t.y))?(r=Math.atan2(e,this.rc),n=Math.sin(r),a=Ey((i=Math.cos(r))*this.sin_p14+t.y*n*this.cos_p14/e),s=Math.atan2(t.x*n,e*this.cos_p14*i-t.y*this.sin_p14*n),s=kv(this.long0+s)):(a=this.phic0,s=0),t.x=s,t.y=a,t},names:["gnom"]};var Cy={init:function(){this.sphere||(this.k0=Uv(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)))},forward:function(t){var e,n,i=t.x,r=t.y,s=kv(i-this.long0);if(this.sphere)e=this.x0+this.a*s*Math.cos(this.lat_ts),n=this.y0+this.a*Math.sin(r)/Math.cos(this.lat_ts);else{var a=vy(this.e,Math.sin(r));e=this.x0+this.a*this.k0*s,n=this.y0+this.a*a*.5/this.k0}return t.x=e,t.y=n,t},inverse:function(t){var e,n;return t.x-=this.x0,t.y-=this.y0,this.sphere?(e=kv(this.long0+t.x/this.a/Math.cos(this.lat_ts)),n=Math.asin(t.y/this.a*Math.cos(this.lat_ts))):(n=function(t,e){var n=1-(1-t*t)/(2*t)*Math.log((1-t)/(1+t));if(Math.abs(Math.abs(e)-n)<1e-6)return e<0?-1*uv:uv;for(var i,r,s,a,o=Math.asin(.5*e),l=0;l<30;l++)if(r=Math.sin(o),s=Math.cos(o),a=t*r,o+=i=Math.pow(1-a*a,2)/(2*s)*(e/(1-t*t)-r/(1-a*a)+.5/t*Math.log((1-a)/(1+a))),Math.abs(i)<=1e-10)return o;return NaN}(this.e,2*t.y*this.k0/this.a),e=kv(this.long0+t.x/(this.a*this.k0))),t.x=e,t.y=n,t},names:["cea"]};var Ay={init:function(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Equidistant Cylindrical (Plate Carre)",this.rc=Math.cos(this.lat_ts)},forward:function(t){var e=t.x,n=t.y,i=kv(e-this.long0),r=fy(n-this.lat0);return t.x=this.x0+this.a*i*this.rc,t.y=this.y0+this.a*r,t},inverse:function(t){var e=t.x,n=t.y;return t.x=kv(this.long0+(e-this.x0)/(this.a*this.rc)),t.y=fy(this.lat0+(n-this.y0)/this.a),t},names:["Equirectangular","Equidistant_Cylindrical","eqc"]};var Ry={init:function(){this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=hy(this.es),this.e1=cy(this.es),this.e2=uy(this.es),this.e3=dy(this.es),this.ml0=this.a*ly(this.e0,this.e1,this.e2,this.e3,this.lat0)},forward:function(t){var e,n,i,r=t.x,s=t.y,a=kv(r-this.long0);if(i=a*Math.sin(s),this.sphere)Math.abs(s)<=dv?(e=this.a*a,n=-1*this.a*this.lat0):(e=this.a*Math.sin(i)/Math.tan(s),n=this.a*(fy(s-this.lat0)+(1-Math.cos(i))/Math.tan(s)));else if(Math.abs(s)<=dv)e=this.a*a,n=-1*this.ml0;else{var o=py(this.a,this.e,Math.sin(s))/Math.tan(s);e=o*Math.sin(i),n=this.a*ly(this.e0,this.e1,this.e2,this.e3,s)-this.ml0+o*(1-Math.cos(i))}return t.x=e+this.x0,t.y=n+this.y0,t},inverse:function(t){var e,n,i,r,s,a,o,l,h;if(i=t.x-this.x0,r=t.y-this.y0,this.sphere)if(Math.abs(r+this.a*this.lat0)<=dv)e=kv(i/this.a+this.long0),n=0;else{var c;for(a=this.lat0+r/this.a,o=i*i/this.a/this.a+a*a,l=a,s=20;s;--s)if(l+=h=-1*(a*(l*(c=Math.tan(l))+1)-l-.5*(l*l+o)*c)/((l-a)/c-1),Math.abs(h)<=dv){n=l;break}e=kv(this.long0+Math.asin(i*Math.tan(l)/this.a)/Math.sin(n))}else if(Math.abs(r+this.ml0)<=dv)n=0,e=kv(this.long0+i/this.a);else{var u,d,p,f,m;for(a=(this.ml0+r)/this.a,o=i*i/this.a/this.a+a*a,l=a,s=20;s;--s)if(m=this.e*Math.sin(l),u=Math.sqrt(1-m*m)*Math.tan(l),d=this.a*ly(this.e0,this.e1,this.e2,this.e3,l),p=this.e0-2*this.e1*Math.cos(2*l)+4*this.e2*Math.cos(4*l)-6*this.e3*Math.cos(6*l),l-=h=(a*(u*(f=d/this.a)+1)-f-.5*u*(f*f+o))/(this.es*Math.sin(2*l)*(f*f+o-2*a*f)/(4*u)+(a-f)*(u*p-2/Math.sin(2*l))-p),Math.abs(h)<=dv){n=l;break}u=Math.sqrt(1-this.es*Math.pow(Math.sin(n),2))*Math.tan(n),e=kv(this.long0+Math.asin(i*u/this.a)/Math.sin(n))}return t.x=e,t.y=n,t},names:["Polyconic","poly"]};var Py={init:function(){this.A=[],this.A[1]=.6399175073,this.A[2]=-.1358797613,this.A[3]=.063294409,this.A[4]=-.02526853,this.A[5]=.0117879,this.A[6]=-.0055161,this.A[7]=.0026906,this.A[8]=-.001333,this.A[9]=67e-5,this.A[10]=-34e-5,this.B_re=[],this.B_im=[],this.B_re[1]=.7557853228,this.B_im[1]=0,this.B_re[2]=.249204646,this.B_im[2]=.003371507,this.B_re[3]=-.001541739,this.B_im[3]=.04105856,this.B_re[4]=-.10162907,this.B_im[4]=.01727609,this.B_re[5]=-.26623489,this.B_im[5]=-.36249218,this.B_re[6]=-.6870983,this.B_im[6]=-1.1651967,this.C_re=[],this.C_im=[],this.C_re[1]=1.3231270439,this.C_im[1]=0,this.C_re[2]=-.577245789,this.C_im[2]=-.007809598,this.C_re[3]=.508307513,this.C_im[3]=-.112208952,this.C_re[4]=-.15094762,this.C_im[4]=.18200602,this.C_re[5]=1.01418179,this.C_im[5]=1.64497696,this.C_re[6]=1.9660549,this.C_im[6]=2.5127645,this.D=[],this.D[1]=1.5627014243,this.D[2]=.5185406398,this.D[3]=-.03333098,this.D[4]=-.1052906,this.D[5]=-.0368594,this.D[6]=.007317,this.D[7]=.0122,this.D[8]=.00394,this.D[9]=-.0013},forward:function(t){var e,n=t.x,i=t.y-this.lat0,r=n-this.long0,s=i/cv*1e-5,a=r,o=1,l=0;for(e=1;e<=10;e++)o*=s,l+=this.A[e]*o;var h,c=l,u=a,d=1,p=0,f=0,m=0;for(e=1;e<=6;e++)h=p*c+d*u,d=d*c-p*u,p=h,f=f+this.B_re[e]*d-this.B_im[e]*p,m=m+this.B_im[e]*d+this.B_re[e]*p;return t.x=m*this.a+this.x0,t.y=f*this.a+this.y0,t},inverse:function(t){var e,n,i=t.x,r=t.y,s=i-this.x0,a=(r-this.y0)/this.a,o=s/this.a,l=1,h=0,c=0,u=0;for(e=1;e<=6;e++)n=h*a+l*o,l=l*a-h*o,h=n,c=c+this.C_re[e]*l-this.C_im[e]*h,u=u+this.C_im[e]*l+this.C_re[e]*h;for(var d=0;d<this.iterations;d++){var p,f=c,m=u,g=a,v=o;for(e=2;e<=6;e++)p=m*c+f*u,f=f*c-m*u,m=p,g+=(e-1)*(this.B_re[e]*f-this.B_im[e]*m),v+=(e-1)*(this.B_im[e]*f+this.B_re[e]*m);f=1,m=0;var x=this.B_re[1],y=this.B_im[1];for(e=2;e<=6;e++)p=m*c+f*u,f=f*c-m*u,m=p,x+=e*(this.B_re[e]*f-this.B_im[e]*m),y+=e*(this.B_im[e]*f+this.B_re[e]*m);var _=x*x+y*y;c=(g*x+v*y)/_,u=(v*x-g*y)/_}var M=c,b=u,w=1,S=0;for(e=1;e<=9;e++)w*=M,S+=this.D[e]*w;var E=this.lat0+S*cv*1e5,T=this.long0+b;return t.x=T,t.y=E,t},names:["New_Zealand_Map_Grid","nzmg"]};var Dy={init:function(){},forward:function(t){var e=t.x,n=t.y,i=kv(e-this.long0),r=this.x0+this.a*i,s=this.y0+this.a*Math.log(Math.tan(Math.PI/4+n/2.5))*1.25;return t.x=r,t.y=s,t},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var e=kv(this.long0+t.x/this.a),n=2.5*(Math.atan(Math.exp(.8*t.y/this.a))-Math.PI/4);return t.x=e,t.y=n,t},names:["Miller_Cylindrical","mill"]};var Iy={init:function(){this.sphere?(this.n=1,this.m=0,this.es=0,this.C_y=Math.sqrt((this.m+1)/this.n),this.C_x=this.C_y/(this.m+1)):this.en=Gx(this.es)},forward:function(t){var e,n,i=t.x,r=t.y;if(i=kv(i-this.long0),this.sphere){if(this.m)for(var s=this.n*Math.sin(r),a=20;a;--a){var o=(this.m*r+Math.sin(r)-s)/(this.m+Math.cos(r));if(r-=o,Math.abs(o)<dv)break}else r=1!==this.n?Math.asin(this.n*Math.sin(r)):r;e=this.a*this.C_x*i*(this.m+Math.cos(r)),n=this.a*this.C_y*r}else{var l=Math.sin(r),h=Math.cos(r);n=this.a*Vx(r,l,h,this.en),e=this.a*i*h/Math.sqrt(1-this.es*l*l)}return t.x=e,t.y=n,t},inverse:function(t){var e,n,i;return t.x-=this.x0,n=t.x/this.a,t.y-=this.y0,e=t.y/this.a,this.sphere?(e/=this.C_y,n/=this.C_x*(this.m+Math.cos(e)),this.m?e=Ey((this.m*e+Math.sin(e))/this.n):1!==this.n&&(e=Ey(Math.sin(e)/this.n)),n=kv(n+this.long0),e=fy(e)):(e=Wx(t.y/this.a,this.es,this.en),(i=Math.abs(e))<uv?(i=Math.sin(e),n=kv(this.long0+t.x*Math.sqrt(1-this.es*i*i)/(this.a*Math.cos(e)))):i-dv<uv&&(n=this.long0)),t.x=n,t.y=e,t},names:["Sinusoidal","sinu"]};var Ny={init:function(){},forward:function(t){for(var e=t.x,n=t.y,i=kv(e-this.long0),r=n,s=Math.PI*Math.sin(n);;){var a=-(r+Math.sin(r)-s)/(1+Math.cos(r));if(r+=a,Math.abs(a)<dv)break}r/=2,Math.PI/2-Math.abs(n)<dv&&(i=0);var o=.900316316158*this.a*i*Math.cos(r)+this.x0,l=1.4142135623731*this.a*Math.sin(r)+this.y0;return t.x=o,t.y=l,t},inverse:function(t){var e,n;t.x-=this.x0,t.y-=this.y0,n=t.y/(1.4142135623731*this.a),Math.abs(n)>.999999999999&&(n=.999999999999),e=Math.asin(n);var i=kv(this.long0+t.x/(.900316316158*this.a*Math.cos(e)));i<-Math.PI&&(i=-Math.PI),i>Math.PI&&(i=Math.PI),n=(2*e+Math.sin(2*e))/Math.PI,Math.abs(n)>1&&(n=1);var r=Math.asin(n);return t.x=i,t.y=r,t},names:["Mollweide","moll"]};var zy={init:function(){Math.abs(this.lat1+this.lat2)<dv||(this.lat2=this.lat2||this.lat1,this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=hy(this.es),this.e1=cy(this.es),this.e2=uy(this.es),this.e3=dy(this.es),this.sinphi=Math.sin(this.lat1),this.cosphi=Math.cos(this.lat1),this.ms1=Uv(this.e,this.sinphi,this.cosphi),this.ml1=ly(this.e0,this.e1,this.e2,this.e3,this.lat1),Math.abs(this.lat1-this.lat2)<dv?this.ns=this.sinphi:(this.sinphi=Math.sin(this.lat2),this.cosphi=Math.cos(this.lat2),this.ms2=Uv(this.e,this.sinphi,this.cosphi),this.ml2=ly(this.e0,this.e1,this.e2,this.e3,this.lat2),this.ns=(this.ms1-this.ms2)/(this.ml2-this.ml1)),this.g=this.ml1+this.ms1/this.ns,this.ml0=ly(this.e0,this.e1,this.e2,this.e3,this.lat0),this.rh=this.a*(this.g-this.ml0))},forward:function(t){var e,n=t.x,i=t.y;if(this.sphere)e=this.a*(this.g-i);else{var r=ly(this.e0,this.e1,this.e2,this.e3,i);e=this.a*(this.g-r)}var s=this.ns*kv(n-this.long0),a=this.x0+e*Math.sin(s),o=this.y0+this.rh-e*Math.cos(s);return t.x=a,t.y=o,t},inverse:function(t){var e,n,i,r;t.x-=this.x0,t.y=this.rh-t.y+this.y0,this.ns>=0?(n=Math.sqrt(t.x*t.x+t.y*t.y),e=1):(n=-Math.sqrt(t.x*t.x+t.y*t.y),e=-1);var s=0;return 0!==n&&(s=Math.atan2(e*t.x,e*t.y)),this.sphere?(r=kv(this.long0+s/this.ns),i=fy(this.g-n/this.a),t.x=r,t.y=i,t):(i=my(this.g-n/this.a,this.e0,this.e1,this.e2,this.e3),r=kv(this.long0+s/this.ns),t.x=r,t.y=i,t)},names:["Equidistant_Conic","eqdc"]};var Fy={init:function(){this.R=this.a},forward:function(t){var e,n,i=t.x,r=t.y,s=kv(i-this.long0);Math.abs(r)<=dv&&(e=this.x0+this.R*s,n=this.y0);var a=Ey(2*Math.abs(r/Math.PI));(Math.abs(s)<=dv||Math.abs(Math.abs(r)-uv)<=dv)&&(e=this.x0,n=r>=0?this.y0+Math.PI*this.R*Math.tan(.5*a):this.y0+Math.PI*this.R*-Math.tan(.5*a));var o=.5*Math.abs(Math.PI/s-s/Math.PI),l=o*o,h=Math.sin(a),c=Math.cos(a),u=c/(h+c-1),d=u*u,p=u*(2/h-1),f=p*p,m=Math.PI*this.R*(o*(u-f)+Math.sqrt(l*(u-f)*(u-f)-(f+l)*(d-f)))/(f+l);s<0&&(m=-m),e=this.x0+m;var g=l+u;return m=Math.PI*this.R*(p*g-o*Math.sqrt((f+l)*(l+1)-g*g))/(f+l),n=r>=0?this.y0+m:this.y0-m,t.x=e,t.y=n,t},inverse:function(t){var e,n,i,r,s,a,o,l,h,c,u,d;return t.x-=this.x0,t.y-=this.y0,u=Math.PI*this.R,s=(i=t.x/u)*i+(r=t.y/u)*r,u=3*(r*r/(l=-2*(a=-Math.abs(r)*(1+s))+1+2*r*r+s*s)+(2*(o=a-2*r*r+i*i)*o*o/l/l/l-9*a*o/l/l)/27)/(h=(a-o*o/3/l)/l)/(c=2*Math.sqrt(-h/3)),Math.abs(u)>1&&(u=u>=0?1:-1),d=Math.acos(u)/3,n=t.y>=0?(-c*Math.cos(d+Math.PI/3)-o/3/l)*Math.PI:-(-c*Math.cos(d+Math.PI/3)-o/3/l)*Math.PI,e=Math.abs(i)<dv?this.long0:kv(this.long0+Math.PI*(s-1+Math.sqrt(1+2*(i*i-r*r)+s*s))/2/i),t.x=e,t.y=n,t},names:["Van_der_Grinten_I","VanDerGrinten","vandg"]};var Oy={init:function(){this.sin_p12=Math.sin(this.lat0),this.cos_p12=Math.cos(this.lat0)},forward:function(t){var e,n,i,r,s,a,o,l,h,c,u,d,p,f,m,g,v,x,y,_,M,b,w=t.x,S=t.y,E=Math.sin(t.y),T=Math.cos(t.y),L=kv(w-this.long0);return this.sphere?Math.abs(this.sin_p12-1)<=dv?(t.x=this.x0+this.a*(uv-S)*Math.sin(L),t.y=this.y0-this.a*(uv-S)*Math.cos(L),t):Math.abs(this.sin_p12+1)<=dv?(t.x=this.x0+this.a*(uv+S)*Math.sin(L),t.y=this.y0+this.a*(uv+S)*Math.cos(L),t):(x=this.sin_p12*E+this.cos_p12*T*Math.cos(L),v=(g=Math.acos(x))?g/Math.sin(g):1,t.x=this.x0+this.a*v*T*Math.sin(L),t.y=this.y0+this.a*v*(this.cos_p12*E-this.sin_p12*T*Math.cos(L)),t):(e=hy(this.es),n=cy(this.es),i=uy(this.es),r=dy(this.es),Math.abs(this.sin_p12-1)<=dv?(s=this.a*ly(e,n,i,r,uv),a=this.a*ly(e,n,i,r,S),t.x=this.x0+(s-a)*Math.sin(L),t.y=this.y0-(s-a)*Math.cos(L),t):Math.abs(this.sin_p12+1)<=dv?(s=this.a*ly(e,n,i,r,uv),a=this.a*ly(e,n,i,r,S),t.x=this.x0+(s+a)*Math.sin(L),t.y=this.y0+(s+a)*Math.cos(L),t):(o=E/T,l=py(this.a,this.e,this.sin_p12),h=py(this.a,this.e,E),c=Math.atan((1-this.es)*o+this.es*l*this.sin_p12/(h*T)),y=0===(u=Math.atan2(Math.sin(L),this.cos_p12*Math.tan(c)-this.sin_p12*Math.cos(L)))?Math.asin(this.cos_p12*Math.sin(c)-this.sin_p12*Math.cos(c)):Math.abs(Math.abs(u)-Math.PI)<=dv?-Math.asin(this.cos_p12*Math.sin(c)-this.sin_p12*Math.cos(c)):Math.asin(Math.sin(L)*Math.cos(c)/Math.sin(u)),d=this.e*this.sin_p12/Math.sqrt(1-this.es),g=l*y*(1-(_=y*y)*(m=(p=this.e*this.cos_p12*Math.cos(u)/Math.sqrt(1-this.es))*p)*(1-m)/6+(M=_*y)/8*(f=d*p)*(1-2*m)+(b=M*y)/120*(m*(4-7*m)-3*d*d*(1-7*m))-b*y/48*f),t.x=this.x0+g*Math.sin(u),t.y=this.y0+g*Math.cos(u),t))},inverse:function(t){var e,n,i,r,s,a,o,l,h,c,u,d,p,f,m,g,v,x,y,_,M,b,w;if(t.x-=this.x0,t.y-=this.y0,this.sphere){if((e=Math.sqrt(t.x*t.x+t.y*t.y))>2*uv*this.a)return;return n=e/this.a,i=Math.sin(n),r=Math.cos(n),s=this.long0,Math.abs(e)<=dv?a=this.lat0:(a=Ey(r*this.sin_p12+t.y*i*this.cos_p12/e),o=Math.abs(this.lat0)-uv,s=Math.abs(o)<=dv?this.lat0>=0?kv(this.long0+Math.atan2(t.x,-t.y)):kv(this.long0-Math.atan2(-t.x,t.y)):kv(this.long0+Math.atan2(t.x*i,e*this.cos_p12*r-t.y*this.sin_p12*i))),t.x=s,t.y=a,t}return l=hy(this.es),h=cy(this.es),c=uy(this.es),u=dy(this.es),Math.abs(this.sin_p12-1)<=dv?(a=my(((d=this.a*ly(l,h,c,u,uv))-(e=Math.sqrt(t.x*t.x+t.y*t.y)))/this.a,l,h,c,u),s=kv(this.long0+Math.atan2(t.x,-1*t.y)),t.x=s,t.y=a,t):Math.abs(this.sin_p12+1)<=dv?(d=this.a*ly(l,h,c,u,uv),a=my(((e=Math.sqrt(t.x*t.x+t.y*t.y))-d)/this.a,l,h,c,u),s=kv(this.long0+Math.atan2(t.x,t.y)),t.x=s,t.y=a,t):(e=Math.sqrt(t.x*t.x+t.y*t.y),m=Math.atan2(t.x,t.y),p=py(this.a,this.e,this.sin_p12),g=Math.cos(m),x=-(v=this.e*this.cos_p12*g)*v/(1-this.es),y=3*this.es*(1-x)*this.sin_p12*this.cos_p12*g/(1-this.es),b=1-x*(M=(_=e/p)-x*(1+x)*Math.pow(_,3)/6-y*(1+3*x)*Math.pow(_,4)/24)*M/2-_*M*M*M/6,f=Math.asin(this.sin_p12*Math.cos(M)+this.cos_p12*Math.sin(M)*g),s=kv(this.long0+Math.asin(Math.sin(m)*Math.sin(M)/Math.cos(f))),w=Math.sin(f),a=Math.atan2((w-this.es*b*this.sin_p12)*Math.tan(f),w*(1-this.es)),t.x=s,t.y=a,t)},names:["Azimuthal_Equidistant","aeqd"]};var Uy={init:function(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0)},forward:function(t){var e,n,i,r,s,a,o,l=t.x,h=t.y;return i=kv(l-this.long0),e=Math.sin(h),n=Math.cos(h),r=Math.cos(i),1,((s=this.sin_p14*e+this.cos_p14*n*r)>0||Math.abs(s)<=dv)&&(a=1*this.a*n*Math.sin(i),o=this.y0+1*this.a*(this.cos_p14*e-this.sin_p14*n*r)),t.x=a,t.y=o,t},inverse:function(t){var e,n,i,r,s,a,o;return t.x-=this.x0,t.y-=this.y0,n=Ey((e=Math.sqrt(t.x*t.x+t.y*t.y))/this.a),i=Math.sin(n),r=Math.cos(n),a=this.long0,Math.abs(e)<=dv?(o=this.lat0,t.x=a,t.y=o,t):(o=Ey(r*this.sin_p14+t.y*i*this.cos_p14/e),s=Math.abs(this.lat0)-uv,Math.abs(s)<=dv?(a=this.lat0>=0?kv(this.long0+Math.atan2(t.x,-t.y)):kv(this.long0-Math.atan2(-t.x,t.y)),t.x=a,t.y=o,t):(a=kv(this.long0+Math.atan2(t.x*i,e*this.cos_p14*r-t.y*this.sin_p14*i)),t.x=a,t.y=o,t))},names:["ortho"]},By=1,ky=2,Hy=3,Gy=4,Vy=5,Wy=6,jy=1,Xy=2,qy=3,Yy=4;function Zy(t,e,n,i){var r;return t<dv?(i.value=jy,r=0):(r=Math.atan2(e,n),Math.abs(r)<=mv?i.value=jy:r>mv&&r<=uv+mv?(i.value=Xy,r-=uv):r>uv+mv||r<=-(uv+mv)?(i.value=qy,r=r>=0?r-vv:r+vv):(i.value=Yy,r+=uv)),r}function Jy(t,e){var n=t+e;return n<-vv?n+=gv:n>+vv&&(n-=gv),n}var Qy={init:function(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Quadrilateralized Spherical Cube",this.lat0>=uv-mv/2?this.face=Vy:this.lat0<=-(uv-mv/2)?this.face=Wy:Math.abs(this.long0)<=mv?this.face=By:Math.abs(this.long0)<=uv+mv?this.face=this.long0>0?ky:Gy:this.face=Hy,0!==this.es&&(this.one_minus_f=1-(this.a-this.b)/this.a,this.one_minus_f_squared=this.one_minus_f*this.one_minus_f)},forward:function(t){var e,n,i,r,s,a,o={x:0,y:0},l={value:0};if(t.x-=this.long0,e=0!==this.es?Math.atan(this.one_minus_f_squared*Math.tan(t.y)):t.y,n=t.x,this.face===Vy)r=uv-e,n>=mv&&n<=uv+mv?(l.value=jy,i=n-uv):n>uv+mv||n<=-(uv+mv)?(l.value=Xy,i=n>0?n-vv:n+vv):n>-(uv+mv)&&n<=-mv?(l.value=qy,i=n+uv):(l.value=Yy,i=n);else if(this.face===Wy)r=uv+e,n>=mv&&n<=uv+mv?(l.value=jy,i=-n+uv):n<mv&&n>=-mv?(l.value=Xy,i=-n):n<-mv&&n>=-(uv+mv)?(l.value=qy,i=-n-uv):(l.value=Yy,i=n>0?-n+vv:-n-vv);else{var h,c,u,d,p,f;this.face===ky?n=Jy(n,+uv):this.face===Hy?n=Jy(n,+vv):this.face===Gy&&(n=Jy(n,-uv)),d=Math.sin(e),p=Math.cos(e),f=Math.sin(n),h=p*Math.cos(n),c=p*f,u=d,this.face===By?i=Zy(r=Math.acos(h),u,c,l):this.face===ky?i=Zy(r=Math.acos(c),u,-h,l):this.face===Hy?i=Zy(r=Math.acos(-h),u,-c,l):this.face===Gy?i=Zy(r=Math.acos(-c),u,h,l):(r=i=0,l.value=jy)}return a=Math.atan(12/vv*(i+Math.acos(Math.sin(i)*Math.cos(mv))-uv)),s=Math.sqrt((1-Math.cos(r))/(Math.cos(a)*Math.cos(a))/(1-Math.cos(Math.atan(1/Math.cos(i))))),l.value===Xy?a+=uv:l.value===qy?a+=vv:l.value===Yy&&(a+=1.5*vv),o.x=s*Math.cos(a),o.y=s*Math.sin(a),o.x=o.x*this.a+this.x0,o.y=o.y*this.a+this.y0,t.x=o.x,t.y=o.y,t},inverse:function(t){var e,n,i,r,s,a,o,l,h,c,u,d,p={lam:0,phi:0},f={value:0};if(t.x=(t.x-this.x0)/this.a,t.y=(t.y-this.y0)/this.a,n=Math.atan(Math.sqrt(t.x*t.x+t.y*t.y)),e=Math.atan2(t.y,t.x),t.x>=0&&t.x>=Math.abs(t.y)?f.value=jy:t.y>=0&&t.y>=Math.abs(t.x)?(f.value=Xy,e-=uv):t.x<0&&-t.x>=Math.abs(t.y)?(f.value=qy,e=e<0?e+vv:e-vv):(f.value=Yy,e+=uv),h=vv/12*Math.tan(e),s=Math.sin(h)/(Math.cos(h)-1/Math.sqrt(2)),a=Math.atan(s),(o=1-(i=Math.cos(e))*i*(r=Math.tan(n))*r*(1-Math.cos(Math.atan(1/Math.cos(a)))))<-1?o=-1:o>1&&(o=1),this.face===Vy)l=Math.acos(o),p.phi=uv-l,f.value===jy?p.lam=a+uv:f.value===Xy?p.lam=a<0?a+vv:a-vv:f.value===qy?p.lam=a-uv:p.lam=a;else if(this.face===Wy)l=Math.acos(o),p.phi=l-uv,f.value===jy?p.lam=-a+uv:f.value===Xy?p.lam=-a:f.value===qy?p.lam=-a-uv:p.lam=a<0?-a-vv:-a+vv;else{var m,g,v;h=(m=o)*m,g=(h+=(v=h>=1?0:Math.sqrt(1-h)*Math.sin(a))*v)>=1?0:Math.sqrt(1-h),f.value===Xy?(h=g,g=-v,v=h):f.value===qy?(g=-g,v=-v):f.value===Yy&&(h=g,g=v,v=-h),this.face===ky?(h=m,m=-g,g=h):this.face===Hy?(m=-m,g=-g):this.face===Gy&&(h=m,m=g,g=-h),p.phi=Math.acos(-v)-uv,p.lam=Math.atan2(g,m),this.face===ky?p.lam=Jy(p.lam,-uv):this.face===Hy?p.lam=Jy(p.lam,-vv):this.face===Gy&&(p.lam=Jy(p.lam,+uv))}return 0!==this.es&&(c=p.phi<0?1:0,u=Math.tan(p.phi),d=this.b/Math.sqrt(u*u+this.one_minus_f_squared),p.phi=Math.atan(Math.sqrt(this.a*this.a-d*d)/(this.one_minus_f*d)),c&&(p.phi=-p.phi)),p.lam+=this.long0,t.x=p.lam,t.y=p.phi,t},names:["Quadrilateralized Spherical Cube","Quadrilateralized_Spherical_Cube","qsc"]},Ky=[[1,22199e-21,-715515e-10,31103e-10],[.9986,-482243e-9,-24897e-9,-13309e-10],[.9954,-83103e-8,-448605e-10,-9.86701e-7],[.99,-.00135364,-59661e-9,36777e-10],[.9822,-.00167442,-449547e-11,-572411e-11],[.973,-.00214868,-903571e-10,1.8736e-8],[.96,-.00305085,-900761e-10,164917e-11],[.9427,-.00382792,-653386e-10,-26154e-10],[.9216,-.00467746,-10457e-8,481243e-11],[.8962,-.00536223,-323831e-10,-543432e-11],[.8679,-.00609363,-113898e-9,332484e-11],[.835,-.00698325,-640253e-10,9.34959e-7],[.7986,-.00755338,-500009e-10,9.35324e-7],[.7597,-.00798324,-35971e-9,-227626e-11],[.7186,-.00851367,-701149e-10,-86303e-10],[.6732,-.00986209,-199569e-9,191974e-10],[.6213,-.010418,883923e-10,624051e-11],[.5722,-.00906601,182e-6,624051e-11],[.5322,-.00677797,275608e-9,624051e-11]],$y=[[-520417e-23,.0124,121431e-23,-845284e-16],[.062,.0124,-1.26793e-9,4.22642e-10],[.124,.0124,5.07171e-9,-1.60604e-9],[.186,.0123999,-1.90189e-8,6.00152e-9],[.248,.0124002,7.10039e-8,-2.24e-8],[.31,.0123992,-2.64997e-7,8.35986e-8],[.372,.0124029,9.88983e-7,-3.11994e-7],[.434,.0123893,-369093e-11,-4.35621e-7],[.4958,.0123198,-102252e-10,-3.45523e-7],[.5571,.0121916,-154081e-10,-5.82288e-7],[.6176,.0119938,-241424e-10,-5.25327e-7],[.6769,.011713,-320223e-10,-5.16405e-7],[.7346,.0113541,-397684e-10,-6.09052e-7],[.7903,.0109107,-489042e-10,-104739e-11],[.8435,.0103431,-64615e-9,-1.40374e-9],[.8936,.00969686,-64636e-9,-8547e-9],[.9394,.00840947,-192841e-9,-42106e-10],[.9761,.00616527,-256e-6,-42106e-10],[1,.00328947,-319159e-9,-42106e-10]],t_=.8487,e_=1.3523,n_=fv/5,i_=18,r_=function(t,e){return t[0]+e*(t[1]+e*(t[2]+e*t[3]))};var s_={init:function(){this.x0=this.x0||0,this.y0=this.y0||0,this.long0=this.long0||0,this.es=0,this.title=this.title||"Robinson"},forward:function(t){var e=kv(t.x-this.long0),n=Math.abs(t.y),i=Math.floor(n*n_);i<0?i=0:i>=i_&&(i=17);var r={x:r_(Ky[i],n=fv*(n-.08726646259971647*i))*e,y:r_($y[i],n)};return t.y<0&&(r.y=-r.y),r.x=r.x*this.a*t_+this.x0,r.y=r.y*this.a*e_+this.y0,r},inverse:function(t){var e={x:(t.x-this.x0)/(this.a*t_),y:Math.abs(t.y-this.y0)/(this.a*e_)};if(e.y>=1)e.x/=Ky[18][0],e.y=t.y<0?-uv:uv;else{var n=Math.floor(e.y*i_);for(n<0?n=0:n>=i_&&(n=17);;)if($y[n][0]>e.y)--n;else{if(!($y[n+1][0]<=e.y))break;++n}var i=$y[n],r=5*(e.y-i[0])/($y[n+1][0]-i[0]);r=function(t,e,n,i){for(var r=e;i;--i){var s=t(r);if(r-=s,Math.abs(s)<n)break}return r}((function(t){return(r_(i,t)-e.y)/function(t,e){return t[1]+e*(2*t[2]+3*e*t[3])}(i,t)}),r,dv,100),e.x/=r_(Ky[n],r),e.y=(5*n+r)*pv,t.y<0&&(e.y=-e.y)}return e.x=kv(e.x+this.long0),e},names:["Robinson","robin"]};var a_={init:function(){this.name="geocent"},forward:function(t){return ax(t,this.es,this.a)},inverse:function(t){return ox(t,this.es,this.a,this.b)},names:["Geocentric","geocentric","geocent","Geocent"]},o_=0,l_=1,h_=2,c_=3,u_={h:{def:1e5,num:!0},azi:{def:0,num:!0,degrees:!0},tilt:{def:0,num:!0,degrees:!0},long0:{def:0,num:!0},lat0:{def:0,num:!0}};var d_={init:function(){if(Object.keys(u_).forEach(function(t){if(void 0===this[t])this[t]=u_[t].def;else{if(u_[t].num&&isNaN(this[t]))throw new Error("Invalid parameter value, must be numeric "+t+" = "+this[t]);u_[t].num&&(this[t]=parseFloat(this[t]))}u_[t].degrees&&(this[t]=this[t]*pv)}.bind(this)),Math.abs(Math.abs(this.lat0)-uv)<dv?this.mode=this.lat0<0?l_:o_:Math.abs(this.lat0)<dv?this.mode=h_:(this.mode=c_,this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0)),this.pn1=this.h/this.a,this.pn1<=0||this.pn1>1e10)throw new Error("Invalid height");this.p=1+this.pn1,this.rp=1/this.p,this.h1=1/this.pn1,this.pfact=(this.p+1)*this.h1,this.es=0;var t=this.tilt,e=this.azi;this.cg=Math.cos(e),this.sg=Math.sin(e),this.cw=Math.cos(t),this.sw=Math.sin(t)},forward:function(t){t.x-=this.long0;var e,n,i,r,s=Math.sin(t.y),a=Math.cos(t.y),o=Math.cos(t.x);switch(this.mode){case c_:n=this.sinph0*s+this.cosph0*a*o;break;case h_:n=a*o;break;case l_:n=-s;break;case o_:n=s}switch(e=(n=this.pn1/(this.p-n))*a*Math.sin(t.x),this.mode){case c_:n*=this.cosph0*s-this.sinph0*a*o;break;case h_:n*=s;break;case o_:n*=-a*o;break;case l_:n*=a*o}return r=1/((i=n*this.cg+e*this.sg)*this.sw*this.h1+this.cw),e=(e*this.cg-n*this.sg)*this.cw*r,n=i*r,t.x=e*this.a,t.y=n*this.a,t},inverse:function(t){t.x/=this.a,t.y/=this.a;var e,n,i,r={x:t.x,y:t.y};i=1/(this.pn1-t.y*this.sw),e=this.pn1*t.x*i,n=this.pn1*t.y*this.cw*i,t.x=e*this.cg+n*this.sg,t.y=n*this.cg-e*this.sg;var s=qx(t.x,t.y);if(Math.abs(s)<dv)r.x=0,r.y=t.y;else{var a,o;switch(o=1-s*s*this.pfact,o=(this.p-Math.sqrt(o))/(this.pn1/s+s/this.pn1),a=Math.sqrt(1-o*o),this.mode){case c_:r.y=Math.asin(a*this.sinph0+t.y*o*this.cosph0/s),t.y=(a-this.sinph0*Math.sin(r.y))*s,t.x*=o*this.cosph0;break;case h_:r.y=Math.asin(t.y*o/s),t.y=a*s,t.x*=o;break;case o_:r.y=Math.asin(a),t.y=-t.y;break;case l_:r.y=-Math.asin(a)}r.x=Math.atan2(t.x,t.y)}return t.x=r.x+this.long0,t.y=r.y,t},names:["Tilted_Perspective","tpers"]};function p_(t){this.surveyTree=new $g,this.limits=new ut,this.offsets=new lt,this.allStations=[],this.lineSegments=[],this.xGroups=[],this.scraps=[],this.terrains=[],this.sourceCRS=null,this.targetCRS="EPSG:3857",this.displayCRS=null,this.projection=null,this.hasTerrain=!1,this.messages=[],this.metadata=null,this.fileCount=0,this.ctx=t}_x.defaultDatum="WGS84",_x.Proj=sx,_x.WGS84=new _x.Proj("WGS84"),_x.Point=Ux,_x.toPoint=fx,_x.defs=Iv,_x.nadgrid=function(t,e){var n=new DataView(e),i=function(t){var e=t.getInt32(8,!1);if(11===e)return!1;11!==(e=t.getInt32(8,!0))&&console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");return!0}(n),r=function(t,e){return{nFields:t.getInt32(8,e),nSubgridFields:t.getInt32(24,e),nSubgrids:t.getInt32(40,e),shiftType:ex(t,56,64).trim(),fromSemiMajorAxis:t.getFloat64(120,e),fromSemiMinorAxis:t.getFloat64(136,e),toSemiMajorAxis:t.getFloat64(152,e),toSemiMinorAxis:t.getFloat64(168,e)}}(n,i);r.nSubgrids>1&&console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");var s=function(t,e,n){for(var i=176,r=[],s=0;s<e.nSubgrids;s++){var a=ix(t,i,n),o=rx(t,i,a,n),l=Math.round(1+(a.upperLongitude-a.lowerLongitude)/a.longitudeInterval),h=Math.round(1+(a.upperLatitude-a.lowerLatitude)/a.latitudeInterval);r.push({ll:[tx(a.lowerLongitude),tx(a.lowerLatitude)],del:[tx(a.longitudeInterval),tx(a.latitudeInterval)],lim:[l,h],count:a.gridNodeCount,cvs:nx(o)})}return r}(n,r,i),a={header:r,subgrids:s};return Kv[t]=a,a},_x.transform=gx,_x.mgrs=Cx,_x.version="__VERSION__",function(t){t.Proj.projections.add(jx),t.Proj.projections.add(Qx),t.Proj.projections.add(Kx),t.Proj.projections.add(ey),t.Proj.projections.add(ny),t.Proj.projections.add(iy),t.Proj.projections.add(sy),t.Proj.projections.add(ay),t.Proj.projections.add(oy),t.Proj.projections.add(gy),t.Proj.projections.add(Sy),t.Proj.projections.add(Ty),t.Proj.projections.add(Ly),t.Proj.projections.add(Cy),t.Proj.projections.add(Ay),t.Proj.projections.add(Ry),t.Proj.projections.add(Py),t.Proj.projections.add(Dy),t.Proj.projections.add(Iy),t.Proj.projections.add(Ny),t.Proj.projections.add(zy),t.Proj.projections.add(Fy),t.Proj.projections.add(Oy),t.Proj.projections.add(Uy),t.Proj.projections.add(Qy),t.Proj.projections.add(s_),t.Proj.projections.add(a_),t.Proj.projections.add(d_)}(_x),p_.prototype.setCRS=function(t){if(null!==t){const e=t.match(/\+init=(.*)\s/);if(e&&2===e.length){const n=e[1];let i;if("epsg:27700"===n)t="+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs";else{if(i=n.match(/epsg:([0-9]+)/),null!==i)return console.log("looking up CRS code EPSG:"+i[1]),fetch("https://epsg.io/"+i[1]+".proj4").then((t=>t.text())).then((t=>{this._setCRS(t)})).catch((function(){console.log("CRS lookup failed")}));console.log("Unsupported projection:",t),t=null}}}return this._setCRS(t),Promise.resolve(null)},p_.prototype._setCRS=function(t){const e=this.ctx.cfg,n=e.value("displayCRS","EPSG:3857");null===t&&null!==(t=e.value("defaultCRS",null))&&console.log("Using default projection."),null!==t&&(this.sourceCRS=t,"ORIGINAL"===n?this.displayCRS="ORIGINAL":(console.log("Reprojecting from",t,"to",this.targetCRS),this.projection=_x(this.sourceCRS,this.targetCRS),this.displayCRS=this.targetCRS))},p_.prototype.addStations=function(t){this.fileCount++,this.allStations.push(t)},p_.prototype.addLineSegments=function(t){const e=this.lineSegments,n=t.length;for(let i=0;i<n;i++){const n=t[i],r=n.length-1;for(let t=0;t<r;t++){const i=n[t],r=n[t+1],s=i.coords,a=r.coords;e.push({from:s,to:a,type:r.type,survey:r.survey})}}},p_.prototype.addXsects=function(t){const e=[],n=[];let i,r;t.sort((function(t,e){return t.m_from-e.m_from}));for(let n=0;n<t.length;n++){const s=t[n];s.m_from!==i&&(r=[],e.push(r)),i=s.m_to,r.push(s)}for(let t=0;t<e.length;t++){const i=e[t],r=i[0].m_from,s=i[i.length-1].m_to,a=n.indexOf(r);-1!==a&&(e[t]=e[a].concat(i),e[a]=[],n[a]=void 0),n.push(s)}for(let t=0;t<e.length;t++){const n=e[t];if(n.length<2)continue;const i=n[0],r=n[1];if(void 0===i)continue;const s=r.start,a=r.end;i.start=(new lt).copy(s).multiplyScalar(2).sub(a),this.xGroups.push(n)}},p_.prototype.getSurvey=function(){const t=this.limits;if(!this.hasTerrain){const e=t.min,n=t.max;t.expandByVector(new lt(.05*(n.x-e.x),.05*(n.y-e.y),0))}const e=t.getCenter(this.offsets);this.allStations.forEach((t=>t.forEach((t=>t.sub(e)))));const n=this.scraps;for(let t=0;t<n.length;t++){const i=n[t].vertices;for(let t=0;t<i.length;t++)i[t].sub(e)}return{title:this.fileName,surveyTree:this.surveyTree,sourceCRS:this.sourceCRS,displayCRS:this.displayCRS,lineSegments:this.lineSegments,crossSections:this.xGroups,scraps:this.scraps,hasTerrain:this.hasTerrain,metadata:this.metadata,terrains:this.terrains,limits:this.limits,offsets:this.offsets}};const f_={type:"progress",name:"set",progress:0};class m_ extends d{constructor(t,e){super(),e||alert("No callback specified"),this.callback=e,this.dataResponse=null,this.metadataResponse=null,this.requests=[],this.ctx=t,this.reset()}}m_.prototype.reset=function(){this.files=null,this.handler=null,this.section=null,this.requests.forEach((t=>t.abort())),this.requests=[],this.models=new p_(this.ctx)},m_.prototype.setHandler=function(t){const e=t.split(".").reverse().shift().toLowerCase();switch(e){case"3d":this.handler=new ev(t);break;case"lox":this.handler=new sv(t);break;case"plt":this.handler=new ov(t);break;default:return console.warn("CaveView: unknown file extension [",e,"]"),!1}return!0},m_.prototype.loadFile=function(t,e){t instanceof File?this.loadLocalFile(t,e):this.loadURL(t,e)},m_.prototype.loadFiles=function(t){this.files=t,this.loadFile(t.pop())},m_.prototype.progress=function(t){f_.progress=t,this.dispatchEvent(f_)},m_.prototype.loadURL=function(t,e){const n=this.ctx.cfg;this.dispatchEvent({type:"progress",name:"start"}),void 0!==e&&(this.section=e);const i=this,r=n.value("surveyDirectory",""),s=n.value("loadMetadata",!1);if(!this.setHandler(t))return!1;const a=s?2:1;let o=0;const l=(new Gs).setPath(r);if(s){l.setResponseType("json");const e=l.load(Qg(t,"json"),(function(t){i.metadataResponse=t,++o===a&&i.callHandler()}),void 0,(function(t){if("abort"===t.type)return;++o===a&&i.callHandler()}));e&&this.requests.push(e)}l.setResponseType(this.handler.type);const h=l.load(t,(function(t){i.dataResponse=t,i.progress(75),++o===a&&i.callHandler()}),(function(t){t.total>0&&i.progress(Math.round(75*t.loaded/t.total))}),(function(t){if("abort"===t.type)return;console.warn("error event",t),++o===a&&i.callHandler()}));return h&&this.requests.push(h),!0},m_.prototype.loadLocalFile=function(t,e){this.dispatchEvent({type:"progress",name:"start"}),void 0!==e&&(this.section=e);const n=this,i=t.name;if(!this.setHandler(i))return!1;const r=new FileReader;switch(r.addEventListener("load",(function t(){n.dataResponse=r.result,n.callHandler(),n.progress(75),r.removeEventListener("load",t),r.removeEventListener("progress",s)})),r.addEventListener("progress",s),this.handler.type){case"arraybuffer":r.readAsArrayBuffer(t);break;case"text":r.readAsText(t);break;default:return alert("unknown file data type"),!1}return!0;function s(t){t.total>0&&n.progress(Math.round(75*t.loaded/t.total))}},m_.prototype.callHandler=function(){if(null===this.dataResponse)return this.callback(!1),void this.dispatchEvent({type:"progress",name:"end"});const t=this.dataResponse,e=this.metadataResponse,n=this.section,i=this.files;this.dataResponse=null,this.metadataResponse=null;const r=null!==i&&i.length>0,s=this.handler;this.handler=null,r&&this.loadFile(i.pop());const a=this.progress.bind(this);s.parse(this.models,t,e,n,a).then((t=>{r||(this.callback(t),this.dispatchEvent({type:"progress",name:"end"}))}))};class g_ extends Ls{constructor(t,e){const n=e.materials;void 0===n.pointGeometry&&(n.pointGeometry=(new Ie).setAttribute("position",new ae([0,0,0],3))),super(n.pointGeometry,t),this.type="Point"}}class v_ extends g_{constructor(t,e){super(t.materials.getClusterMaterial(e),t),this.renderOrder=1}adjustHeight(t){this.position.setZ(t(this.position)+10)}}v_.prototype.isMarker=!0;const x_=new lt,y_=new lt,__=new lt,M_=new lt,b_=new on(x_,y_,__),w_=new on(x_,__,M_),S_=new Nt,E_=new lt;class T_{constructor(t,e,n,i,r){this.nodes=new Array(4),this.count=0,this.markers=[],this.quadMarker=null,this.centroid=new lt,this.ctx=t,this.xMin=e,this.xMax=n,this.yMin=i,this.yMax=r}addNode(t,e){if(0==e--)return;const n=t.position,i=this.ctx,r=(this.xMin+this.xMax)/2,s=(this.yMin+this.yMax)/2;this.markers.push(t),this.centroid.add(n),this.count++;let a=0;n.x>r&&(a+=1),n.y>s&&(a+=2);let o=this.nodes[a];if(void 0===o){switch(a){case 0:o=new T_(i,this.xMin,r,this.yMin,s);break;case 1:o=new T_(i,r,this.xMax,this.yMin,s);break;case 2:o=new T_(i,this.xMin,r,s,this.yMax);break;case 3:o=new T_(i,r,this.xMax,s,this.yMax)}this.nodes[a]=o}o.addNode(t,e)}check(t,e,n,i){for(let r=0;r<4;r++){const s=this.nodes[r];if(void 0!==s){if(s.count<2){this.nodes[r]=void 0;continue}const a=s.projectedArea(t);x_.subVectors(t.camera.position,e);const o=2*x_.length();x_.normalize(),S_.setFromNormalAndCoplanarPoint(x_,t.camera.position),null===this.quadMarker?y_.copy(this.centroid.clone().divideScalar(this.count)).applyMatrix4(t.matrixWorld):y_.copy(this.quadMarker.position).applyMatrix4(t.matrixWorld);a<10*((o-Math.abs(S_.distanceToPoint(y_)))/o)*n?s.clusterMarkers(t):(s.showMarkers(i),s.check(t,e,n,i))}}}showMarkers(t){this.markers.forEach((e=>e.visible=t.contains(e.stationID))),null!==this.quadMarker&&(this.quadMarker.visible=!1)}hideMarkers(){this.markers.forEach((t=>t.visible=!1)),null!==this.quadMarker&&(this.quadMarker.visible=!1)}clusterMarkers(t){this.hideMarkers();for(let t=0;t<4;t++){const e=this.nodes[t];void 0!==e&&e.hideQuadMarkers()}if(null===this.quadMarker){const e=new v_(this.ctx,this.count);e.position.copy(this.centroid).divideScalar(this.count),e.layers.set(16),null!==t.heightProvider&&e.adjustHeight(t.heightProvider),t.addStatic(e),this.quadMarker=e}this.quadMarker.visible=!0}hideQuadMarkers(){this.quadMarker&&(this.quadMarker.visible=!1);for(let t=0;t<4;t++){const e=this.nodes[t];void 0!==e&&e.hideQuadMarkers()}}projectedArea(t){const e=t.camera,n=t.matrixWorld,i=this.centroid.z/this.count;return x_.set(this.xMin,this.yMin,i).applyMatrix4(n).project(e),y_.set(this.xMin,this.yMax,i).applyMatrix4(n).project(e),__.set(this.xMax,this.yMax,i).applyMatrix4(n).project(e),M_.set(this.xMax,this.yMin,i).applyMatrix4(n).project(e),b_.getArea()+w_.getArea()}}class L_ extends Se{constructor(t,e,n){super();const i=e.min,r=e.max;this.maxDepth=n,this.type="CV.ClusterMarker",this.quadTree=new T_(t,i.x,r.x,i.y,r.y),this.heightProvider=null,this.labels=[],this.ctx=t,this.addEventListener("removed",this.onRemoved)}addHeightProvider(t){this.heightProvider=t,this.traverse((e=>{e.isMarker&&e.adjustHeight(t)}))}onRemoved(){this.traverse((t=>{"GlyphString"===t.type&&t.geometry.dispose()}))}addMarker(t,e){const n=this.ctx.cfg,i=this.ctx.materials,r={background:n.themeColorCSS("stations.entrances.background"),color:n.themeColorCSS("stations.entrances.text"),font:"normal helvetica,sans-serif"},s=i.getGlyphMaterial(r,n.themeAngle("stations.entrances.angle"));s.depthTest=!0,s.transparent=!1,s.alphaTest=0;const a=new Ma(e,s,this.ctx);return a.layers.set(6),a.position.copy(t),a.stationID=t.id,this.labels.push(a),this.quadTree.addNode(a,this.maxDepth),this.addStatic(a),a}cluster(t,e,n){if(this.children.length<2)return;this.camera=t.activeCamera;const i=this.camera.getWorldDirection(E_).dot(Se.DefaultUp);this.quadTree.check(this,e,Math.max(.05,1-Math.cos(i)),n),this.labels.sort(((e,n)=>n.getDepth(t)-e.getDepth(t))),this.labels.forEach(((t,e,n)=>t.checkOcclusion(n,e)))}}class C_ extends L_{constructor(t,e){super(t,e.modelLimits,4);const n=this,i=e.surveyTree,r=e.metadata.entrances,s=[],a=new Ie,o=t.materials.getEntrancePointMaterial();this.entranceColor=t.cfg.themeColor("stations.entrances.marker");const l=new Ls(a,o);l.layers.set(17);let h=i;for(;1===h.children.length;)h=h.children[0];i.traverse((function(t){if(!(2&t.type))return;let e;const i=r[t.getPath()];e=void 0!==i&&void 0!==i.name?i.name:void 0!==t.comment?t.comment:t.getPath(h);if(s.push(t),"-skip"===e)return;n.addMarker(t," "+e+" ")}));const c=3*s.length;if(c>0){const t=new ae(c,3),e=new ae(c,3);t.copyVector3sArray(s),a.setAttribute("position",t),a.setAttribute("color",e)}else this.visible=!1;return this.markers=l,this.vertices=s,this.metadata=e.metadata,this.setSelection(null),this.addStatic(l),this}getStation(t){const e=this.vertices[t],n=e.getPath();return{station:e,name:n,info:this.metadata.entrances[n]}}setStation(t,e){const n=this.metadata;n.entrances[t.getPath()]=e,n.saveLocal()}intersectLabels(t,e,n){const i=this.labels.filter((function(i){return i.intersects(t,e,n)})).sort((function(t,e){return t.depth-e.depth}));return 0===i.length?null:i[0]}setSelection(t){const e=this.markers.geometry.getAttribute("color"),n=this.entranceColor;if(void 0!==e){if(null===t||t.isEmpty()){const t=e.array,i=t.length;for(let e=0;e<i;e+=3)n.toArray(t,e)}else{const i=t.getIds();this.vertices.forEach((function(t,r){i.has(t.id)?n.toArray(e,3*r):e.setXYZ(r,.5,.5,.5)}))}e.needsUpdate=!0}}}class A_ extends g_{constructor(t,e){const n=t.materials;void 0===n.pointerTexture&&(n.pointerTexture=(new ks).load("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='36px' height='36px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z'/%3E%3C/svg%3E"));super(new bs({size:32,map:n.pointerTexture,transparent:!0,sizeAttenuation:!1,alphaTest:.8,color:e}),t)}}const R_=new Rt,P_=new st,D_=new st,I_=new lt,N_=new Ut;class z_ extends Ls{constructor(t,e){super(new Ie,t.materials.getExtendedPointsMaterial()),this.type="CV.Stations",this.stationCount=0,this.ctx=t;const n=t.cfg;this.baseColor=n.themeColor("stations.default.marker"),this.junctionColor=n.themeColor("stations.junctions.marker"),this.entranceColor=n.themeColor("stations.entrances.marker"),this.vertices=[],this.pointSizes=[],this.instanceData=[],this.selected=null,this.selectedSize=0,this.selection=e,this.splaysVisible=!1,this.ssThresholdSq=Math.pow(n.value("stationSelectionDistance",12),2);const i=new A_(t,16711680);i.visible=!1,this.addStatic(i),this.highlightPoint=i}raycast(t,e){if(!this.visible)return e;const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),R_.copy(n.boundingSphere),R_.applyMatrix4(i),R_.radius+=r,!1===t.ray.intersectsSphere(R_))return;const a=this.vertices,o=t.ray,l=t.camera,h=l.projectionMatrix,c=!this.splaysVisible,u=-l.near;o.at(1,D_);const d=this.ctx.container,p=new lt(d.clientWidth/2,d.clientHeight/2,1);D_.w=1,D_.applyMatrix4(l.matrixWorldInverse),D_.applyMatrix4(l.projectionMatrix),D_.multiplyScalar(1/D_.w),I_.copy(D_),I_.multiply(p),N_.multiplyMatrices(l.matrixWorldInverse,i);const f=this.ssThresholdSq;for(let t=Math.max(0,s.start),n=Math.min(a.length,s.start+s.count);t<n;t++){const n=a[t];c&&0===n.connections||(P_.copy(n),P_.w=1,P_.applyMatrix4(N_),P_.z>u||(P_.applyMatrix4(h),P_.multiplyScalar(1/P_.w),P_.x*=p.x,P_.y*=p.y,F_(P_,n,t,f,e,this)))}}addStation(t){if(void 0!==t.legs)return;const e=this.instanceData,n=e.length;let i,r=0;2&t.type?(i=this.entranceColor,r=12):(i=t.connections>2?this.junctionColor:this.baseColor,r=8),this.vertices.push(t),t.toArray(e,n),i.toArray(e,n+3),this.pointSizes.push(r),t.stationVertexIndex=this.stationCount++,t.linkedSegments=[],t.legs=[]}isStationVisible(t){return this.selection.contains(t.id)&&(t.connections>0||this.splaysVisible)}getStationByIndex(t){return this.vertices[t]}clearSelected(){if(null!==this.selected){const t=this.geometry.getAttribute("pSize");t.setX(this.selected,this.selectedSize),t.needsUpdate=!0,this.selected=null}}highlightStation(t){const e=this.highlightPoint;return e.position.copy(t),e.updateMatrix(),e.visible=!0,t}clearHighlight(){this.highlightPoint.visible=!1}selectStation(t){this.selectStationByIndex(t.stationVertexIndex)}selectStationByIndex(t){const e=this.geometry.getAttribute("pSize");null!==this.selected&&e.setX(this.selected,this.selectedSize),this.selectedSize=e.getX(t),e.setX(t,2*this.selectedSize),e.needsUpdate=!0,this.selected=t}selectStations(t){const e=this.vertices,n=e.length,i=this.geometry.getAttribute("pSize"),r=this.splaysVisible?6:0,s=t.getIds(),a=t.isEmpty();for(let t=0;t<n;t++){const n=e[t];let o=8;a||s.has(n.id)?(2&n.type?o=12:0===n.connections&&(o=r),i.setX(t,o)):(i.setX(t,0),void 0!==n.label&&(n.label.visible=!1))}i.needsUpdate=!0}finalise(){const t=this.geometry,e=new Float32Array(this.instanceData),n=new ea(e,6);t.setAttribute("position",new ra(n,3,0)),t.setAttribute("color",new ra(n,3,3)),t.setAttribute("pSize",new ae(this.pointSizes,1)),this.instanceData=null}resetDistances(){this.vertices.forEach((t=>{t&&(t.shortestPath=1/0)}))}setSplaysVisibility(t){this.splaysVisible=t;const e=t?6:0,n=this.vertices,i=this.geometry.getAttribute("pSize"),r=n.length,s=this.selection;for(let t=0;t<r;t++){const r=n[t];0!==r.connections||0!==e&&!s.contains(r.id)||i.setX(t,e)}i.needsUpdate=!0}}function F_(t,e,n,i,r,s){const a=t.x-I_.x,o=t.y-I_.y,l=a*a+o*o;l<i&&r.push({distance:Math.sqrt(l),point:t,index:n,station:e,face:null,object:s})}const O_=new lt;class U_ extends ps{constructor(t,e,n){super(),this.type="CV.StationLabels",this.stations=e,this.commentCount=n,this.ctx=t;const i=t.cfg,r=t.materials,s={color:i.themeColorCSS("stations.default.text"),font:i.themeValue("stations.font")};this.defaultLabelMaterial=r.getGlyphMaterial(s,0),this.splayLabelMaterial=r.getGlyphMaterial(s,0);const a={color:i.themeColorCSS("stations.junctions.text"),font:i.themeValue("stations.font")};this.junctionLabelMaterial=r.getGlyphMaterial(a,0)}update(t,e,i){const r=O_.copy(t.position);t.isOrthographicCamera&&(r.sub(e),r.setLength(n/t.zoom),r.add(e)),r.applyMatrix4(i);const s=this.stations,a=s.vertices,o=a.length,l=0!=(8192&t.layers.mask),h=0!=(32768&t.layers.mask),c=o/this.commentCount;for(let t=0;t<o;t++){const e=a[t],n=e.label;if(!s.isStationVisible(e)){n&&(n.visible=!1);continue}let i=4e4;0===e.connections?i=250:e.connections<3&&(i=5e3),h&&void 0!==e.comment&&(i*=c);const o=e.distanceToSquared(r)<i;let u="";l&&(u+=e.name),l&&h&&void 0!==e.comment&&(u+=" "),h&&void 0!==e.comment&&(u+=e.comment),n&&n.name===u?n.visible=o:(void 0!==n&&(this.remove(n),e.label=null),o&&this.addLabel(e,u))}}addLabel(t,e){const n=t.connections;let i;i=0===n?this.splayLabelMaterial:n<3?this.defaultLabelMaterial:this.junctionLabelMaterial;const r=new Ma(e,i,this.ctx);r.layers.mask=this.layers.mask,r.position.copy(t),t.label=r,this.addStatic(r)}}class B_ extends ps{constructor(t,e){super(),this.markers=new Map,this.markerColor=e,this.ctx=t}mark(t){const e=this.markers;if(e.has(t))return;const n=new A_(this.ctx,this.markerColor);n.position.copy(t),n.station=t,n.layers=this.layers,this.add(n),e.set(t,n)}unmark(t){const e=this.markers,n=e.get(t);void 0!==n&&(this.remove(n),e.delete(t))}clear(){this.markers.forEach((t=>this.remove(t))),this.markers.clear()}getStations(){const t=[];return this.markers.forEach(((e,n)=>t.push(n))),t}setVisibility(t){this.markers.forEach((e=>e.visible=t))}}class k_{constructor(t,e){if(0===t.length||!e)return;this.stations=t,this.legsObject=e,this.vertexPairToSegment=[],this.segmentMap=new Map,this.segmentToInfo={},this.maxDistance=0,this.zeroStation=null;const n=e.legVertices,i=this.segmentMap,r=this.vertexPairToSegment,s=this.segmentToInfo,a=n.length;let o,l,h=!0,c=0;for(let t=0;t<a;t+=2){const e=n[t],u=n[t+1];if(r.push(c),o=e,void 0!==o&&(o.legs.push(t),o.linkedSegments.push(c)),h){if(void 0===o)continue;l={segment:c,startStation:o,endStation:null},h=!1}o=u,void 0!==o&&o.legs.push(t),o&&(o.connections>2||t+2<a&&!o.equals(n[t+2]))&&(l.endStation=o,i.set(l.startStation.id+":"+o.id,l),s[c]=l,o.linkedSegments.push(c),c++,h=!0)}return h||(l.endStation=o,i.set(l.startStation.id+":"+o.id,l),o.linkedSegments.push(c)),this}vertexSegment(t){return this.vertexPairToSegment[t/2]}shortestPathSearch(t,e=function(){}){const n=[t],i=this.legsObject,r=i.legVertices;this.stations.resetDistances();let s=0;for(t.shortestPath=0;n.length>0;){const t=n.shift(),a=t.legs;if(!a)continue;const o=t.shortestPath;s=Math.max(s,o);for(let s=0;s<a.length;s++){const l=a[s],h=r[l],c=r[l+1],u=h!==t?h:c,d=i.legLengths[l/2];u.shortestPath>o+d&&(u.shortestPath===1/0&&e(t,u),u.shortestPath=o+d,n.push(u))}}this.zeroStation=t,this.maxDistance=s}getShortestPath(t){const e=this.zeroStation,n=new Set;if(null===e||t.shortestPath===1/0||e===t||0===t.shortestPath)return n;const i=this.legsObject.legVertices;let r=t,s=!0;for(;s;){const t=r.legs,a=t.length;for(let o=0;o<a;o++){const a=t[o],l=i[a],h=i[a+1],c=l!==r?l:h;c.shortestPath<r.shortestPath&&(r=c,n.add(a),r===e&&(s=!1))}}return n}getAdjacentStations(t){const e=this.legsObject.legVertices,n=t.legs,i=t,r=[];return n?(n.forEach((t=>{const n=e[t],s=e[t+1],a=n!==i?n:s;r.push(a.id)})),r):r}}class H_ extends d{constructor(t){super(),this.metadata=t.metadata,this.topology=t.topology,this.surveyTree=t.surveyTree,this.routes=new Map,this.routeNames=[],this.currentRoute=new Set,this.currentRouteName=null,this.adjacentSegments=new Set,Object.defineProperty(this,"setRoute",{set:function(t){this.loadRoute(t)},get:function(){return this.currentRouteName}});const e=this.metadata.getRoutes(),n=this.routeNames;let i;for(i in e){const t=e[i];n.push(i),this.routes.set(i,t.segments)}n.sort(),this.dispatchEvent({type:"changed",name:"download"})}addRoute(t){t!==this.currentRouteName&&void 0!==t&&(this.routeNames.indexOf(t)<0&&(this.routeNames.push(t),this.routes.set(t,[])),this.loadRoute(t))}loadRoute(t){const e=this.surveyTree,n=this.currentRoute,i=this.topology.segmentMap,r=this.routes.get(t);if(!r)return alert("route "+t+" does not exist"),!1;n.clear();for(let t=0;t<r.length;t++){const s=r[t],a=i.get(e.getIdByPath(s.start)+":"+e.getIdByPath(s.end));void 0!==a&&n.add(a.segment)}return this.currentRouteName=t,this.dispatchEvent({type:"changed",name:""}),!0}getCurrentRoute(){return this.currentRoute}saveCurrent(){const t=this.currentRouteName,e=this.topology.segmentMap,n=this.currentRoute;if(!t)return;const i=[];e.forEach((function(t){n.has(t.segment)&&i.push({start:t.startStation.getPath(),end:t.endStation.getPath()})})),this.routes.set(t,i),this.metadata.saveRoute(t,{segments:i})}getRouteNames(){return this.routeNames}toggleSegment(t){const e=this,n=this.currentRoute,i=this.topology.vertexSegment(t);if(this.adjacentSegments.clear(),n.has(i))n.delete(i);else{n.add(i);const t=this.topology.segmentToInfo[i];void 0!==t&&(t.startStation.linkedSegments.forEach(r),t.endStation.linkedSegments.forEach(r))}return;function r(t){n.has(t)||e.adjacentSegments.add(t)}}inCurrentRoute(t){return this.currentRoute.has(this.topology.vertexSegment(t))}adjacentToRoute(t){return this.adjacentSegments.has(this.topology.vertexSegment(t))}}class G_ extends Ha{constructor(t){super(new Ea,t.materials.getSurveyLineMaterial("basic")),this.ctx=t,this.legLengths=[],this.legVertices=[],this.colors=[],this.type="Legs",this.highlightLeg=null,this.scale.set(1,1,1)}addLegs(t,e){this.legVertices=t,this.legRuns=e;const n=new ae(3*t.length,3),i=new ae(3*t.length,3);n.copyVector3sArray(t),i.array.fill(1);const r=this.geometry;return r.setPositions(n.array),r.setColors(i.array),this.computeLineDistances(),this.computeStats(),this.colors=i,this}computeStats(){const t=this.legVertices,e=t.length,n=e/2,i=new Array(n);let r=0,s=0,a=1/0,o=-1/0;for(let n=0;n<e;n+=2){const e=t[n],l=t[n+1],h=e.correctedDistanceTo(l);i[n/2]=h,r+=h,s+=h*h,o=Math.max(o,h),a=Math.min(a,h)}const l={minLegLength:a,maxLegLength:o,legLength:r,legLengthSD:Math.sqrt(s/n-Math.pow(r/n,2)),legLengthRange:o-a,legCount:n};return this.legLengths=i,this.stats=l,this}cutRuns(t){const e=t.getIds(),n=this.legRuns;if(!n)return;const i=this.legVertices,r=[],s=[],a=n.length;for(let t=0;t<a;t++){const a=n[t],o=a.survey,l=a.start,h=a.end;let c=0;if(e.has(o)){for(let t=l;t<h;t++)r.push(i[t]);a.start=c,c+=h-l,a.end=c,s.push(a)}}return 0!==r.length&&(this.geometry.dispose(),this.addLegs(r,s),!0)}setHighlightLeg(t){this.highlightLeg=t}setShading(t,e,n,i,r){this.material=this.ctx.materials.getSurveyLineMaterial(n,i),this.material.needsUpdate=!0;const s=this.legRuns,a=this.ctx.cfg.themeColor("shading.unselected"),o=this.legVertices,l=this.colors.array,h=null===this.highlightLeg?null:2*this.highlightLeg;if(t.size>0&&s)for(let n=0,i=s.length;n<i;n++){const i=s[n],r=i.survey,h=i.start,c=i.end;if(t.has(r))for(let t=h;t<c;t+=2)e(o,l,t,t+1,r);else for(let t=h;t<c;t++)a.toArray(l,3*t)}else for(let t=0,n=o.length;t<n;t+=2){const n=t+1;null!==h&&t!==h||r&&(o[t].shortestPath===1/0||o[n].shortestPath===1/0)?(a.toArray(l,3*t),a.toArray(l,3*n)):e(o,l,t,n,null)}this.geometry.getAttribute("instanceColorStart").needsUpdate=!0,this.geometry.getAttribute("instanceColorEnd").needsUpdate=!0}hide(t){if(t){const t=this.legVertices,e=t.length,n=[];for(let i=0;i<e;i+=2){const e=t[i].type,r=t[i+1].type;n.push(4&e&&4&r?1:0)}this.geometry.setHide(n)}else this.geometry.clearHide()}getLegStations(t){const e=this.legVertices;return{start:e[t],end:e[t+1]}}}function V_(t,e,n,i,r){r.dashOffset+=.1}class W_ extends Ha{constructor(t){const e=new Ea,n=t.survey;super(e,new Ng(t,"",!0)),this.metadata=n.metadata,this.vertices=[],this.selected=[],this.stations=[],this.onBeforeRender=V_,this.visible=!1;const i=n.metadata.traces,r=n.surveyTree;i.forEach((t=>{const e=r.getByPath(t.start),n=r.getByPath(t.end);void 0!==n&&void 0!==e&&this._addTrace(e,n)})),this.finish()}finish(){const t=this.geometry;if(0!==this.vertices.length)return t.setPositions(this.vertices),t.setHide(this.selected),this.visible=!0,this.metadata.traces=this.serialise(),this.metadata.saveLocal(),this}getTraceStations(t){const e=this.stations;return{start:e[2*t].getPath(),end:e[2*t+1].getPath()}}deleteTrace(t){const e=2*t;this.stations.splice(e,2),this.vertices.splice(e,2),this.selected.splice(e,2),this.finish()}_addTrace(t,e){this.vertices.push(t.x,t.y,t.z,e.x,e.y,e.z),this.stations.push(t,e),this.selected.push(1,1)}addTrace(t,e){this._addTrace(t,e),this.finish()}outlineTrace(t){if(!this.visible)return;const e=this.selected;if(e.fill(0),null!==t){let n=2*t;e[n++]=1,e[n]=1}this.geometry.setHide(e)}serialise(){const t=this.stations,e=[];for(let n=0,i=t.length;n<i;n+=2)e.push({start:t[n].getPath(),end:t[n+1].getPath()});return e}}class j_ extends d{constructor(t,e){super(),this.name=t;let n={},i=[],r={};null!==e&&(e.routes&&(n=e.routes),e.traces&&(i=e.traces),e.entrances&&(r=e.entrances));let s=window.localStorage.getItem(t);if(null!==s){s=JSON.parse(s);const t=s.routes;for(const e in t){const i=t[e];i.local=!0,n[e]=i}void 0!==s.traces&&(i=s.traces),void 0!==s.entrances&&(r=s.entrances)}this.routes=n,this.traces=i,this.entrances=r}getRoutes(){return this.routes}saveRoute(t,e){this.routes[t]=e,this.saveLocal(),this.dispatchEvent({name:"change",type:"routes"})}saveLocal(){const t={routes:this.routes,traces:this.traces,entrances:this.entrances};window.localStorage.setItem(this.name,JSON.stringify(t))}getURL(){return Kg({name:"test",version:1,routes:this.routes,traces:this.traces,entrances:this.entrances})}}class X_ extends ho{constructor(t){super(),this.transparent=!0,this.onBeforeCompile=function(e){Object.assign(e.uniforms,t.materials.commonTerrainUniforms),this.editShader(e,"varying vec2 vPosition;","vPosition = vec2( position.x, position.y );",Ta.commonTerrainCodePars,Ta.commonTerrainCodeColor)},Object.defineProperty(this,"opacity",{get:function(){return t.materials.terrainOpacity}})}}class q_{constructor(t,e){this.provider=e,this.active=!1,this.hasCoverage=!1,this.crsSupported=void 0===e.crsSupported?["EPSG:3857","EPSG:4326","ORIGINAL"]:e.crsSupported,this.throughMode=2,this.ctx=t;const n=e.getAttribution();if(n){const e={h:0,s:0,l:0};new te(t.cfg.themeValue("background")).getHSL(e),n.classList.add("overlay-branding"),n.style.color=e.l<.5?"white":"black",this.attribution=n}this.materialCache=new Map,this.missing=new Set;const i=e.coverage;void 0!==i&&(this.coverage=new ca(new $(i.minX,i.minY),new $(i.maxX,i.maxY)))}getMinZoom(){return this.provider.minZoom}checkCoverage(t,e,n){const i=this.coverage;if(-1===this.crsSupported.indexOf(e))return!1;const r=_x("ORIGINAL"===e?n:e,"WGS84"),s=new ca;return s.expandByPoint(r.forward({x:t.min.x,y:t.min.y})),s.expandByPoint(r.forward({x:t.min.x,y:t.max.y})),s.expandByPoint(r.forward({x:t.max.x,y:t.min.y})),s.expandByPoint(r.forward({x:t.max.x,y:t.max.y})),this.provider.crs=e,this.hasCoverage=void 0===i||i.intersectsBox(s),this.hasCoverage}showAttribution(){const t=this.attribution;void 0!==t&&this.ctx.container.appendChild(t)}hideAttribution(){const t=this.attribution,e=t.parentNode;null!==e&&e.removeChild(t)}getTile(t,e,n){const i=t+":"+e+":"+n,r=this.ctx.cfg,s=this.ctx.materials,a=this.materialCache.get(i),o=this.provider.maxZoom;let l=1,h=0,c=0;return new Promise((u=>{if(void 0!==a)return void u(this.active?a:null);const d=n-o;if(d>0){const i=Math.pow(2,d);l=1/i;const r=Math.floor(t*l),s=Math.floor(e*l);h=(t-r*i)/i,c=1-(e-s*i)/i,c-=l,t=r,e=s,n=o}const p=this.provider.getUrl(t,e,n);null===p||this.missing.has(p)?u(s.getMissingMaterial()):(new ks).setCrossOrigin("anonymous").load(p,(t=>{if(!this.active)return t.dispose(),void u(null);const e=new X_(this.ctx);t.anisotropy=r.value("anisotropy",4),t.repeat.setScalar(l),t.offset.set(h,c),e.map=t,e.needsUpdate=!0,this.materialCache.set(i,e),u(e)}),void 0,(()=>{this.missing.add(p),u(this.active?s.getMissingMaterial():null)}))}))}setActive(){this.showAttribution(),this.active=!0}setInactive(){this.materialCache.forEach((t=>{t.map.dispose(),t.dispose()})),this.materialCache.clear(),this.hideAttribution(),this.active=!1}}const Y_=new lt,Z_=new lt,J_=new Uint8Array(4);class Q_ extends ps{constructor(t){super(),this.hasOverlay=!1,this.activeOverlay=null,this.depthTexture=null,this.renderer=null,this.renderTarget=null,this.datumShift=0,this.activeDatumShift=0,this.terrainBase=null,this.terrainRange=null,this.isFlat=!1,this.screenAttribution=null,this.terrainShadingModes={},this.throughMode=1,this.commonUniforms=t.materials.commonTerrainUniforms,this.ctx=t,this.shadingMode=8,this.addEventListener("removed",(()=>this.removed()))}removed(){}getOpacity(){return this.ctx.materials.terrainOpacity}setOpacity(t){this.ctx.materials.terrainOpacity=t}commonRemoved(){const t=this.activeOverlay;null!==t&&t.setInactive(),null!==this.renderTarget&&this.renderTarget.dispose()}checkTerrainShadingModes(t){const e=this.ctx.overlays,n={"terrain.shading.height":8};if((t.capabilities.isWebGL2||null!==t.extensions.get("OES_standard_derivatives")&&!this.isFlat)&&(n["terrain.shading.contours ("+this.ctx.cfg.themeValue("shading.contours.interval")+" m)"]=15),this.isTiled)for(const t in e){const i=e[t];i.checkCoverage(this.limits,this.displayCRS,this.surveyCRS)&&(i.active=this.activeOverlay===i,n[t]=t)}else this.hasOverlay&&(n["terrain.shading.overlay"]=7);return this.terrainShadingModes=n,n}setup(t,e,n){this.computeBoundingBox(),n.addStatic(this);const i=1024,r=this.ctx.materials,s=this.ctx.container;let a=s.clientWidth,o=s.clientHeight;const l=n.combinedLimits.getSize(Y_),h=a/l.x,c=o/l.y;h<c?o=o*h/c:a=a*c/h;const u=new Vn(-a/2,a/2,o/2,-o/2,-1e4,1e4);u.layers.set(7);const d=new at(i,i,{minFilter:S,magFilter:w,format:I,stencilBuffer:!0});d.texture.generateMipmaps=!1,d.texture.name="CV.DepthMapTexture",t.setSize(i,i),t.setPixelRatio(1),t.clear(),t.setRenderTarget(d),e.overrideMaterial=r.getDepthMapMaterial(this),t.render(e,u),e.overrideMaterial=null,this.addHeightMap(t,d),this.checkTerrainShadingModes(t),t.renderLists.dispose(),this.ctx.viewer.resetRenderer(),n.setupTerrain(this),r.setTerrain(this)}setShadingMode(t,e){const n=this.activeOverlay,i=this.ctx.materials,r=this.ctx.overlays;let s,a=!0,o=null;switch(t){case 8:s=i.getHypsometricMaterial();break;case 7:this.setOverlay(e),a=!1;break;case 15:s=i.getContourMaterial();break;default:if(o=r[t],void 0===o)return console.warn("unknown mode",t),!1;this.isTiled&&o.hasCoverage?(o.throughMode=this.throughMode,this.setOverlay(o,e),a=!1):(s=i.getHypsometricMaterial(),t=8)}return a&&null!==n&&(n.setInactive(),this.activeOverlay=null),void 0!==s&&(s.setThroughMode(this.throughMode),this.setMaterial(s)),this.shadingMode=t,!0}setThroughMode(t){this.throughMode=t}setVisibility(t){this.visible=t,t?this.showAttribution():this.hideAttribution()}showAttribution(){const t=this.screenAttribution;null!==t&&this.ctx.container.appendChild(t),null!==this.activeOverlay&&this.activeOverlay.showAttribution()}hideAttribution(){const t=this.screenAttribution;if(null!==t){const e=t.parentNode;null!==e&&e.removeChild(t)}null!==this.activeOverlay&&this.activeOverlay.hideAttribution()}applyDatumShift(t){t&&0===this.activeDatumShift?(this.translateZ(this.datumShift),this.activeDatumShift=this.datumShift):t||0===this.activeDatumShift||(this.translateZ(-this.datumShift),this.activeDatumShift=0),this.updateMatrix(),this.dispatchEvent({type:"datumShiftChange",value:this.activeDatumShift})}computeBoundingBox(){const t=new ut;return this.traverse((function(e){e.isTile&&e.isMesh&&t.union(e.geometry.boundingBox)})),this.boundingBox=t,t}addHeightMap(t,e){this.depthTexture=e.texture,this.renderer=t,this.renderTarget=e}getHeight(t){const e=this.renderTarget;null===this.terrainBase&&(void 0===this.boundingBox&&this.computeBoundingBox(),this.terrainBase=this.boundingBox.min,this.terrainRange=this.boundingBox.getSize(new lt),Z_.set(e.width,e.height,1).divide(this.terrainRange));const n=this.terrainBase;return Y_.copy(t).sub(n).multiply(Z_).round(),this.renderer.readRenderTargetPixels(e,Y_.x,Y_.y,1,1,J_),(2.319211489520967e-10*(i=J_)[0]+5.9371814131736755e-8*i[1]+1519918441772461e-20*i[2]+.0038909912109375*i[3])*this.terrainRange.z+n.z;var i}setScale(t){this.commonUniforms.scale.value=t}setAccuracy(t){this.commonUniforms.accuracy.value=t,this.commonUniforms.ringColor.value.g=1-t/1e3}setTarget(t){this.commonUniforms.target.value.copy(t)}_fitSurface(t){let e=0,n=0,i=0;t.forEach((t=>{const r=this.getHeight(t);n+=r,i+=r*r,e++}));const r=Math.sqrt(i/e-Math.pow(n/e,2));this.datumShift=n/e,console.log("Adjustmenting terrain height by:",this.datumShift,"sd:",r)}}Q_.addOverlay=function(t,e,n){void 0===t.overlays&&(t.overlays={}),t.overlays[e]=new q_(t,n)};class K_ extends Ie{constructor(t,e){super(),this.type="LoxTerrainGeometry";const n=t.data,i=t.lines,r=t.samples,s=t.calib,a=[],o=[],l=s.xx,h=s.xy,c=s.yx,u=s.yy,d=s.xOrigin-e.x,p=s.yOrigin-e.y,f=-e.z,m=r-1,g=i-1;let v=1/0,x=-1/0;for(let t=0;t<i;t++){const e=(i-1-t)*r;for(let i=0;i<r;i++){const r=i*l+(g-t)*h+d,s=i*c+(g-t)*u+p,a=n[e+i]+f;o.push(r,s,a),a<v&&(v=a),a>x&&(x=a)}}const y=m*l+g*h+d,_=m*c+g*u+p;this.boundingBox=new ut(new lt(d,p,v),new lt(y,_,x));for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=e+r*t,i=e+r*(t+1),s=e+1+r*(t+1),l=e+1+r*t;Math.abs(o[3*n+2]-o[3*l+2])<Math.abs(o[3*i+2]-o[3*s+2])?(a.push(n,i,l),a.push(i,s,l)):(a.push(n,i,s),a.push(s,l,n))}this.setIndex(a),this.setAttribute("position",new ae(o,3)),this.computeVertexNormals()}setupUVs(t,e,n){const i=t.calib,r=i.xx*i.yy-i.xy*i.yx;if(0===r)return!1;const s=i.yy/r,a=-i.xy/r,o=-i.yx/r,l=i.xx/r,h=this.getAttribute("position").array,c=e.naturalWidth,u=e.naturalHeight,d=-(s*i.xOrigin+a*i.yOrigin),p=-(o*i.xOrigin+l*i.yOrigin),f=[];for(let t=0;t<h.length;t+=3){const e=h[t]+n.x,i=h[t+1]+n.y,r=(e*s+i*a+d)/c,m=(e*o+i*l+p)/u;f.push(r,m)}void 0!==this.getAttribute("uv")&&console.alert("replacing attribute uv"),this.setAttribute("uv",new ae(f,2))}}class $_ extends Tn{constructor(t,e,n){super(new K_(e.dtm,n),t.materials.getSurfaceMaterial()),this.type="CV.LoxTile",this.layers.set(7),this.overlayMaterial=null,this.ctx=t,void 0===e.bitmap?this.bitmap=null:(this.bitmap=e.bitmap,this.offsets=n)}loadOverlay(t,e){if(null===this.bitmap)return;const n=(new ks).load(this.bitmap.image,(function(){const r=i.bitmap;i.geometry.setupUVs(r,n.image,i.offsets),n.onUpdate=function(t){URL.revokeObjectURL(t.image.src),t.image=null},i.overlayMaterial=new X_(t),i.overlayMaterial.map=n,i.overlayMaterial.setThroughMode(i.parent.throughMode),r.data=null,r.image=null,i.material=i.overlayMaterial,e()})),i=this;return void(n.anisotropy=this.ctx.cfg.value("anisotropy",4))}removed(){const t=this.overlayMaterial;null!==t&&(t.map.dispose(),t.dispose()),this.geometry.dispose()}}$_.prototype.isTile=!0;class tM extends Q_{constructor(t,e,n){super(t),this.type="CV.Terrain",this.overlayMaterial=null,this.attributions=[];let i=0;e.forEach((e=>{const r=new $_(t,e,n);null!==r.bitmap&&i++,this.add(r)})),this.overlayLoaded=!1,this.hasOverlay=i>0}setOverlay(t,e){if(this.hasOverlay){if(this.overlayLoaded)return this.children.forEach((t=>{null!==t.overlayMaterial&&(console.log("dd"),t.material=[t.overlayMaterial,e])})),void t();this.children.forEach((n=>n.loadOverlay(this.ctx,t,e))),this.overlayLoaded=!0}}removed(){this.children.forEach((t=>t.removed())),this.commonRemoved()}setMaterial(t){this.children.forEach((e=>e.material=t))}fitSurface(t,e){super._fitSurface(t,e)}}tM.prototype.isTiled=!1,tM.prototype.isLoaded=!0;class eM extends Tn{constructor(t){super(new Ie,t.materials.getUnselectedWallMaterial()),this.ctx=t,this.type="Walls"}addWalls(t,e,n){const i=this.geometry,r=new ae(3*t.length,3);return i.setAttribute("position",r.copyVector3sArray(t)),i.setIndex(e),i.computeVertexNormals(),i.computeBoundingBox(),this.indexRuns=n,this}setShading(t,e){const n=this.geometry,i=this.indexRuns,r=this.ctx.materials;if(n.clearGroups(),this.visible=this.ready,t.length>0&&i){this.material=[e,r.getUnselectedWallMaterial()];let s,a=i[0],o=a.start,l=a.count,h=t.has(a.survey)?0:1;for(let e=1,r=i.length;e<r;e++)a=i[e],s=t.has(a.survey)?0:1,s===h&&a.start===o+l?l+=a.count:(n.addGroup(o,l,h),o=a.start,l=a.count,h=s);n.addGroup(o,l,h)}else this.material=e}cutRuns(t){const e=this.flat;this.setFlat(!1),this.flatGeometry&&(this.flatGeometry.dispose(),this.flatGeometry=null);const n=this.geometry,i=n.getAttribute("position"),r=n.index,s=t.getIds(),a=this.indexRuns,o=[],l=[],h=[],c=new Map,u=a.length;let d,p=0,f=0;for(d=0;d<u;d++){const t=a[d];if(s.has(t.survey)){const e=t.start,n=t.count,s=e+n,a=i.itemSize,u=i.array;for(let t=e;t<s;t++){const e=r.getX(t);let n=c.get(e);if(void 0===n){const t=e*a;n=p++,c.set(e,n),l.push(u[t],u[t+1],u[t+2])}o.push(n)}t.start=f,f+=n,h.push(t)}}return 0!==o.length&&(n.index=new r.constructor(o),n.setAttribute("position",new ae(l,3)),n.computeVertexNormals(),n.computeBoundingBox(),this.indexRuns=h,this.setFlat(e),!0)}setFlat(t){if(t===this.flat)return;const e=this.geometry;let n=this.flatGeometry;t?(null===n&&(n=e.toNonIndexed(),n.computeVertexNormals(),n.computeBoundingBox()),this.indexedGeometry=e,this.geometry=n,this.dropBuffers()):(this.flatGeometry=e,this.geometry=this.indexedGeometry),this.flat=t}}function nM(t,e){!function(t,e){const n=t.scraps,i=n.length;if(0===i)return null;const r=e.addFeature(new eM(e.ctx),o,"Scraps"),s=[],a=[],l=[];let h=0,c=0;for(let t=0;t<i;t++)u(n[t]);return r.addWalls(a,s,l),void e.addFeature(r,o,"CV.Survey:faces:scraps");function u(t){let e,n;for(e=0,n=t.vertices.length;e<n;e++)a.push(t.vertices[e]);for(e=0,n=t.faces.length;e<n;e++){const n=t.faces[e];s.push(n[0]+h,n[2]+h,n[1]+h)}const i=s.length;l.push({start:c,count:i-c,survey:t.survey}),c=i,h+=t.vertices.length}}(t,e),function(t,e){const n=t.crossSections;e.stations;const i=e.getLegs(),r=e.ctx,s=new Map,o=r.cfg.value("fixup_xsects",!0);if(n.forEach((t=>{t.forEach((t=>{s.set(t.end,t)}))})),0===n.length)return;const l=[],h=e.addFeature(new eM(r),a,"Walls"),c=[],u=[],d=n.length,p=[],f=Se.DefaultUp;let m,g,v,x,y,_,M,b,w,S,E,T,L,C,A,R,P,D=0,I=0;const N=new lt,z=new lt,F=new lt;let O,U=null;if(0!==d){for(let t=0;t<d;t++){const e=n[t];if(e.length<2)continue;null===e[0].start&&H(e),o&&G(e);const i=e.length;O=k(e[0],e[1]);for(let t=1;t<i;t++){const n=e[t],i=n.survey;O=k(n,e[t+1]),i!==m&&(m=i,null!==U&&(B(),I=c.length,U.count=I-U.start,p.push(U),U=null)),g=D++,v=D++,x=D++,y=D++,8===O?(S=D++,L=D++,E=D++,T=D++):(S=g,L=v,E=v,T=g),_=D++,M=D++,b=D++,w=D++,8===O?(C=D++,P=D++,A=D++,R=D++):(C=g,P=v,A=v,R=g),4===O?(c.push(x,v,M),c.push(x,M,b),c.push(x,b,_),c.push(x,_,g),c.push(y,M,v),c.push(y,w,M),c.push(y,_,w),c.push(y,g,_)):(c.push(x,E,A),c.push(x,A,b),c.push(x,b,C),c.push(x,C,S),c.push(E,v,M),c.push(E,M,A),c.push(S,C,_),c.push(S,_,g),c.push(L,M,v),c.push(L,P,M),c.push(T,_,R),c.push(T,g,_),c.push(y,P,L),c.push(y,w,P),c.push(y,R,w),c.push(y,T,R)),D-=O,null===U&&(U={start:I,survey:i},c.push(x,y,v),c.push(x,g,y),8===O&&(c.push(x,S,g),c.push(x,v,E),c.push(y,g,T),c.push(y,L,v)))}m=null,D+=O}if(null!==U&&(B(),U.count=c.length-U.start,p.push(U)),0!==c.length)return h.addWalls(u,c,p),e.addFeature(h,a,"CV.Survey:faces:walls"),void e.loadWarnings(l)}function B(){c.push(b,M,w),c.push(b,w,_),8===O&&(c.push(b,_,C),c.push(b,A,M),c.push(w,R,_),c.push(w,M,P))}function k(t,e){const n=.293,i=t.end,r=t.lrud;let s;N.subVectors(t.start,t.end).normalize();const a=Math.abs(N.dot(f))>.97;let o,l,h,c,d,p;if(e&&(F.subVectors(e.start,e.end).normalize(),N.add(F)),N.cross(f),a&&r.u+r.d<5){N.copy(z);const t=N.clone().cross(f);o=t.clone().setLength(-r.u).add(i),l=t.clone().setLength(r.d).add(i)}else o=new lt(i.x,i.y,i.z+r.u),l=new lt(i.x,i.y,i.z-r.d);const m=N.clone().setLength(r.l).add(i),g=N.clone().setLength(-r.r).add(i);switch(z.copy(N),t.type){case 3:u.push(m,g,o,l),s=4;break;case 2:h=m.clone().setZ(o.z),c=g.clone().setZ(o.z),d=m.clone().setZ(l.z),p=g.clone().setZ(l.z),u.push(h,p,c,d),s=4;break;case 1:u.push(m,g,o,l),h=m.clone().setZ(o.z).lerp(i,n),c=g.clone().setZ(o.z).lerp(i,n),d=m.clone().setZ(l.z).lerp(i,n),p=g.clone().setZ(l.z).lerp(i,n),u.push(h,p,c,d),s=8;break;default:console.error("unsupported lrud shape",t.type)}return s}function H(t){let e=t[0],n=t[1];if(o){const i=V(e.end,n.end);if(i){e.start=i;const r=s.get(i);r&&(n=e,e={start:null,end:i,lrud:r.lrud,type:2},t.unshift(e),l.push({station:n.start,text:"xSects start extended"}))}}e.start=(new lt).copy(n.start).multiplyScalar(2).sub(n.end)}function G(t){const e=t[t.length-1],n=V(e.end,e.start);if(!n)return;const i=s.get(n);void 0!==i&&(t.push({start:e.end,end:n,lrud:i.lrud,type:2}),l.push({station:e.end,text:"xSects end extended"}))}function V(t,e){const n=t.legs;if(0===n.length)return;const r=[];return n.forEach((n=>{const s=i[n]!==t?i[n]:i[n+1];s!==e&&r.push(s)})),r[0]}}(t,e)}function iM(t){let e=[],n=0;this.getColour=function(e){const n=t.materials.colourCache.getColors("survey");return n[e%n.length]},this.getColourMap=function(t){if(n===t&&e.length>0)return e;e=[],n=t;let i=n,r=this.getColour(n.id);a(i);let s=i.children;for(;1===s.length;)i=s[0],a(i),s=i.children;for(let t=0,e=s.length;t<e;t++){const e=s[t];r=this.getColour(e.id),e.traverse(a)}return e;function a(t){t.isStation()||(e[t.id]=r)}}}eM.prototype.ready=!0,eM.prototype.flat=!1,eM.prototype.flatGeometry=null,eM.prototype.indexedGeometry=null;class rM extends Ha{constructor(t,e,n=16776960){const i=new lt(.5,.5,.5),r=new lt(-.5,.5,.5),s=new lt(-.5,-.5,.5),a=new lt(.5,-.5,.5),o=new lt(.5,.5,-.5),l=new lt(-.5,.5,-.5),h=new lt(-.5,-.5,-.5),c=new lt(.5,-.5,-.5),u=[i,r,r,s,s,a,a,i,o,l,l,h,h,c,c,o,i,o,r,l,s,h,a,c],d=new ae(3*u.length,3),p=new Ea;d.copyVector3sArray(u),p.setPositions(d.array),super(p,t.materials.getLine2Material({color:n})),e&&this.update(e),this.type="CV.SurveyBox"}update(t){t.getSize(this.scale),t.getCenter(this.position),this.updateMatrix(),this.geometry.computeBoundingSphere()}removed(){this.geometry&&this.geometry.dispose()}}class sM extends rM{constructor(t,e){const n=t.survey,i=new ut;let r=n.surveyTree,s=r;super(t,r.boundingBox,e);const a=this.material;a.stencilWrite=!0,a.stencilZPass=H,this.layers.set(5),n.addStatic(this);const o=new Set;this.setRoot=function(t){r=t},this.set=function(t){s=t,o.clear(),s===r?this.visible=!1:(t.getSubtreeIds(o),this.visible=!0,t.isStation()||void 0===t.boundingBox||this.update(t.boundingBox))},this.getIds=function(){return o},this.isEmpty=function(){return s===r},this.contains=function(t){return s===r||o.has(t)},this.getWorldBoundingBox=function(){return this.isEmpty()?n.getWorldBoundingBox():i.copy(s.boundingBox).applyMatrix4(n.matrixWorld)},this.getName=function(){return this.isEmpty()?"":s.getPath()},this.getNode=function(){return s},this.isStation=function(){return s.isStation()}}}class aM extends Ha{constructor(t){const e=new Ea,n=t.survey,i=t.cfg.themeColor("grid.base");super(e,t.materials.getLine2Material({color:i})),this.scale.set(1,1,1),this.type="CV.Grid";const r=t.survey.combinedLimits,s=r.min.clone();s.y=r.max.y;const a=r.max.clone(),o=r.min.clone();o.x=r.max.x;const l=r.min.clone(),h=n.getGeographicalPosition(s),c=n.getGeographicalPosition(a),u=n.getGeographicalPosition(o),d=n.getGeographicalPosition(l),p=Math.min(u.x-d.x,c.x-h.x),f=Math.min(h.y-d.y,c.y-u.y),m=Math.log10(Math.max(p,f)),g=Math.pow(10,Math.round(m)-1),v=(u.x-d.x)/(o.x-l.x),x=(h.y-d.y)/(s.y-l.y),y=Math.atan2(u.y-d.y,u.x-d.x),_=Math.cos(y),M=(g-d.x%g)*_/v,b=(g-d.y%g)*_/x,w=g*_/v,S=g*_/x,E=(o.x-l.x)*(u.y-d.y)/(u.x-d.x),T=(s.y-l.y)*(h.x-d.x)/(h.y-d.y),L=r.min.z;let C;const A=[];for(C=l.x+M;C<o.x;C+=w)A.push(C,l.y,L,C-T,s.y,L);for(C=l.y+b;C<s.y;C+=S)A.push(l.x,C,L,o.x,C-E,L);e.setPositions(A)}}const oM=new Set,lM=new te(16777215);class hM extends Se{constructor(t,e){super(),this.highlightBox=null,this.highlightPath=null,this.lastMarkedStation=null,this.markers=new B_(t,65280),this.featureBox=null,this.surveyTree=null,this.projection=null,this.projectionWGS84=null,this.worldBoundingBox=null,this.caveShading=1,this.surfaceShading=5,this.duplicateShading=18,this.wallsMode=!1,this.hideMode=!1,this.ctx=t,this.pointTargets=[],this.entranceTargets=[],this.type="CV.Survey",this.cutInProgress=!1,this.features=new Map,this.routes=null,this.stations=null,this.terrain=null,this.topology=null,this.inverseWorld=new Ut,this.lightDirection=new lt(-1,-1,2).normalize();const n=this;this.gradientName=t.cfg.value("saturatedGradient",!1)?"gradientHi":"gradientLow",t.surveyColourMapper=new iM(t),t.survey=this;let i=e.getSurvey();this.name=i.title,this.CRS=i.sourceCRS,this.displayCRS=i.displayCRS,this.limits=i.limits,this.offsets=i.offsets;const r=(new ut).copy(this.limits);r.min.sub(this.offsets),r.max.sub(this.offsets),this.modelLimits=r,this.combinedLimits=r,function(){const t=i.displayCRS;if(null===i.sourceCRS||null===t||"ORIGINAL"===t)return n.scaleFactor=1,void(null!==i.sourceCRS&&(n.projectionWGS84=_x("WGS84",i.sourceCRS)));const e=n.limits,r=e.min.clone(),s=e.max.clone();r.z=0,s.z=0;const a=r.distanceTo(s),o=_x(t,i.sourceCRS);r.copy(o.forward(r)),s.copy(o.forward(s)),n.projection=o;const l=r.distanceTo(s);n.scaleFactor=a/l,tv.scaleFactor=1/n.scaleFactor,n.projectionWGS84=_x("WGS84",i.displayCRS)}(),this.loadCave(i),this.loadWarnings(e.messages),this.loadEntrances(),this.setFeatureBox(),this.addStatic(this.markers),this.addFeature(new aM(t),c,"Grid"),this.addEventListener("removed",this.onRemoved);let s=.5;return i=null,void Object.defineProperty(this,"zScale",{get:function(){return s},set:function(t){const e=Math.pow(2,4*(s-.5)),i=Math.pow(2,4*(t-.5));n.applyMatrix4((new Ut).makeScale(1,1,i/e)),n.updateMatrix(),s=t}})}}hM.prototype.onRemoved=function(){if(this.cutInProgress)this.cutInProgress=!1;else for(this.traverse((function(t){t.geometry&&t.geometry.dispose()}));this.children.length>0;)this.remove(this.children[0])},hM.prototype.loadWarnings=function(t){const e=this.selection;if(t.length>0){let n=this.getFeature(14);n||(n=new B_(this.ctx,16711935)),t.forEach((t=>{const i=t.station;void 0!==i&&(e.isEmpty()||e.contains(i.id))&&(n.mark(i),i.messageText=t.text)})),this.addFeature(n,14,"CV.Survey:warnings")}},hM.prototype.refreshColors=function(){if(this.hasFeature(6)){const t=this.getFeature(6);this.removeFeature(t),this.remove(t),this.entrances=null}if(this.loadEntrances(),this.featureBox){const t=this.getFeature(4);this.removeFeature(t),this.remove(t),this.featureBox=null}this.setFeatureBox(),this.setShadingMode(this.caveShading),this.setSurfaceShading(this.surfaceShading),this.setDuplicateShading(this.duplicateShading)},hM.prototype.loadEntrances=function(){const t=new C_(this.ctx,this);this.addFeature(t,6,"CV.Survey:entrances"),this.entranceTargets=[t.markers],this.entrances=t},hM.prototype.setupTerrain=function(t){if(this.combinedLimits=(new ut).copy(t.boundingBox).union(this.modelLimits),this.setFeatureBox(),t.isFlat)return;const e=this.getFeature(c);this.removeFeature(e),this.remove(e),this.addFeature(new aM(this.ctx),c);const n=[];this.surveyTree.traverse((function(t){if(!(2&t.type))return;n.push(t)})),t.fitSurface(n,this.offsets),null===this.terrain&&(this.terrain=t);const i=this.getFeature(6);return void(void 0!==i&&i.addHeightProvider(t.getHeight.bind(t)))},hM.prototype.loadCave=function(t){const e=this,n=this.ctx,i=t.surveyTree;this.surveyTree=i,this.selection=new sM(n,n.cfg.themeValue("box.select")),function(t){const i=t.length,r=[];let s,a,o,l;if(r[1]={vertices:[],runs:[]},r[3]={vertices:[],runs:[]},r[2]={vertices:[],runs:[]},r[19]={vertices:[],runs:[]},0===i)return null;for(let e=0;e<i;e++){const n=t[e],i=n.type,h=n.survey;if(s=r[i],void 0===n){console.warn("unknown segment type: ",i);break}if(h!==l||i!==o){if(void 0!==a){const t=r[o];a.end=t.vertices.length,t.runs.push(a)}a={},a.survey=h,a.start=s.vertices.length,l=h,o=i}s.vertices.push(n.from),s.vertices.push(n.to)}void 0===a.end&&(a.end=s.vertices.length,s.runs.push(a));return h(1,"CV.Survey:cave:cave"),h(3,"CV.Survey:surface:surface"),h(2,"CV.Survey:cave:splay"),void h(u,"CV.Survey:cave:duplicate");function h(t,i){const s=r[t];if(0===s.vertices.length)return;const a=new G_(n);a.addLegs(s.vertices,s.runs),e.addFeature(a,t,i+":g")}}(t.lineSegments),this.loadStations(i),function(t){if(!1===t.hasTerrain)return;const i=new tM(n,t.terrains,e.offsets);e.terrain=i}(t),this.computeBoundingBoxes(i),this.pointTargets.push(this.stations);const r=new j_(this.name,t.metadata);return this.metadata=r,this.loadDyeTraces(),this.topology=new k_(this.stations,this.getFeature(1)),this.routes=new H_(this),void nM(t,this)},hM.prototype.getFeature=function(t){return this.features.get(t)},hM.prototype.update=function(t,e){const n=t.activeCamera,i=this.features.get(6);i&&t.testCameraLayer(6)?(t.setCameraLayer(16,!0),i.cluster(t,e,this.selection)):t.setCameraLayer(16,!1);const r=this.features.get(l);(r&&t.testCameraLayer(l)||r.commentCount>0&&t.testCameraLayer(h))&&r.update(n,e,this.inverseWorld)},hM.prototype.addFeature=function(t,e,n){return t.name=n,t.layers.set(e),this.features.set(e,t),this.addStatic(t),t},hM.prototype.removeFeature=function(t){this.layers.mask&=~t.layers.mask;const e=this.features;e.forEach(((n,i)=>{n===t&&e.delete(i)}))},hM.prototype.hasFeature=function(t){return this.features.has(t)},hM.prototype.loadStations=function(t){const e=new z_(this.ctx,this.selection);let n=0;t.traverse((function(t){void 0!==t.comment&&n++;if(!t.isStation())return;e.addStation(t)})),e.finalise();const i=new U_(this.ctx,e,n);return this.addFeature(e,8,"CV.Stations"),this.addFeature(i,l,"CV.StationLabels"),n>0&&(this.features.set(h,i),i.layers.enable(h)),void(this.stations=e)},hM.prototype.computeBoundingBoxes=function(t){return void t.traverseDepthFirst((function(t){const e=t.parent;if(t.isStation())e.boundingBox.expandByPoint(t);else if(e){if(0===t.children.length||t.boundingBox.isEmpty())return;e.boundingBox.expandByPoint(t.boundingBox.min),e.boundingBox.expandByPoint(t.boundingBox.max)}}))},hM.prototype.loadDyeTraces=function(){const t=new W_(this.ctx);this.addFeature(t,9,"CV.DyeTraces"),this.dyeTraces=t},hM.prototype.setScale=function(t,e){this.scale.set(t,t,e),this.updateMatrix(),this.updateMatrixWorld(),this.inverseWorld.copy(this.matrixWorld).invert(),this.worldBoundingBox=this.combinedLimits.clone().applyMatrix4(this.matrixWorld)},hM.prototype.getLegs=function(){return this.getFeature(1).legVertices},hM.prototype.getRoutes=function(){return this.routes},hM.prototype.getWorldPosition=function(t){return t.applyMatrix4(this.matrixWorld)},hM.prototype.getGeographicalPosition=function(t){const e=this.offsets,n=this.projection;let i={x:t.x+e.x,y:t.y+e.y};return null!==n&&(i=n.forward(i)),new lt(i.x,i.y,t.z+e.z)},hM.prototype.containsWGS84Position=function(t){t.copy(this.projectionWGS84.forward(t));const e=this.limits.min,n=this.limits.max;return t.x>=e.x&&t.x<=n.x&&t.y>=e.y&&t.y<=n.y},hM.prototype.getModelSurfaceFromWGS84=function(t,e){const n=this.offsets;return t.copy(this.projectionWGS84.forward(t)),void this.terrain.getHeights([t],(function(i){t.z=i[0].z,t.sub(n),e()}))},hM.prototype.shortestPathSearch=function(t){this.highlightPath=null,this.markers.clear(),this.topology.shortestPathSearch(t),this.markers.mark(t),this.setShadingMode(s)},hM.prototype.showShortestPath=function(t){this.highlightPath=this.topology.getShortestPath(t),null!==this.lastMarkedStation&&this.markers.unmark(this.lastMarkedStation),this.markers.mark(t),this.lastMarkedStation=t,this.setLegShading(1,s)},hM.prototype.getMaxDistance=function(){return this.topology.maxDistance},hM.prototype.selectStation=function(t){this.stations.selectStation(t)},hM.prototype.highlightSelection=function(t){if(t.isStation())this.stations.highlightStation(t);else{let e=this.highlightBox;null===e&&(e=new sM(this.ctx,this.ctx.cfg.themeValue("box.highlight")),this.highlightBox=e),e.set(t),this.stations.clearHighlight(),t===this.surveyTree?this.entrances.setSelection(this.selection):this.entrances.setSelection(e)}},hM.prototype.selectSection=function(t){const e=this.selection;return this.highlightSelection(this.surveyTree),e.set(t),this.stations.selectStations(e),this.entrances.setSelection(e),this.setShadingMode(this.caveShading),t},hM.prototype.setFeatureBox=function(){if(null===this.featureBox){const t=new rM(this.ctx,this.combinedLimits,this.ctx.cfg.themeColorCSS("box.bounding"));this.addFeature(t,4,"survey-boundingbox"),this.featureBox=t}else this.featureBox.update(this.combinedLimits);this.worldBoundingBox=this.combinedLimits.clone().applyMatrix4(this.matrixWorld)},hM.prototype.getWorldBoundingBox=function(){return this.worldBoundingBox},hM.prototype.cutSection=function(t){const e=this.selection;if(e.set(t),e.isEmpty())return;this.pointTargets=[],this.entranceTargets=[],this.terrain=null;const n=[];this.traverse((function(t){switch(t.type){case"Legs":case"Walls":t.cutRuns(e)||n.push(t);break;case"CV.SurveyBox":case"CV.Stations":case"CV.StationLabels":case"CV.ClusterMarker":case"CV.Grid":n.push(t)}})),n.forEach((t=>{const e=t.parent;e&&e.remove(t),t.geometry&&t.geometry.dispose(),this.removeFeature(t)})),this.surveyTree=t,this.selection.setRoot(t),this.highlightBox&&this.highlightBox.setRoot(t),this.loadStations(t),this.pointTargets.push(this.stations),this.selectSection(t),this.modelLimits=this.getBounds(),this.combinedLimits=this.modelLimits,this.limits.copy(this.modelLimits),this.limits.min.add(this.offsets),this.limits.max.add(this.offsets),this.featureBox=null,this.setFeatureBox(),this.addFeature(new aM(this.ctx),c),this.worldBoundingBox=null,this.loadEntrances();const i=this.getFeature(1);return this.topology=new k_(this.stations,i),void(this.cutInProgress=!0)},hM.prototype.getBounds=function(){const t=new ut,e=t.min,n=t.max;return this.traverse((function(t){if("CV.Survey"===t.type||"CV.Box3"===t.type)return;const i=t.geometry;i&&i.boundingBox&&(e.min(i.boundingBox.min),n.max(i.boundingBox.max))})),t},hM.prototype.setWallsMode=function(t){const e=this.getFeature(a),n=this.getFeature(o);e&&e.setFlat(t),n&&n.setFlat(t),this.wallsMode=t},hM.prototype.setHideMode=function(t){const e=this.getFeature(1);e&&e.hide(t),this.hideMode=t},hM.prototype.setShadingMode=function(t,e){const n=this.ctx.materials;let i;switch(t){case 1:i=n.getHeightMaterial();break;case 4:i=n.getCursorMaterial();break;case 5:i=n.getSurfaceMaterial();break;case 9:if(null===this.terrain)return!1;if(i=n.getDepthMaterial(),!i)return!1;break;case r:if(null===this.terrain)return!1;if(i=n.getDepthCursorMaterial(),!i)return!1;break;case s:case 6:i=!1}return this.markers.setVisibility(t===s),this.setLegShading(1,t,!1,e)&&(this.setWallShading(this.features.get(a),i),this.setWallShading(this.features.get(o),i),this.caveShading=t),this.caveShading},hM.prototype.setWallShading=function(t,e){t&&(e?t.setShading(this.selection,e):t.visible=!1)},hM.prototype.setSurfaceShading=function(t){return this.setLegShading(3,t,!0)&&(this.surfaceShading=t),this.surfaceShading},hM.prototype.setDuplicateShading=function(t){return this.setLegShading(u,t,!0)&&(this.duplicateShading=t),this.duplicateShading},hM.prototype.setLegShading=function(t,e,n,a){const o=this.features.get(t);if(void 0===o)return!1;switch(e){case 1:this.setLegColourByMaterial(o,"height",n,a);break;case 2:this.setLegColourByLength(o,a);break;case 3:this.setLegColourByInclination(o,a);break;case 4:this.setLegColourByMaterial(o,"cursor",a);break;case r:this.setLegColourByMaterial(o,"depth-cursor",a);break;case 5:this.setLegColourByColour(o,this.ctx.cfg.themeColor("shading.single"),n,a);break;case 17:this.setLegColourByColour(o,this.ctx.cfg.themeColor("shading.surface"),n,a);break;case 18:this.setLegColourByColour(o,this.ctx.cfg.themeColor("shading.duplicate"),n,a);break;case 6:this.setLegColourBySurvey(o,a);break;case i:this.setLegColourByPath(o);break;case 7:case 8:break;case 9:this.setLegColourByMaterial(o,"depth",n,a);break;case s:0===this.topology.maxDistance?this.setLegColourByColour(o,this.ctx.cfg.themeColor("shading.unconnected")):this.setLegColourByDistance(o);break;default:return console.warn("invalid leg shading mode"),!1}return!0},hM.prototype.setLegColourByMaterial=function(t,e,n,i){t.setShading(this.selection.getIds(),(function(t,e,n,i){lM.toArray(e,3*n),lM.toArray(e,3*i)}),e,n,i)},hM.prototype.setLegColourByColour=function(t,e,n,i){t.setShading(this.selection.getIds(),(function(t,n,i,r){e.toArray(n,3*i),e.toArray(n,3*r)}),"basic",n,i)},hM.prototype.setLegColourByLength=function(t,e){const n=this.ctx.materials.colourCache.getColors(this.gradientName),i=n.length-1,r=t.stats,s=t.legLengths;t.setShading(this.selection.getIds(),(function(t,e,a,o){const l=(s[a/2]-r.minLegLength)/r.legLengthRange,h=n[Math.floor(l*i)];h.toArray(e,3*a),h.toArray(e,3*o)}),"basic",!1,e)},hM.prototype.setLegColourByDistance=function(t,e){const n=this.ctx.cfg,i=this.ctx.materials.colourCache.getColors(this.gradientName),r=n.themeColor("shading.unconnected"),s=n.themeColor("routes.active"),a=i.length-1,o=this.topology.maxDistance,l=this.highlightPath;function h(t,e){const n=t[e].shortestPath;return n===1/0?r:i[Math.floor(a*n/o)]}t.setShading(this.selection.getIds(),(function(t,e,n,i){const r=null!==l&&l.has(n),a=r?s:h(t,n),o=r?s:h(t,i);a.toArray(e,3*n),o.toArray(e,3*i)}),"basic",!1,e)},hM.prototype.setLegColourBySurvey=function(t,e){let n=this.selection.getNode();for(;1===n.children.length;)n=n.children[0];oM.clear(),n.getSubtreeIds(oM);const i=this.ctx.surveyColourMapper.getColourMap(n);t.setShading(oM,(function(t,e,n,r,s){const a=i[s];a.toArray(e,3*n),a.toArray(e,3*r)}),"basic",!1,e)},hM.prototype.setLegColourByPath=function(t){const e=this.routes,n=this.ctx.cfg,i=n.themeColor("routes.active"),r=n.themeColor("routes.adjacent"),s=n.themeColor("routes.default");t.setShading(this.selection.getIds(),(function(t,n,a,o){let l;l=e.inCurrentRoute(a)?i:e.adjacentToRoute(a)?r:s;l.toArray(n,3*a),l.toArray(n,3*o)}),"basic")},hM.prototype.setLegColourByInclination=function(t,e){const n=this.ctx.materials.colourCache.getColors("inclination"),i=2*(n.length-1)/Math.PI,r=new lt;t.setShading(this.selection.getIds(),(function(t,e,s,a){const o=t[s],l=t[a];r.subVectors(o,l).normalize();const h=r.dot(Se.DefaultUp),c=Math.floor(i*Math.acos(Math.abs(h))),u=n[c];u.toArray(e,3*s),u.toArray(e,3*a)}),"basic",!1,e)};class cM extends He{constructor(t,e,n,i){const r=Math.cos(n),s=Math.sin(n),a=window.devicePixelRatio||1,o=e.image,l=new Float32Array([r,s,-s,r]),h=new $(o.width*a/t.clientWidth,o.height*a/t.clientHeight);i=i||[1,1,1],super({vertexShader:Ta.popupVertexShader,fragmentShader:Ta.popupFragmentShader,type:"CV.PopupMaterial",uniforms:{rotate:{value:l},popupImage:{value:e},scale:{value:h}},defines:{USE_COLOR:!0}}),this.opacity=1,this.alphaTest=.8,this.depthTest=!1,this.transparent=!0,this.texture=e,this.defaultAttributeValues.color=i}}class uM extends Ie{constructor(){super(),this.type="PopupGeometry",this.setIndex(pa.index),this.setAttribute("position",pa.position)}}let dM=null;class pM extends Tn{constructor(t){null===dM&&(dM=new uM),super(dM),this.layers.set(1),this.type="Popup",this.renderOrder=1/0,this.ctx=t}close(){this.parent&&this.parent.remove(this);const t=this.materal;t&&(t.dispose(),t.texture&&t.texture.dispose())}}class fM extends pM{constructor(t){return super(t),this.lines=[],this.type="CanvasPopup",this}addLine(t){return this.lines.push(t),this}finish(){const t=this.ctx.cfg,e=this.ctx.container,n=this.lines,i=n.length,r=32*i,s=document.createElement("canvas");s||console.error("creating canvas for CanvasPopup failed"),s.width=256,s.height=r;const a=s.getContext("2d");a||console.error("cannot obtain 2D canvas"),a.fillStyle=t.themeColorCSS("popup.background"),a.fillRect(0,0,256,r),a.strokeStyle=t.themeColorCSS("popup.border"),a.lineWidth=2,a.strokeRect(0,0,256,r),a.textAlign="left",a.font="20px normal helvetica,sans-serif",a.fillStyle=t.themeColorCSS("popup.text");for(let t=0;t<i;t++)a.fillText(n[t],10,32*(t+1)-6);const o=new Rs(s);o.onUpdate=function(t){t.image=null};const l=new cM(e,o,0);return this.material=l,this.material.needsUpdate=!0,this}}class mM extends fM{constructor(t,e,n,i,r,s,a){super(t);const o=n.getGeographicalPosition(e);let l,h,c=e.getPath(),u=!1,d=null;for(;c.length>20;)l=c.split("."),l.shift(),c=l.join("."),u=!0;if(h=s?e.shortestPath!==1/0?Math.round(e.shortestPath):"unconnected":null,u&&(c="..."+c),this.addLine(c),a&&void 0!==e.messageText)this.addLine(e.messageText);else if(void 0!==r&&(d=r(n.CRS,o,i,h)),null!==d)for(let t=0;t<d.length;t++)this.addLine(d[t]);else this.addLine("x: "+Math.round(o.x)+" m, y: "+Math.round(o.y)+" m").addLine("z: "+Math.round(o.z)+" m"),null!==i&&this.addLine("depth from surface: "+Math.round(i)+" m"),s&&this.addLine("distance: "+h+" m");this.finish(),this.position.copy(e)}}class gM{constructor(t,e){const n=t.shortestPathDistance()<e.shortestPathDistance();this.startStation=n?t:e,this.endStation=n?e:t}start(){return this.startStation}end(){return this.endStation}length(){const t=this.startStation.coordinates(),e=this.endStation.coordinates();return t.distanceTo(e)}}class vM{constructor(t,e){this.station=e,this.survey=t}id(){return this.station.id}name(){return this.station.getPath()}coordinates(){return this.survey.getGeographicalPosition(this.station)}connectionCount(){return this.station.connections}isEntrance(){return 2==(2&this.station.type)}adjacentStationIds(){return this.survey.topology.getAdjacentStations(this.station).slice()}shortestPathDistance(){return this.station.shortestPath}forEachConnectedLeg(t){const e=this.survey;e.topology.shortestPathSearch(this.station,((n,i)=>t(new gM(new vM(e,n),new vM(e,i)))))}}class xM extends pM{constructor(t,e,n,i){super(t),this.type="ImagePopup";(new ks).load(n,(function(t){r.material=new cM(r.ctx.container,t,0),r.material.needsUpdate=!0,i()})).onUpdate=function(t){t.image=null},this.position.copy(e);const r=this}}const yM=new lt,_M=new lt,MM=new lt,bM=new lt,wM=new on(yM,_M,MM),SM=new on(yM,MM,bM);class EM extends Tn{constructor(t,e,n,i,r){super(new Ie,t.materials.getSurfaceMaterial()),this.x=e,this.y=n,this.zoom=i,this.tileSet=r.tileSet,this.clip=r.clip,this.clippedFraction=r.clippedFraction,this.canZoom=i<r.tileSet.overlayMaxZoom,this.evicted=!1,this.replaced=!1,this.evictionCount=0,this.lastFrame=0,this.childrenLoading=0,this.childErrors=0,this.area=0,this.boundingBox=null,this.worldBoundingBox=null,this.type="Tile",this.isTile=!1}}function TM(t,e){this.CRS=e,this.transform=_x(e,"EPSG:4326"),this.transformedLimits=null;const n="https://api.cesium.com/v1/assets/1/endpoint?access_token="+t.cfg.value("cesiumAccessToken","no access token");return new Promise(((t,e)=>{(new Gs).setResponseType("text").load(n,(e=>{const n=JSON.parse(e);this.url=n.url,this.accessToken=n.accessToken,this.attributions=n.attributions,TM.defaultTileSet.valid=!0,t(this)}),(function(){}),(()=>{console.warn("cesium api error"),e(this)}))}))}EM.liveTiles=0,EM.prototype.onBeforeRender=function(t){this.lastFrame=t.info.render.frame},EM.prototype.createFromTileData=function(t,e){const n=t.attributes,i=t.index,r=t.boundingBox,s=this.geometry;let a,o;for(a in n)o=n[a],s.setAttribute(a,new ae(o.array,o.itemSize));return s.setIndex(new re(i,1)),s.boundingBox=new ut(new lt(r.min.x,r.min.y,r.min.z),new lt(r.max.x,r.max.y,r.max.z)),this.boundingBox=s.boundingBox,this.dropBuffers(),this.layers.set(7),this.material=e,this.isTile=!0,this.canZoom=t.canZoom&&this.canZoom,null===this.worldBoundingBox&&(this.updateWorldMatrix(!0,!1),this.worldBoundingBox=this.boundingBox.clone().applyMatrix4(this.matrixWorld)),this},EM.prototype.empty=function(){this.isMesh=!1,this.geometry&&(this.geometry.dispose(),this.geometry=new Ie),--EM.liveTiles},EM.prototype.evict=function(){this.evicted=!0,this.replaced=!1,this.evictionCount=0,this.children.forEach((t=>t.evict())),this.empty()},EM.prototype.setReplaced=function(){this.evicted=!1,this.replaced=!0,this.empty()},EM.prototype.setSkipped=function(){this.parent.childrenLoading--,this.evicted=!1,this.replaced=!0},EM.prototype.setPending=function(t){t&&null===this.parent&&t.addStatic(this),this.parent.childrenLoading++,this.isMesh=!1,this.evicted=!1,this.replaced=!1,this.evictionCount=0},EM.prototype.setFailed=function(){const t=this.parent;t.childErrors++,t.childrenLoading--,t.canZoom=!1,t.remove(this)},EM.prototype.setLoaded=function(t,e){const n=this.parent;let i=0;if(0==--n.childrenLoading){if(0===n.childErrors)return n.isTile&&n.setReplaced(),n.children.forEach((n=>{n.replaced||n.evicted||(null===t?(n.isMesh=!0,EM.liveTiles++):(i++,n.setOverlay(t).then((t=>{t.isMesh=!0,EM.liveTiles++,0==--i&&e(this.canZoom)}))))})),void(0===i&&e(!1));n.remove(this)}e(!1)},EM.prototype.removed=function(){this.geometry&&this.geometry.dispose()},EM.prototype.setMaterial=function(t){this.material=t},EM.prototype.setThroughMode=function(t){this.isTile&&this.isMesh&&this.material.setThroughMode(t)},EM.prototype.setOverlay=function(t){return t.getTile(this.x,this.y,this.zoom).then((e=>(null!==e&&(this.material=e,e.setThroughMode(t.throughMode)),this)))},EM.prototype.computeProjectedArea=function(t){const e=this.worldBoundingBox,n=e.max.z;return yM.copy(e.min).setZ(n),MM.copy(e.max),_M.set(yM.x,MM.y,n),bM.set(MM.x,yM.y,n),yM.project(t),_M.project(t),MM.project(t),bM.project(t),this.area=(wM.getArea()+SM.getArea())/this.clippedFraction,this},TM.defaultTileSet={title:"Cesium",initialZoom:12,overlayMaxZoom:16,maxZoom:17,minZoom:10,divisions:1,subdirectory:null,dtmScale:64,minX:0,maxX:2048,minY:0,maxY:1023,attributions:[],log:!0,valid:!1},TM.prototype.workerScript="webMeshWorker.js",TM.prototype.getTileSets=function(){return[TM.defaultTileSet]},TM.prototype.getScreenAttribution=function(){const t=this.attributions;if(0===t.length)return null;const e=document.createElement("div");e.classList.add("overlay-branding");for(let n=0;n<t.length;n++){const i=t[n];e.innerHTML=i.html;break}return e},TM.prototype.getCoverage=function(t,e){const n={zoom:e};null===this.transformedLimits&&(this.transformedLimits=new ca);const i=this.transformedLimits;i.expandByPoint(this.transform.forward(t.min.clone())),i.expandByPoint(this.transform.forward(t.max.clone()));const r=i.min,s=i.max,a=Math.pow(2,e)/180;return n.minX=Math.floor((r.x- -180)*a),n.maxX=Math.floor((s.x- -180)*a),n.minY=Math.floor((r.y- -90)*a),n.maxY=Math.floor((s.y- -90)*a),n.count=(n.maxX-n.minX+1)*(n.maxY-n.minY+1),n},TM.prototype.getTileSpec=function(t,e,n,i){const r=new ca,s=180/Math.pow(2,n);if(r.min.x=t*s-180,r.min.y=e*s-90,r.max.x=(t+1)*s-180,r.max.y=(e+1)*s-90,!this.transformedLimits.intersectsBox(r))return null;const a=new $;return r.clone().intersect(this.transformedLimits).getSize(a),{tileSet:this.tileSet,divisions:1,resolution:s,x:t,y:e,z:n,clip:i,offsets:null,flatZ:null,displayCRS:this.CRS,url:this.url,accessToken:this.accessToken,clippedFraction:a.x*a.y/s*s,request:"tile"}};const LM=6378137*Math.PI;var CM;function AM(t){return new Promise((e=>{(new Gs).setResponseType("text").load(t.cfg.value("terrainDirectory","")+"/tileSets.json",(t=>{(CM=JSON.parse(t)).push(AM.defaultTileSet),e(this)}),(function(){}),(()=>{CM=[AM.defaultTileSet],e(this)}))}))}AM.defaultTileSet={isFlat:!0,title:"flat",overlayMaxZoom:18,maxZoom:16,minZoom:10,divisions:128,subdirectory:null,dtmScale:64,minX:0,maxX:1023,minY:0,maxY:1023,attributions:[],log:!0},AM.prototype.workerScript="webTileWorker.js",AM.prototype.getTileSets=function(){return CM},AM.prototype.getScreenAttribution=function(){return null},AM.prototype.getCoverage=function(t,e){const n={zoom:e},i=LM,r=-LM,s=Math.pow(2,e-1)/LM;return n.minX=Math.floor((t.min.x-r)*s),n.maxX=Math.floor((t.max.x-r)*s),n.maxY=Math.floor((i-t.min.y)*s),n.minY=Math.floor((i-t.max.y)*s),n.count=(n.maxX-n.minX+1)*(n.maxY-n.minY+1),n},AM.prototype.getTileSpec=function(t,e,n,i){const r=this.tileSet,s=n>r.maxZoom?Math.pow(2,r.maxZoom-n):1;if(1!==s&&null===this.activeOverlay)return null;this.log&&console.log("load: [ ",n+"/"+t+"/"+e,"]");const a=LM/Math.pow(2,n-1),o={top:0,bottom:0,left:0,right:0},l=a*t-LM,h=l+a,c=LM-a*e,u=c-a,d=r.divisions*s,p=a/d;if(c>i.max.y&&(o.top=Math.floor((c-i.max.y)/p)),u<i.min.y&&(o.bottom=Math.floor((i.min.y-u)/p)),l<i.min.x&&(o.left=Math.floor((i.min.x-l)/p)),h>i.max.x&&(o.right=Math.floor((h-i.max.x)/p)),o.top>=d||o.bottom>=d||o.left>=d||o.right>=d)return null;return{tileSet:r,divisions:d,resolution:p,x:t,y:e,z:n,clip:o,offsets:null,flatZ:null,clippedFraction:(d-o.top-o.bottom)*(d-o.left-o.right)/(d*d),request:"tile"}},AM.prototype.findTile=function(t){const e=this.tileSet,n=LM/Math.pow(2,e.maxZoom-1),i=(t.x+LM)/n,r=(LM-t.y)/n,s=Math.floor(i),a=Math.floor(r),o=e.maxZoom,l=i-s,h=r-a,c=e.divisions+1;return{x:s,y:a,z:o,tileSet:e,dataOffsets:[Math.floor(c*l)+c*Math.floor(c*h)],points:[t],request:"height",clip:{}}};const RM=new Ot,PM=new Ut,DM={type:"progress",name:"start"},IM={type:"progress",name:"end"};function NM(t,e){const n=e.zoom-t.zoom;if(0!==n)return n;const i=t.lastFrame-e.lastFrame;if(0!==i)return i;const r=t.x-e.x;return 0!==r?r:t.y-e.y}class zM extends Q_{constructor(t,e,n){let i;switch(super(t),this.name="WebTerrain",this.type="CV.WebTerrain",this.attributions=[],this.log=!1,this.ctx=t,this.displayCRS=e.displayCRS,this.surveyCRS=e.CRS,this.limits=e.limits,this.flatZ=e.modelLimits.max.z,this.offsets=e.offsets,this.onLoaded=n,this.childrenLoading=0,this.childErrors=0,this.isLoaded=!1,this.material=null,this.initialZoom=null,this.dying=!1,this.tilesLoading=0,this.maxTilesLoading=0,this.overlaysLoading=0,this.debug=!0,this.coverage=null,this.TS=null,this.maxTiles=t.cfg.value("maxTiles",128),this.retile_timeout=80,this.retileScaler=4,this.lastActivityTime=0,this.timerId=null,this.material=t.materials.getCursorMaterial(),this.canZoom=!0,this.watcher=this.scheduleRetile.bind(this),this.updateFunc=zM.prototype.zoomCheck.bind(this),this.displayCRS){case"EPSG:3857":i=new AM(t);break;case"EPSG:4326":case"ORIGINAL":i=new TM(t,this.surveyCRS);break;default:return void n(this)}i.then((e=>{this.workerPool=t.workerPools.getPool(e.workerScript),this.TS=e,this.tileSets=e.getTileSets(),this.screenAttribution=e.getScreenAttribution(),this.hasCoverage()?this.tileArea(this.limits):(console.log("no terrain found"),n(this))})).catch((()=>{console.log("error loading tile set")}))}}zM.prototype.isTiled=!0,zM.prototype.hasCoverage=function(){const t=this.limits,e=this.ctx.cfg.value("terrainDirectory",""),n=this.tileSets,i=this.TS;for(let r=0,s=n.length;r<s;r++){const s=n[r];if(!1===s.valid)continue;const a=i.getCoverage(t,s.minZoom);if(a.minX>=s.minX&&a.maxX<=s.maxX&&a.minY>=s.minY&&a.maxY<=s.maxY)return s.directory=e+s.subdirectory,i.tileSet=s,this.isFlat=s.isFlat,this.log=void 0!==s.log&&s.log,this.attributions=s.attributions,console.log("selected tile set:",s.title),!0}return!1},zM.prototype.loadTile=function(t,e,n,i,r){void 0===r&&(r=i.children.find((function(i){return i.x===t&&i.y===e&&i.zoom===n})));const s=this,a=this.TS.getTileSpec(t,e,n,this.limits);if(null===a)return;a.offsets=this.offsets,a.flatZ=this.flatZ,0===this.tilesLoading&&(this.dispatchEvent(DM),this.maxTilesLoading=0),this.maxTilesLoading=Math.max(this.maxTilesLoading,++this.tilesLoading),this.log&&console.log("load: [ ",n+"/"+t+"/"+e,"]",this.tilesLoading);const o=r||new EM(this.ctx,t,e,n,a);return o.setPending(i),void this.workerPool.runWorker(a,(function(t){if(--s.tilesLoading,s.dying)return void s.dispatchEvent(IM);if("zoom"===t.status)return o.setSkipped(),void s.zoomTile(o,o.parent);if("ok"!==t.status||0!==o.parent.childErrors)return o.setFailed(),0!==s.tilesLoading||s.isLoaded||s.onLoaded(s),void s.dispatchEvent(IM);o.createFromTileData(t,s.material),s.dispatchEvent({type:"progress",name:"set",progress:100*(s.maxTilesLoading-s.tilesLoading)/s.maxTilesLoading}),o.setLoaded(s.activeOverlay,l)}));function l(t){t&&null!==s.activeOverlay&&o.zoom<s.activeOverlay.getMinZoom()&&s.zoomTile(o),0===s.tilesLoading&&(s.dispatchEvent(IM),s.isLoaded||(s.isLoaded=!0,s.onLoaded(s)))}},zM.prototype.tileArea=function(t){const e=this.TS.tileSet;let n,i=e.initialZoom||e.overlayMaxZoom+1;do{n=this.TS.getCoverage(t,--i)}while(n.count>4&&i>e.minZoom);this.initialZoom=i,this.coverage=n;for(let t=n.minX;t<n.maxX+1;t++)for(let e=n.minY;e<n.maxY+1;e++)this.loadTile(t,e,i,this)},zM.prototype.tileSet=function(){const t=Object.assign({},AM.defaultTileSet),e=this.coverage;return delete t.isFlat,delete t.directory,t.title="new tile set",t.subdirectory="new_tile_set",t.minZoom=e.zoom,t.minX=e.minX,t.maxX=e.maxX,t.minY=e.minY,t.maxY=e.maxY,Kg(t)},zM.prototype.zoomTile=function(t,e=t){const n=t.zoom+1,i=2*t.x,r=2*t.y;this.loadTile(i,r,n,e),this.loadTile(i+1,r,n,e),this.loadTile(i,r+1,n,e),this.loadTile(i+1,r+1,n,e)},zM.prototype.setOverlay=function(t,e){if(this.tilesLoading>0)return;const n=this.activeOverlay,i=t.throughMode;if(null!==n){if(n===t)return void this.traverse((t=>t.setThroughMode(i)));n.setInactive()}t.setActive(),this.activeOverlay=t;const r=t.getMinZoom();this.traverse((n=>{n.isTile&&n.isMesh&&(n.zoom<r?this.zoomTile(n):(this.overlaysLoading++,n.setOverlay(t).then((()=>{0==--this.overlaysLoading&&e()}))))}))},zM.prototype.removed=function(){this.dying=!0,this.traverse((t=>{t!==this&&t.removed(t)})),this.commonRemoved()},zM.prototype.setMaterial=function(t){this.tilesLoading>0||(this.traverse((e=>{e.isTile&&e.setMaterial(t)})),this.activeOverlay=null,t.needsUpdate=!0,t.fog=!1,this.material=t)},zM.prototype.zoomCheck=function(t){if(performance.now()-this.lastActivityTime<this.retile_timeout)return;if(this.tilesLoading>0)return!0;const e=RM,n=t.activeCamera,i=t.getLastFrame(),r=[],s=[],a=[];let o=!1;e.setFromProjectionMatrix(PM.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse)),this.traverse((function(t){const o=t.parent;if(!t.isTile||!o.canZoom)return;t.isMesh&&t.canZoom&&t.lastFrame===i?(t.computeProjectedArea(n),t.area/4>.81&&r.push(t)):!o.isMesh&&t.evicted&&e.intersectsBox(t.worldBoundingBox)?(t.traverse((function(e){e!==t&&(e.evicted=!1,e.replaced=!0)})),a.push(t)):t.isMesh&&t.lastFrame!==i&&s.push(t)}));const l=a.length,h=r.length,c=s.length;let u=EM.liveTiles-this.maxTiles;if(Math.min(c,u)>0){s.sort(NM);const t=performance.now(),e=s.length;for(let n=0;n<e;n++){const e=s[n];if(0===e.evictionCount)e.evictionCount=t;else if(t-e.evictionCount>1e3&&(e.evict(),--u))break}}if(0!==l){for(let t=0;t<l;t++){const e=a[t];this.loadTile(e.x,e.y,e.zoom,e.parent,e)}o=!0}else if(0!==h){for(let t=0;t<h;t++)this.zoomTile(r[t]);o=!0}return void(o&&(this.timerId=setTimeout(this.updateFunc,this.retile_timeout*this.retileScaler,t),this.retileScaler*=2))},zM.prototype.getHeights=function(t,e){const n=this.TS,i={},r=[];t.forEach((function(t,e){const r=n.findTile(t),s=r.x+":"+r.y+":"+r.z;t.index=e,void 0===i[s]?i[s]=r:(i[s].dataOffsets.push(r.dataOffsets[0]),i[s].points.push(r.points[0]))}));let s=0;for(const t in i)this.workerPool.runWorker(i[t],a),s++;return;function a(t){t.points.forEach((t=>r[t.index]=t)),0==--s&&e(r)}},zM.prototype.fitSurface=function(t,e){if(void 0===this.TS.findTile)return void this._fitSurface(t);const n=t.map((t=>t.clone().add(e)));this.getHeights(n,(t=>{let e=0,i=0,r=0;t.forEach((t=>{const s=n[t.index].z-t.z;i+=s,r+=s*s,e++}));const s=Math.sqrt(r/e-Math.pow(i/e,2));this.datumShift=i/e,console.log("Adjustmenting terrain height by:",this.datumShift,"sd:",s)}))},zM.prototype.scheduleRetile=function(t){this.visible&&(null!==this.timerId&&clearTimeout(this.timerId),this.retileScaler=4,this.lastActivityTime=performance.now(),this.timerId=setTimeout(this.updateFunc,this.retile_timeout,t.cameraManager))},zM.prototype.watch=function(t){t.addEventListener("moved",this.watcher)},zM.prototype.unwatch=function(t){t.removeEventListener("moved",this.watcher)};var FM="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},OM={exports:{}},UM={exports:{}};!function(t,e){(function(){var e,n,i,r;i=function(t,e){return Object.prototype.toString.call(e).match(/\s(\w+)/)[1].toLowerCase()===t},n=function(t){return!!t&&i("object",t)},r=function(t){return i("array",t)?t:[t]},e=function(){function t(){this.__eventStore={},this.__asyncEvents=!0}return t.mixin=function(e){var n,i,r,s;for(i in e.__eventStore={},s=[],r=t.prototype)n=r[i],s.push(e[i]=n);return s},t.prototype.on=function(t,e,i){var s,a,o,l,h;if(null==i&&(i=!1),n(t))for(h in t)e=t[h],this.on(h,e);else for(a=0,o=(l=r(t)).length;a<o;a++)h=l[a],(s=this.__eventStore)[h]||(s[h]=[]),this.__eventStore[h].push({fn:e,once:i});return this},t.prototype.once=function(t,e){return e?this.on(t,e,!0):this.on(t,!0)},t.prototype.off=function(t,e){var i,s,a,o,l,h,c;if(!e)for(i=0,a=(l=r(t)).length;i<a;i++)c=l[i],this.__eventStore[c]=[];if(n(t))for(c in t)e=t[c],this.off(c,e);else for(s=0,o=(h=r(t)).length;s<o;s++)c=h[s],this.__eventStore[c]=(this.__eventStore[c]||[]).filter((function(t){return t.fn!==e}));return this},t.prototype.trigger=function(t,e){var n,i;return e||(e=[]),null!=(n=this.__eventStore[t])&&n.forEach((i=this,function(n){var r,s;if(r=n.fn,s=n.once,i.__asyncEvents?setTimeout((function(){return r.apply(null,e)}),1):r.apply(null,e),s)return i.off(t,r)})),this},t}(),t.exports=e}).call(FM)}(UM),function(t,e){(function(){var e,n,i,r;i=function(t,e){return Object.prototype.toString.call(e).match(/\s(\w+)/)[1].toLowerCase()===t},n=function(t){return!!t&&i("object",t)},r=function(t){return i("array",t)?t:[t]},e=function(){function t(){this.__eventStore={},this.__asyncEvents=!0}return t.mixin=function(e){var n,i,r,s;for(i in e.__eventStore={},s=[],r=t.prototype)n=r[i],s.push(e[i]=n);return s},t.prototype.on=function(t,e,i){var s,a,o,l,h;if(null==i&&(i=!1),n(t))for(h in t)e=t[h],this.on(h,e);else for(a=0,o=(l=r(t)).length;a<o;a++)h=l[a],(s=this.__eventStore)[h]||(s[h]=[]),this.__eventStore[h].push({fn:e,once:i});return this},t.prototype.once=function(t,e){return e?this.on(t,e,!0):this.on(t,!0)},t.prototype.off=function(t,e){var i,s,a,o,l,h,c;if(!e)for(i=0,a=(l=r(t)).length;i<a;i++)c=l[i],this.__eventStore[c]=[];if(n(t))for(c in t)e=t[c],this.off(c,e);else for(s=0,o=(h=r(t)).length;s<o;s++)c=h[s],this.__eventStore[c]=(this.__eventStore[c]||[]).filter((function(t){return t.fn!==e}));return this},t.prototype.trigger=function(t,e){var n,i;return e||(e=[]),null!=(n=this.__eventStore[t])&&n.forEach((i=this,function(n){var r,s;if(r=n.fn,s=n.once,i.__asyncEvents?setTimeout((function(){return r.apply(null,e)}),1):r.apply(null,e),s)return i.off(t,r)})),this},t}(),t.exports=e}).call(FM),function(){var e,n,i={}.hasOwnProperty,r=[].slice,s=[].indexOf||function(t){for(var e=0,n=this.length;e<n;e++)if(e in this&&this[e]===t)return e;return-1};n=function(t){var e;return e=function(t){function e(){var t,n,i;this.t=(t=this.t,n=this,function(){return t.apply(n,arguments)}),e.__super__.constructor.call(this),this.dict={},this.defaultlocal="en",this.chosenLocal=void 0,this.availableLocales=[],this.locales=[],this.missingTranslations={},this.on("dict:change",(i=this,function(){return i.sortLocales()}))}return function(t,e){for(var n in e)i.call(e,n)&&(t[n]=e[n]);function r(){this.constructor=t}r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype}(e,t),e.prototype.utils={merge:function(t,e){var n,i,r;for(n in i=[],e)"object"==typeof(r=e[n])&&"object"==typeof t[n]?i.push(this.merge(t[n],r)):i.push(t[n]=r);return i},filter:function(t,e){var n,i,r,s;for(r=[],n=0,i=t.length;n<i;n++)e(s=t[n])&&r.push(s);return r},unique:function(t){var e,n,i,r,s,a;for(s={},e=0,i=t.length;e<i;e++)s[a=t[e]]=a;for(n in r=[],s)a=s[n],r.push(a);return r},getByDotNotation:function(t,e){var n;for(n=e.split(".");0!==n.length&&void 0!==t;)t=t[n[0]],n.shift();return t},isPlainObject:function(t){return!!t&&"[object Object]"===Object.prototype.toString.call(t)}},e.prototype.register=function(t,e){return t in this.dict||(this.dict[t]={},this.availableLocales.push(t)),this.utils.merge(this.dict[t],e),this.trigger("dict:change",[t])},e.prototype.set=function(t){return this.chosenLocal=t,this.sortLocales()},e.prototype.setDefault=function(t){return this.defaultLocal=t,this.sortLocales()},e.prototype.detectLocal=function(){return navigator.userLanguage||navigator.language},e.prototype.similiarLocales=function(t){return t=String(t).slice(0,2).toLowerCase(),this.utils.filter(this.availableLocales,(function(e){return t!==e&&0===e.toLowerCase().indexOf(t)}))},e.prototype.sortLocales=function(){var t,e,n,i,a,o;for(o=this.locales.slice(),a=[],e=0,n=(t=[this.chosenLocal].concat(r.call(this.similiarLocales(this.chosenLocal)),[this.detectLocal()],r.call(this.similiarLocales(this.detectLocal())),[this.defaultLocal],r.call(this.similiarLocales(this.defaultlocal)),["en"],r.call(this.similiarLocales("en")))).length;e<n;e++)i=t[e],s.call(this.availableLocales,i)>=0&&a.push(i);if(a.push.apply(a,this.availableLocales),this.locales=this.utils.unique(a),o.join(",")!==this.locales.join(","))return this.trigger("lang:change",[this.locales,o])},e.prototype.interpolate=function(){var t,e;return e=arguments[0],t=2<=arguments.length?r.call(arguments,1):[],e=this.utils.isPlainObject(t[0])?e.replace(/%\{([^}]+)\}/g,(function(e,n){return t[0][n]})):e.replace(/%(\d+)/g,(function(e,n){return t[Number(n)-1]}))},e.prototype.t=function(){var t,e,n,i,s,a,o,l;for(n=arguments[0],e=2<=arguments.length?r.call(arguments,1):[],o=void 0,t=0,i=(a=this.locales).length;t<i&&(s=a[t],!(o=this.utils.getByDotNotation(this.dict[s],n)));t++)s in this.missingTranslations||(this.missingTranslations[s]=[]),this.missingTranslations[s].push(n),this.missingTranslations[s]=this.utils.unique(this.missingTranslations[s]),this.trigger("missing-translation",[s,n]);return"string"==typeof o?o=this.interpolate.apply(this,[o].concat(r.call(e))):void 0!==o&&(o.plural=(l=this,function(t){return t in o?o[t]:l.interpolate(o.n,t)})),o},e}(t),new e},null!==t&&null!=t.exports?(e=UM.exports,t.exports=n(e)):window.x18n=n(window.Observable)}.call(FM)}(OM);var BM=OM.exports;var kM={settings:{title:"Settings",survey:{header:"Survey",caption:"File"},view:{header:"View",camera:{caption:"Camera type",orthographic:"Orthographic",perspective:"Perspective",anaglyph:"Anaglyph"},viewpoints:{caption:"Viewpoint",none:"<select viewpoint>",plan:"Plan",elevation_n:"N Elevation",elevation_s:"S Elevation",elevation_e:"E Elevation",elevation_w:"W Elevation"},eye_separation:"Eye Separation",vertical_scaling:"Vertical Scaling",linewidth:"Line width",autorotate:"Auto Rotate",rotation_speed:"Rotation Speed"},shading:{header:"Shading",caption:"Underground legs",height:"by height",length:"by leg length",inclination:"by leg inclination",height_cursor:"height cursor",fixed:"fixed",survey:"survey",route:"route",depth:"depth",depth_cursor:"depth cursor",distance:"distance",beck:"beck"},selected_route:"Selected route",no_routes:"no routes defined",visibility:{header:"Visibility",legs:"Center lines",entrances:"Entrance labels",entrance_dots:"Entrance dots",stations:"Stations",labels:"Station Labels",comments:"Station Comments",walls:"Walls (LRUD)",scraps:"Scraps",splays:"Splay Legs",duplicates:"Duplicate Legs",traces:"Dye Traces",warnings:"Warnings",box:"Bounding box",hud:"Indicators",fog:"Fog",grid:"Grid"},controls:{header:"Controls",svx_control_mode:"'Aven' controls",zoom_to_cursor:"Zoom to cursor",wheel_tilt:"Mouse wheel - tilt"},ui:{selection_tree:"Use tree selection"},colors:{header:"Colours",background_color:"Background",entrance_text:"Entrance text",entrance_background:"Entrance background",entrance_marker:"Entrance marker",bounding_box:"Bounding box",legs_fixed:"Passage lines (fixed)",surface_fixed:"Surface lines (fixed)",duplicate_fixed:"Duplicate lines (fixed)",hud_text:"Scale text",defaults:"Restore default colours"}},surface:{title:"Surface",surface:{header:"Surface Features",legs:"Surface Legs",shading:{caption:"Shading",height:"by height",inclination:"by inclination",height_cursor:"height cursor",fixed:"fixed"}},terrain:{header:"Terrain",terrain:"Terrain visible",shading:{caption:"Shading",relief:"relief shading",height:"by height",overlay:"map overlay",contours:"contours"},overlay:{caption:"Overlay"},opacity:"Opacity",datum_shift:"Vertical datum shift",lighting:"Directional Lighting",downloadTileSet:"download tile set spec"}},selection:{title:"Selection",header:"Selection"},edit:{title:"Edit",mode:"edit mode",intro:"select edit mode",modes:{none:"- none -",route:"Routes",trace:"Traces",entrances:"Entrances"},entrance:{header:"Entrances"},route:{header:"Routes",current:"Current route",save:"Save",new:"New route",add:"Add",download:"Download"},trace:{header:"Traces",start:"Start",end:"End"}},info:{title:"Information",header:"Information",file:"file",more:"For more information see",summary:"A WebGL 3d cave viewer for Survex (.3d), Therion (.lox) and Compass (.plt) models.",github:"CaveView on GitHub",stats:{header:"Survey Stats",legs:"Leg count",totalLength:"Total length",minLength:"Shortest leg",maxLength:"Longest leg",splayCount:"Splay leg count",surfaceCount:"Surface leg count",duplicateCount:"Duplicate leg count"}},help:{title:"Help",header_svx:"Key commands (survex)",header_native:"Key commands (native)",shading:{header:"Shading",height:"height",inclination:"leg inclination",length:"leg length",height_cursor:"height cursor",single:"single colour",survey:"survey section",route:"route",depth:"depth below surface",depth_cursor:"depth cursor",cursor_up:"move cursor up",cursor_down:"move cursor down",distance:"distance",flat:"Flat shading"},view:{header:"View",full_screen:"toggle full screen",orthogonal:"orthogonal view",perspective:"perspective view",reset:"reset to inital view",center:"center on selected feature",next:"next cave",plan:"plan",elevation:"elevation",north:"face north",east:"face east",south:"face south",west:"face west",rotate_clockwise:"rotate clockwise",rotate_anticlockwise:"rotate anticlockwise",zoom_in:"zoom in",zoom_out:"zoom out",auto_rotate:"rotate continuosly",rotate_speed_up:"increase speed of rotation",rotate_speed_down:"decrease speed of rotation",reverse_rotation:"reverse direction of rotation",zoom_to_cursor:"toggle zoom to cursor mode",control_mode:"toggle control mode",decrease_focal_length:"decrease focal length",increase_focal_length:"increase focal length"},visibility:{header:"Visibility",scraps:"scraps on/off [lox only]",station_labels:"station labels on/off",entrance_labels:"entrance labels on/off",splays:"splay legs on/off",survey:"underground legs on/off",surface:"surface legs on/off",terrain:"terrain on/off",walls:"LRUD walls on/off",stations:"station markers on/off",opacity_down:"decrease terrain opacity",opacity_up:"increase terrain opacity"},selection:{header:"Selection",remove:"remove all except selected section"}},exports:{title:"Exports",gltf_export:{header:"glTF Export",walls:"include LRUD walls",scraps:"include scraps",legs:"include centre lines",rotate_axes:"rotate axes",export:"Download"},png_export:{header:"Image (PNG) Export",export:"Snapshot",size:"Size (px)",line_scale:"Line scale"}},hud:{height:"height",leg_length:"leg length",depth:"depth",inclination:"inclination"},dnd:{splash_text:"Drag&nbsp;and&nbsp;drop a .3d or .lox model here to&nbsp;load"}};const HM={fieldOfView:50,background:"black",sky:1077133,maxPolarAngle:180,saturatedGradient:!1,lighting:{azimuth:315,inclination:45},entrance_dot_size:5,hud:{font:"normal Arial, sans-serif",text:"white",progress:"green",progressBackground:"dimgray",bezel:"gray",widgetSize:40,scale:{bar1:"white",bar2:"red"},compass:{top1:11549204,top2:1750245,bottom1:5774602,bottom2:807786},ahi:{sky:1077133,earth:8397056,bar:"yellow",marks:"white"},cursor:"yellow"},box:{bounding:"white",select:"blue",highlight:"red"},routes:{active:"yellow",adjacent:"red",default:"gray"},stations:{font:"normal Arial, sans-serif",entrances:{text:"white",background:"darkred",marker:"white",angle:45},junctions:{text:"yellow",marker:"yellow"},default:{text:"white",marker:"red"}},shading:{single:"red",surface:"yellow",duplicate:"white",cursor:"yellow",cursorBase:"gray",unselected:"gray",contours:{line:14793634,line10:15900002,interval:10,base:"white"},unconnected:"gray"},popup:{text:"white",border:"white",background:1118481},grid:{base:"gray"}};BM.register("en",kM),BM.set("en");class GM extends d{constructor(t){if(super(),this.environment=new Map,this.themeColors=new Map,this.i18n=BM.t,void 0!==t){for(const e in t)this.environment.set(e,t[e]);void 0!==GM.home&&this.environment.set("home",GM.home),this.setLanguage(this.value("language",navigator.language.slice(0,2)))}}setLanguage(t){if(console.log("home:",GM.home),"en"===t)BM.set("en");else{console.log("loading language file for:",t);(new Gs).setPath(this.value("home")+"lib/").load("lang-"+t+".json",(function(e){console.log("loaded language ["+t+"]"),BM.register(t,JSON.parse(e)),BM.set(t)}),null,(function(){console.log("error loading language file",t)}))}const e=this;return void BM.on(["lang:change"],(function(){e.dispatchEvent({type:"change",name:"language"})}))}value(t,e){return this.environment.has(t)?this.environment.get(t):e}setPropertyValue(t,e){this.environment.set(t,this.value(t,e)),Object.defineProperty(this,t,{set:function(e){this.environment.set(t,e),this.dispatchEvent({type:"change",name:t})},get:function(){return this.environment.get(t)}})}themeValue(t){const e=this.environment.get("theme"),n=t.split(".");let i;return void 0!==e&&(i=this.treeValue(e,n)),void 0===i&&(i=this.treeValue(HM,n)),i}themeAngle(t){return this.themeValue(t)*j}treeValue(t,e){let n=t;for(let t=0;t<e.length;t++){const i=e[t];if(void 0===n[i])return;n=n[i]}return n}themeColorCSS(t){return this.themeColor(t).getStyle()}themeColor(t){let e=this.themeColors.get(t);if(void 0===e){const n=window.localStorage.getItem("cv-color:"+t);e=new te(n||this.themeValue(t)),this.themeColors.set(t,e)}return e}themeColorHex(t){return"#"+this.themeColor(t).getHexString()}setThemeColorCSS(t,e){const n=window.localStorage,i=new te(e);this.themeColors.set(t,i),n.setItem("cv-color:"+t,"#"+i.getHexString()),this.dispatchEvent({type:"colors",name:t})}resetColors(){this.themeColors.clear(),window.localStorage.clear(),this.dispatchEvent({type:"colors",name:"all"})}}function VM(t){this.script=t,this.workers=[],this.activeWorkers=new Set}void 0!==document.currentScript&&(GM.home=document.currentScript.src.match(/^(.*\/)js\//)[1]);const WM=window.navigator.hardwareConcurrency;VM.maxActive=void 0===WM?4:WM,VM.pendingWork=[],VM.activeWorkers=0,VM.prototype.terminateActive=function(){const t=this.activeWorkers;t.forEach((t=>t.terminate())),t.clear(),VM.pendingWork=VM.pendingWork.filter((t=>t.pool!=this)),this.workers.forEach((t=>{t.onmessage=null}))},VM.prototype.getWorker=function(){let t;return t=0===this.workers.length?new Worker(this.script):this.workers.pop(),this.activeWorkers.add(t),t.pool=this,t},VM.prototype.putWorker=function(t){this.activeWorkers.delete(t),this.workers.length<4?this.workers.push(t):t.terminate();const e=VM.pendingWork;if(e.length>0){const t=e.shift();t.pool.queueWork(t.message,t.callback)}},VM.prototype.runWorker=function(t,e){VM.activeWorkers++;const n=this.getWorker();return n.onmessage=t=>{n.pool.putWorker(n),e(t.data)},n.postMessage(t),n},VM.prototype.queueWork=function(t,e){VM.activeWorkers!==VM.maxActive?this.runWorker(t,e):VM.pendingWork.push({pool:this,message:t,callback:e})},VM.prototype.dispose=function(){this.workers.forEach((t=>t.terminate())),this.workers=null,this.activeWorkers=null};class jM{constructor(t){const e=new Map;this.getPool=function(n){const i=t.value("home","")+"js/workers/"+n;let r=e.get(i);return void 0===r&&(r=new VM(i),e.set(i,r)),r},this.terminateActive=function(){e.forEach((t=>t.terminateActive()))},this.dispose=function(){e.forEach((t=>{t.terminateActive(),t.dispose()})),e.clear()}}}const XM={autoRotate:!1,autoRotateSpeed:.5,box:!0,cameraType:2,view:1,editMode:0,shadingMode:1,surfaceShading:1,duplicateShading:18,linewidth:0,terrainShading:8,terrainDirectionalLighting:!0,terrainOpacity:.5,terrainDatumShift:!1,surfaceLegs:!1,walls:!1,scraps:!1,splays:!1,grid:!1,stations:!1,stationLabels:!1,entrances:!0,entrance_dots:!0,terrain:!1,traces:!1,HUD:!0,fog:!1,warnings:!1,fullscreen:!1,zoomToCursor:!0};function qM(t){const e=Object.keys(t),n=[];Object.getOwnPropertyNames(t).forEach((i=>{if(e.includes(i))return;const r=Object.getOwnPropertyDescriptor(t,i);void 0!==r.set&&void 0!==r.get&&n.push(i)})),this.saveState=function(){const e={};return n.forEach((n=>{const i=t[n];"object"!=typeof i&&(e[n]=i)})),e}}const YM=Math.PI/60,ZM=new lt;class JM extends d{constructor(t,e,n){super(),this.cameraManager=t;const i=e;this.enabled=!0,this.target=new lt,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.zoomSpeed=1,this.zoomToCursor=!1,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.wheelTilt=!1;const r=t.activeCamera;this.target0=this.target.clone(),this.position0=r.position.clone(),this.zoom0=r.zoom,this.getPolarAngle=function(){return v.phi},this.getAzimuthalAngle=function(){return v.theta},this.rotateUp=function(t){Z(t),this.update()},this.rotateLeft=function(t){Y(t),this.update()},this.scaleDolly=function(t){y*=t,this.update()},this.saveState=function(){const e=t.activeCamera;s.target0.copy(s.target),s.position0.copy(e.position),s.zoom0=e.zoom},this.reset=function(){const e=t.activeCamera;s.target.copy(s.target0),e.position.copy(s.position0),e.zoom=s.zoom0,e.updateProjectionMatrix(),s.dispatchEvent(a),s.update(),d=u.NONE},this.update=function(){const e=new lt,n=t.activeCamera.up,i=(new ot).setFromUnitVectors(n,new lt(0,1,0)),r=i.clone().invert(),o=new lt,l=new ot;return function(){const n=t.activeCamera,h=s.target,c=n.position;e.copy(c).sub(h),e.applyQuaternion(i),v.setFromVector3(e),s.autoRotate&&d===u.NONE&&Y(2*Math.PI/60/60*s.autoRotateSpeed),v.theta+=x.theta,v.phi+=x.phi,v.theta=Math.max(s.minAzimuthAngle,Math.min(s.maxAzimuthAngle,v.theta)),v.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,v.phi)),v.makeSafe();const p=Math.max(v.radius,g);return v.radius*=y,v.radius=Math.max(s.minDistance,Math.min(s.maxDistance,v.radius)),h.add(_),s.zoomToCursor&&(n.isPerspectiveCamera?s.target.lerp(D,1-v.radius/p):n.isOrthographicCamera&&s.target.lerp(D,1-b)),e.setFromSpherical(v),e.applyQuaternion(r),c.copy(h).add(e),n.lookAt(h),x.set(0,0,0),_.set(0,0,0),y=1,!!(M||o.distanceToSquared(c)>g||8*(1-l.dot(n.quaternion))>g)&&(s.dispatchEvent(a),o.copy(c),l.copy(n.quaternion),M=!1,b=1,!0)}}(),this.dispose=function(){i.removeEventListener("contextmenu",_t,!1),i.removeEventListener("mousedown",dt,!1),i.removeEventListener("wheel",mt,!1),i.removeEventListener("touchstart",vt,!1),i.removeEventListener("touchend",yt,!1),i.removeEventListener("touchmove",xt,!1),document.removeEventListener("mousemove",pt,!1),document.removeEventListener("mouseup",ft,!1),i.removeEventListener("keydown",gt,!1)},this.end=function(){s.dispatchEvent(l)},Object.defineProperty(this,"svxControlMode",{set:X,get:function(){return j}});const s=this,a={type:"change"},o={type:"start"},l={type:"end"};let h=0,c=0;const u={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY_PAN:4};let d=u.NONE;const g=1e-6,v=new la,x=new la;let y=1;const _=new lt;let M=!1,b=1;const w=new $,S=new $,E=new $,T=new $,L=new $,C=new $,A=new $,R=new $,P=new $,D=new lt,I=new lt;let N=!0;const z=new $,F=new $,O=new $;let U,B,k,H,G=0,V=0,W=-1,j=!1;function X(t){t?(U=nt,B=it,k=st,H=at):(U=it,B=rt,k=ht,H=ct),j=t}function q(){return Math.pow(.95,s.zoomSpeed)}function Y(t){x.theta-=t}function Z(t){x.phi-=t}const J=function(t,e){t*=W,ZM.setFromMatrixColumn(e,0),ZM.multiplyScalar(t),_.add(ZM)},Q=function(t,e){t*=W,ZM.setFromMatrixColumn(e,1),ZM.multiplyScalar(-t),_.add(ZM)},K=function(e,n){const r=t.activeCamera;if(r.isPerspectiveCamera){ZM.copy(r.position).sub(s.target);let t=ZM.length();t*=Math.tan(r.fov/2*Math.PI/180),J(2*e*t/i.clientHeight,r.matrix),Q(2*n*t/i.clientHeight,r.matrix)}else r.isOrthographicCamera&&(J(e*(r.right-r.left)/(r.zoom*i.clientWidth),r.matrix),Q(n*(r.top-r.bottom)/(r.zoom*i.clientHeight),r.matrix))};function tt(e){const n=t.activeCamera;n.isPerspectiveCamera?y/=e:n.isOrthographicCamera&&(b=n.zoom,n.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,n.zoom*e)),b/=n.zoom,n.updateProjectionMatrix(),M=!0)}function et(e){const n=t.activeCamera;n.isPerspectiveCamera?y*=e:n.isOrthographicCamera&&(b=n.zoom,n.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,n.zoom/e)),b/=n.zoom,n.updateProjectionMatrix(),M=!0)}function nt(t){z.set(t.clientX,t.clientY),G=0}function it(t){w.set(t.clientX,t.clientY)}function rt(t){A.set(t.clientX,t.clientY)}function st(t){F.set(t.clientX,t.clientY),O.subVectors(F,z);const e=performance.now();e>V+1e3&&(G=0),V=e;const n=O.x*O.x,r=O.y*O.y;switch(G){case 0:G=Math.abs(O.x)>Math.abs(O.y)?1:2;break;case 1:r>8*n&&(G=2);break;case 2:n>8*r&&(G=1)}1===G?(w.copy(z),Y(2*Math.PI*O.x*W/i.clientWidth),w.copy(F),s.update()):function(t){A.copy(z),ct(t,W)}(t),z.copy(F)}function at(t){S.set(t.clientX,t.clientY),E.subVectors(S,w),Z(2*Math.PI*E.y*W/i.clientHeight),w.copy(S),s.update()}function ht(t){S.set(t.clientX,t.clientY),E.subVectors(S,w),Y(2*Math.PI*E.x/i.clientWidth),Z(2*Math.PI*E.y/i.clientHeight),w.copy(S),s.update()}function ct(t,e){R.set(t.clientX,t.clientY),P.subVectors(R,A),P.y*=e,ut(t.clientX,t.clientY),P.y>0?tt(q()):P.y<0&&et(q()),A.copy(R),s.update()}const ut=function(){const e=new lt,i=new lt;return function(r,a){const o=t.activeCamera,l=o.up;let h;const c=t.getMouse(r,a);if(N||I.x!==c.x||I.y!==c.y){const t=n.getStation(c);null!==t&&t.project(o),I.set(c.x,c.y,null===t?.5:t.z),N=!1}o.isPerspectiveCamera?(e.set(c.x,c.y,I.z),e.unproject(o),e.sub(o.position).normalize(),h=i.copy(s.target).sub(o.position).dot(l)/e.dot(l),D.copy(o.position).add(e.multiplyScalar(h))):o.isOrthographicCamera?(e.set(c.x,c.y,(o.near+o.far)/(o.near-o.far)),e.unproject(o),i.set(0,0,-1).applyQuaternion(o.quaternion),h=-e.dot(l)/i.dot(l),D.copy(e).add(i.multiplyScalar(h))):console.warn("WARNING: OrbitControls.js encountered an unknown camera type.")}}();function dt(t){if(!1!==s.enabled){switch(t.preventDefault(),function(t){let e=0;switch(t){case p:e=1;break;case f:e=4;break;case m:e=2}const n=performance.now();n-c<100?h|=e:h=e,c=n}(t.button),h){case 1:U(t),d=u.ROTATE;break;case 4:case 3:B(t),d=u.DOLLY;break;case 2:!function(t){T.set(t.clientX,t.clientY)}(t),i.style.cursor="all-scroll",d=u.PAN}d!==u.NONE&&(document.addEventListener("mousemove",pt,!1),document.addEventListener("mouseup",ft,!1),s.dispatchEvent(o)),N=!0}}function pt(t){if(!1!==s.enabled){switch(t.preventDefault(),d){case u.ROTATE:k(t);break;case u.DOLLY:H(t,1);break;case u.PAN:!function(t){L.set(t.clientX,t.clientY),C.subVectors(L,T),K(C.x,C.y),T.copy(L),s.update()}(t)}N=!0}}function ft(){!1!==s.enabled&&(i.style.cursor="default",document.removeEventListener("mousemove",pt,!1),document.removeEventListener("mouseup",ft,!1),s.dispatchEvent(l),d=u.NONE,h=0)}function mt(t){!1===s.enabled||d!==u.NONE&&d!==u.ROTATE||(t.preventDefault(),t.stopPropagation(),s.dispatchEvent(o),function(t){const e=t.deltaY;s.wheelTilt?Z(2*Math.PI*e/12500):(ut(t.clientX,t.clientY),e<0?et(q()):e>0&&tt(q())),s.update()}(t),s.dispatchEvent(l))}function gt(t){t.preventDefault(),!1!==s.enabled&&!1!==s.enableKeys&&n.mouseOver&&function(t){switch(t.keyCode){case s.keys.UP:K(0,s.keyPanSpeed),s.update();break;case s.keys.BOTTOM:K(0,-s.keyPanSpeed),s.update();break;case s.keys.LEFT:K(s.keyPanSpeed,0),s.update();break;case s.keys.RIGHT:K(-s.keyPanSpeed,0),s.update();break;case 67:if(!j)break;Y(-YM),s.update();break;case 82:if(!j||!t.ctrlKey)break;t.preventDefault(),W*=-1;break;case 86:if(!j)break;Y(YM),s.update();break;case 191:if(!j)break;Z(-YM),s.update();break;case 192:if(!j)break;Z(YM),s.update();break;case 219:if(!j)break;et(q()),s.update();break;case 221:if(!j)break;tt(q()),s.update()}}(t)}function vt(t){if(!1!==s.enabled){switch(t.preventDefault(),t.touches.length){case 1:!function(t){w.set(t.touches[0].pageX,t.touches[0].pageY)}(t),d=u.TOUCH_ROTATE;break;case 2:!function(t){const e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+n*n);A.set(0,i);const r=.5*(t.touches[0].pageX+t.touches[1].pageX),s=.5*(t.touches[0].pageY+t.touches[1].pageY);ut(r,s),T.set(r,s)}(t),d=u.TOUCH_DOLLY_PAN;break;default:d=u.NONE}d!==u.NONE&&s.dispatchEvent(o)}}function xt(t){if(!1!==s.enabled)switch(t.preventDefault(),t.stopPropagation(),t.touches.length){case 1:if(d!==u.TOUCH_ROTATE)return;!function(t){S.set(t.touches[0].pageX,t.touches[0].pageY),E.subVectors(S,w),Y(2*Math.PI*E.x/i.clientWidth),Z(2*Math.PI*E.y/i.clientHeight),w.copy(S),s.update()}(t);break;case 2:if(d!==u.TOUCH_DOLLY_PAN)return;!function(t){const e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+n*n);R.set(0,i),P.set(0,Math.pow(R.y/A.y,s.zoomSpeed)),tt(P.y),A.copy(R);const r=.5*(t.touches[0].pageX+t.touches[1].pageX),a=.5*(t.touches[0].pageY+t.touches[1].pageY);ut(r,a),L.set(r,a),C.subVectors(L,T),K(C.x,C.y),T.copy(L),s.update()}(t);break;default:d=u.NONE}}function yt(){!1!==s.enabled&&(s.dispatchEvent(l),d=u.NONE)}function _t(t){!1!==s.enabled&&t.preventDefault()}i.addEventListener("contextmenu",_t,!1),i.addEventListener("mousedown",dt,!1),i.addEventListener("wheel",mt,!1),i.addEventListener("touchstart",vt,!1),i.addEventListener("touchend",yt,!1),i.addEventListener("touchmove",xt,!1),i.addEventListener("keydown",gt,!1);X(n.ctx.cfg.value("avenControls",!0)),this.update()}}class QM{constructor(t,e,n,i,r){const s=[];if(n.walls&&s.push(h(a)),n.scraps&&s.push(h(o)),n.legs){const t=e.getFeature(1).geometry,n=t.getAttribute("instanceStart").array;s.push({type:"lines",index:t.index,position:new ae(n,3,!1),modelLimits:e.modelLimits})}if(0===s.length)return;const l=new Worker(t.cfg.value("home","")+"js/workers/gltfWorker.js");function h(t){const n=e.getFeature(t).geometry;return{type:"walls",index:n.index,position:n.getAttribute("position"),modelLimits:e.modelLimits}}l.addEventListener("message",(function(t){let e;e=i.binary?"application/octet-stream":"application/gltf+json",l.terminate(),r(new Blob([t.data.gltf],{type:e}),i.binary)})),l.postMessage({items:s,options:i})}}class KM{constructor(t,e){this.getSnapshot=function(n,i){const r=t.container,s=t.viewer,a=r.clientWidth,o=r.clientHeight,l=n,h=Math.round(o*l/a),c=new at(l,h,{minFilter:S,magFilter:w,format:I,stencilBuffer:!0});c.texture.generateMipmaps=!1,c.texture.name="CV.snapshot",e.setSize(l,h),e.setPixelRatio(1),e.setRenderTarget(c),e.setClearAlpha(1),s.dispatchEvent({type:"resized",name:"rts",width:l,height:h,lineScale:i}),s.renderView();const u=l*h*4,d=new Uint8ClampedArray(u);e.readRenderTargetPixels(c,0,0,l,h,d);const p=4*l,f=new Uint8ClampedArray(u);for(let t=0;t<u;t+=p){const e=u-t-p;for(let n=0;n<p;n++)f[e+n]=d[t+n]}const m=new ImageData(f,l,h),g=document.createElement("canvas");g.width=l,g.height=h;return g.getContext("2d").putImageData(m,0,0),c.dispose(),s.resetRenderer(),g.toDataURL()}}}function $M(t){this.ctx=t,this.openPageId=null,this.reset()}$M.prototype.reset=function(){const t=this,e=document.createElement("div");e.classList.add("cv-frame");const n=document.createElement("div");n.classList.add("cv-frame-header"),n.textContent="frame header",e.appendChild(n);const i=document.createElement("div");i.classList.add("cv-tab-box"),this.pages&&this.pages.forEach((t=>t.owner.dispose())),this.frame=e,this.header=n,this.tabBox=i,this.pages=[],this.listeners=[],this.inHandler=!1,this.controls=[],this.seq=0;const r=document.createElement("div");r.classList.add("close"),r.classList.add("tab"),this.addListener(r,"click",(function(){t.openPageId=null,t.tabBox.classList.remove("onscreen"),t.frame.classList.remove("onscreen")})),i.appendChild(r)},$M.seq=0,$M.prototype.addPage=function(t){const e=t.page,n=t.tab;return t.frame=this,this.addListener(n,"click",t.tabHandleClick.bind(t)),void 0!==t.onTop&&this.addListener(n,"click",t.onTop),this.tabBox.appendChild(n),this.frame.appendChild(e),this.pages.push({tab:n,page:e,owner:t}),this.openPageId===t.id&&t.open(),this},$M.prototype.getSeq=function(){return $M.seq++},$M.prototype.onScreen=function(t){this.tabBox.classList.add("onscreen"),this.frame.classList.add("onscreen"),this.header.textContent=t},$M.prototype.setParent=function(t){t.appendChild(this.tabBox),t.appendChild(this.frame)},$M.prototype.setControlsVisibility=function(t,e){const n=e?"block":"none";t.forEach((t=>{null!==t&&(t.style.display=n)}))},$M.prototype.clear=function(){const t=this.frame,e=this.tabBox;null!==t&&null!==t.parentElement&&t.parentElement.removeChild(t),null!==e&&null!==e.parentElement&&e.parentElement.removeChild(e),this.listeners.forEach((t=>t.obj.removeEventListener(t.name,t.handler))),this.reset()},$M.prototype.addFullscreenButton=function(t,e,n){const i=this.tabBox,r=document.createElement("div");return r.classList.add(t),r.classList.add("tab"),this.addListener(r,"click",(function(){e[n]=!e[n],s()})),this.addListener(e,"change",s),i.appendChild(r),s(),r;function s(){e[n]?(r.classList.remove("expand"),r.classList.add("collapse")):(r.classList.add("expand"),r.classList.remove("collapse"))}},$M.prototype.addListener=function(t,e,n){t.addEventListener(e,n,!1),this.listeners.push({obj:t,name:e,handler:n})},$M.prototype.handleChange=function(t){const e=t.target,n=t.name;if(!this.displayinHandle&&this.controls[n]){const t=this.controls[n];switch(t.type){case"checkbox":t.checked=e[n];break;case"select-one":case"range":t.value=e[n];break;case"download":t.href=e[n]}}this.pages.forEach((e=>{const n=e.owner;null!==n.onChange&&n.onChange(t)}))};class tb{constructor(t,e,n,i){const r=document.createElement("div"),s=document.createElement("div");s.classList.add("page"),r.classList.add(t),r.classList.add("tab"),this.page=s,this.tab=r,this.onTop=n,this.frame=null,this.onLeave=i,this.slide=void 0,this.x18nPrefix=e+".",this.onChange=null,this.id=t}}tb.prototype.i18n=function(t){const e=this.frame.ctx.cfg.i18n(this.x18nPrefix+t);return void 0===e?t:e},tb.prototype.addListener=function(t,e,n){this.frame.addListener(t,e,n)},tb.prototype.tabHandleClick=function(t){t.preventDefault(),t.stopPropagation(),this.open()},tb.prototype.open=function(){const t=this.tab,e=this.frame.pages;t.classList.add("toptab"),this.frame.onScreen(this.i18n("title")),this.frame.openPageId=this.id,e.forEach((e=>{const n=e.page,i=e.tab,r=e.owner;i===t?n.style.display="block":(n.style.display="none",i.classList.contains("toptab")&&(i.classList.remove("toptab"),void 0!==r.onLeave&&r.onLeave()))}))},tb.prototype.appendChild=function(t){return this.page.appendChild(t),t},tb.prototype.addHeader=function(t){const e=document.createElement("div");return e.classList.add("header"),e.textContent=this.i18n(t),this.page.appendChild(e),e},tb.prototype.addCollapsingHeader=function(t){const e=document.createElement("div");e.classList.add("header"),e.textContent=this.i18n(t),e.classList.add("header_full"),this.page.appendChild(e);const n=document.createElement("div");return n.classList.add("container_full"),this.page.appendChild(n),this.addListener(e,"click",(()=>{e.classList.contains("header_collapsed")?(n.style.display="block",this.addListener(n,"transitionend",(function t(){n.removeEventListener("transitionend",t),e.classList.remove("header_collapsed")})),n.classList.remove("container_collapsed")):(this.addListener(n,"transitionend",(function t(){n.removeEventListener("transitionend",t),e.classList.add("header_collapsed"),n.style.display="none"})),n.classList.add("container_collapsed"))})),n},tb.prototype.addText=function(t){const e=this.addLine(t);return e.classList.add("spaced"),e},tb.prototype.addLine=function(t){const e=document.createElement("p");return e.textContent=t,this.page.appendChild(e),e},tb.prototype.addBlankLine=function(){const t=document.createElement("br");return this.page.appendChild(t),t},tb.prototype.addLink=function(t,e){const n=document.createElement("a");return n.href=t,n.textContent=e,n.target="_blank",this.page.appendChild(n),n},tb.prototype.makeLabel=function(t,e,n="na"){const i=document.createElement("label");return i.textContent=this.i18n(t),i.htmlFor=n,i.classList.add(e),i},tb.prototype.addSelect=function(t,e,n,i,r){const s=document.createElement("div"),a=document.createElement("select");if(s.classList.add("control"),e instanceof Array)e.forEach((t=>{const e=document.createElement("option");e.value=t,e.text=t,e.text===n[i]&&(e.selected=!0),a.add(e,null)}));else for(const t in e){const r=document.createElement("option");r.text=t.split(" ").reduce(((t,e)=>t+" "+this.i18n(e)),"").trim(),r.value=e[t],r.value===n[i]&&(r.selected=!0),a.add(r,null)}const o=this.frame;return this.addListener(a,"change",(function(t){o.inHandler=!0,n[i]=t.target.value,o.inHandler=!1})),o.controls[i]=a,s.appendChild(this.makeLabel(t,"cv-select")),s.appendChild(a),void 0===r?this.page.appendChild(s):this.page.replaceChild(s,r),s},tb.prototype.addFileSelect=function(t,e,n,i){const r=this.frame,s=this.addSelect(t,e,n,i),a=s.firstChild,o="cv-"+r.getSeq();a.for=o,a.classList.add("cv-file-label");const l=document.createElement("input");return l.id=o,l.classList.add("cv-file"),l.type="file",l.accept=".svx,.lox,.plt",l.multiple=!0,this.addListener(l,"change",(function(){const t=l.files.length,e=[];if(t>0){for(let n=0;n<t;n++)e.push(l.files[n]);n[i]=e}})),a.appendChild(l),s},tb.prototype.addCheckbox=function(t,e,n){const i=this.frame,r=document.createElement("input"),s=document.createElement("div"),a="cv-"+i.getSeq();return s.classList.add("control"),r.type="checkbox",r.checked=e[n],r.id=a,this.addListener(r,"change",(function(t){i.inHandler=!0,e[n]=t.target.checked,i.inHandler=!1})),i.controls[n]=r,s.appendChild(r),s.appendChild(this.makeLabel(t,"check",a)),this.page.appendChild(s),s},tb.prototype.addRange=function(t,e,n){const i=this.frame,r=document.createElement("div"),s=document.createElement("input");return r.classList.add("control"),s.type="range",s.min=0,s.max=1,s.step=.05,s.value=e[n],this.addListener(s,"input",(function(t){i.inHandler=!0,e[n]=t.target.value,i.inHandler=!1})),i.controls[n]=s,r.appendChild(this.makeLabel(t,"cv-range")),r.appendChild(s),this.page.appendChild(r),r},tb.prototype.addSlide=function(t,e){const n=document.createElement("div");return n.classList.add("slide"),n.style.zIndex=200-e,n.appendChild(t),this.page.appendChild(n),this.slide=n,this.slideDepth=e,n},tb.prototype.replaceSlide=function(t,e){const n=document.createElement("div"),i=this.page;let r=this.slide;return n.classList.add("slide"),n.style.zIndex=200-e,e<this.slideDepth&&n.classList.add("slide-out"),n.appendChild(t),i.appendChild(n),e>this.slideDepth?(r.addEventListener("transitionend",(function t(){r.removeEventListener("transitionend",t),i.removeChild(r),r=null})),r.classList.add("slide-out")):e<this.slideDepth?(n.addEventListener("transitionend",(function t(){i.removeChild(r),n.removeEventListener("transitionend",t),r=null})),n.classList.remove("slide-out")):i.removeChild(r),this.slide=n,this.slideDepth=e,n},tb.prototype.addButton=function(t,e){const n=document.createElement("button");return n.type="button",n.textContent=this.i18n(t),this.addListener(n,"click",e),this.page.appendChild(n),n},tb.prototype.addTextBox=function(t,e,n){const i=document.createElement("div"),r=document.createElement("input");let s;return r.type="text",r.placeholder=e,i.appendChild(this.makeLabel(t,"text")),i.appendChild(r),this.page.appendChild(i),this.addListener(r,"change",(function(t){return s=t.target.value,!0})),n((function(){return r.value="",s})),i},tb.prototype.addDownloadButton=function(t,e,n){const i=document.createElement("a");return void 0===i.download?null:(this.addListener(i,"click",(()=>{i.href=e(i)})),i.textContent=this.i18n(t),i.type="download",i.download=n,i.href="javascript:void();",i.classList.add("download"),this.page.appendChild(i),i)},tb.canDownload=function(){return void 0!==document.createElement("a").download},tb.prototype.download=function(t,e){const n=document.createElement("a");if(void 0===n.download)return null;n.type="download",n.download=e,n.href=t,n.click()},tb.prototype.addColor=function(t,e){const n=this.frame,i=document.createElement("input"),r=document.createElement("div"),s=n.ctx.cfg,a="cv-"+n.getSeq();return r.classList.add("control"),i.type="color",i.value=s.themeColorHex(e),i.id=a,this.addListener(i,"change",(function(t){n.inHandler=!0,s.setThemeColorCSS(e,t.target.value),n.inHandler=!1})),n.controls[e]=i,r.appendChild(i),r.appendChild(this.makeLabel(t,"color",a)),this.page.appendChild(r),this.addListener(s,"colors",(t=>{"all"===t.name&&(i.value=s.themeColorHex(e))})),r},tb.prototype.addLogo=function(){const t=document.createElement("div");t.classList.add("logo"),t.title="logo",this.appendChild(t)},tb.prototype.dispose=function(){this._dispose&&this._dispose()};class eb extends tb{constructor(t,e){super("icon_help","help"),t.addPage(this);const n=this;let i;function r(t,e){const r=document.createElement("dt"),s=document.createElement("dd");r.textContent=t,s.textContent=n.i18n(e),i.appendChild(r),i.appendChild(s)}this.addHeader(e?"header_svx":"header_native"),this.addHeader("shading.header"),i=document.createElement("dl"),r("1","shading.height"),r("2","shading.inclination"),r("3","shading.length"),r("4","shading.height_cursor"),r("5","shading.single"),r("6","shading.survey"),r("7","shading.route"),r("8","shading.depth"),r("9","shading.depth_cursor"),r("0","shading.distance"),r("<alt>f","shading.flat"),e||(r("[","shading.cursor_up"),r("]","shading.cursor_down")),this.appendChild(i),this.addHeader("view.header"),i=document.createElement("dl"),e?(r("P","view.plan"),r("L","view.elevation"),r("","-"),r("N","view.north"),r("E","view.east"),r("S","view.south"),r("W","view.west"),r("","-"),r("C","view.rotate_clockwise"),r("V","view.rotate_anticlockwise"),r("]","view.zoom_in"),r("[","view.zoom_out"),r("F","view.full_screen"),r("","-"),r('" "',"view.auto_rotate"),r("Z","view.rotate_speed_up"),r("V","view.rotate_speed_down"),r("R","view.reverse_rotation"),r("","-"),r("<del>","view.reset")):(r("F","view.full_screen"),r("O","view.orthogonal"),r("P","view.perspective"),r("R","view.reset"),r(".","view.center"),r("N","view.next")),r("<alt>S","view.control_mode"),r("<alt>X","view.zoom_to_cursor"),r("(","view.decrease_focal_length"),r(")","view.increase_focal_length"),this.appendChild(i),this.addHeader("visibility.header"),i=document.createElement("dl"),e?(r("J","visibility.station_labels"),r("Q","visibility.splays"),r("T","visibility.terrain"),r("<ctrl>N","visibility.station_labels"),r("<ctrl>X","visibility.stations"),r("<ctrl>L","visibility.survey"),r("<ctrl>F","visibility.surface"),r("","-"),r("<","visibility.opacity_down"),r(">","visibility.opacity_up")):(r("C","visibility.scraps"),r("J","visibility.station_labels"),r("L","visibility.entrance_labels"),r("Q","visibility.splays"),r("S","visibility.surface"),r("T","visibility.terrain"),r("W","visibility.walls"),r("Z","visibility.stations"),r("","-"),r("<","visibility.opacity_down"),r(">","visibility.opacity_up")),this.appendChild(i),e||(this.addHeader("selection.header"),i=document.createElement("dl"),r("V","selection.remove"),this.appendChild(i))}}class nb extends tb{constructor(t,e,n){super("icon_info","info"),t.addPage(this),this.addHeader("header"),this.addHeader("stats.header"),this.addText(this.i18n("file")+": "+n.file);const i=e.getLegStats(1);if(this.addBlankLine(),this.addLine(this.i18n("stats.legs")+": "+i.legCount),this.addLine(this.i18n("stats.totalLength")+": "+i.legLength.toFixed(2)+" m"),this.addLine(this.i18n("stats.minLength")+": "+i.minLegLength.toFixed(2)+" m"),this.addLine(this.i18n("stats.maxLength")+": "+i.maxLegLength.toFixed(2)+" m"),(e.hasSplays||e.hasDuplicateLegs||e.hasSurfaceLegs)&&(this.addBlankLine(),this.addLine("Other legs"),this.addBlankLine()),e.hasSplays){const t=e.getLegStats(2);this.addLine(this.i18n("stats.splayCount")+": "+t.legCount)}if(e.hasDuplicateLegs){const t=e.getLegStats(u);this.addLine(this.i18n("stats.duplicateCount")+": "+t.legCount)}if(e.hasSurfaceLegs){const t=e.getLegStats(3);this.addLine(this.i18n("stats.surfaceCount")+": "+t.legCount)}this.addHeader("CaveView v2.3.0-test."),this.addLogo(),this.addText(this.i18n("summary")),this.addText(this.i18n("more")+": "),this.addLink("https://aardgoose.github.io/CaveView.js/",this.i18n("github")),this.addText("© Angus Sawyer, 2021")}}class ib extends tb{constructor(t,e,n,i){super("icon_explore","selection",(function(){a.isOntop=!0}),(function(){a.isOntop=!1})),t.addPage(this),this.surveyTree=e.getSurveyTree(),this.currentTop=this.surveyTree,this.nodes=new WeakMap,this.leafSections=new WeakSet,this.lastSelected=null,this.lastSection=0,this.lastShadingMode=e.shadingMode,this.currentHover=null,this.stringCompare=new Intl.Collator("en-GB",{numeric:!0}).compare,this.isOntop=!1;const r=document.createElement("div"),s=e.ctx.cfg;if(r.id="ui-path",r.classList.add("header"),e.isClipped){const t=document.createElement("span");t.textContent="◀ ",this.addListener(r,"click",(function(){i.reload()})),r.classList.add("reload");const e=document.createTextNode(this.currentTop.name);r.appendChild(t),r.appendChild(e)}else r.textContent=this.currentTop.name,this.nodes.set(r,this.currentTop);this.titleBar=r,this.appendChild(r),this.addListener(this.page,"mouseover",(function(t){const n=t.target;if("LI"!==n.nodeName)return;const i=a.nodes.get(n);i!==a.currentHover&&(e.highlight=e.section!==i?i:a.surveyTree,e.popup=i,a.currentHover=i)})),this.addListener(this.page,"mouseleave",(function(){e.highlight=a.surveyTree,e.popup=a.surveyTree})),this.addListener(this.page,"click",(function(t){t.stopPropagation(),t.preventDefault();const n=t.target,i=a.nodes.get(n);switch(n.tagName){case"LI":e.section=i,e.setPOI=!0,n.classList.add("selected"),null!==a.lastSelected&&a.lastSelected.classList.remove("selected"),a.lastSelected=n;break;case"DIV":a.handleNext(n,i);break;case"SPAN":a.handleBack(n)}})),this.addListener(this.page,"dblclick",(function(t){t.stopPropagation(),t.preventDefault();const n=t.target,i=a.nodes.get(n);if(!n.classList.contains("section"))return;i!==a.surveyTree&&(e.cut=!0)}));const a=this;return n.clientHeight,this.addLine=function(t,n){const i=null===n?null:n.connections;if(null===i||this.leafSections.has(t)||this.leafSections.add(t),!(0!==i||e.splays||2&n.type))return;const r=document.createElement("li"),l=void 0===n.comment?n.name:n.name+" ( "+n.comment+" )",h=document.createTextNode(l);let c;if(a.nodes.set(r,n),e.section===n&&r.classList.add("selected"),0===n.type?(c=o("█ ","#444444"),r.classList.add("section")):2&n.type?(c=o("∩ ",s.themeColorCSS("stations.entrances.marker")),c.classList.add("cv-entrance")):c=i>2?o("◼ ",s.themeColorCSS("stations.junctions.marker")):o(0===i?"◻ ":"◼ ",s.themeColorCSS("stations.default.marker")),r.appendChild(c),r.appendChild(h),n.children.length>0){const t=document.createElement("div");t.classList.add("descend-tree"),a.nodes.set(t,n),r.appendChild(t)}t.appendChild(r)},this.displaySectionCommon=function(t){const n=t.children;t.sorted||(n.sort(((t,e)=>this.stringCompare(t.name,e.name))),t.sorted=!0);const i=document.createElement("ul");return i.classList.add("cv-tree"),t.forEachChild((t=>this.addLine(i,t))),l(i),this.currentTop=t,this.lastShadingMode=e.shadingMode,i},this.reloadSections=function(){const t=this.page.getElementsByTagName("UL"),e=[];for(let n=0;n<t.length;n++){const i=t[n];this.leafSections.has(i)&&e.push(i)}e.forEach((t=>{const e=this.nodes.get(t.previousSibling)||this.currentTop;e&&t.replaceWith(this.displaySectionCommon(e))}))},void(this.onChange=function(t){if(!e.surveyLoaded)return;if("splays"===t.name)return void a.reloadSections();(a.lastSection!==e.section||6===a.lastShadingMode&&6!==e.shadingMode||6!==a.lastShadingMode&&6===e.shadingMode)&&(l(),a.lastShadingMode=e.shadingMode,a.lastSection=e.section)});function o(t,e){const n=document.createElement("span");return n.style.color=e,n.textContent=t,n}function l(t){const n=(void 0===t?a.page:t).getElementsByTagName("li"),i=e.ctx.surveyColourMapper,r=6===e.shadingMode?i.getColourMap(e.section):null;for(let t=0;t<n.length;t++){const e=n[t],i=a.nodes.get(n[t]);if(void 0!==i&&!i.isStation()){const t=e.firstChild,n=i.id;let s;s=null!==r&&void 0!==r[n]?"#"+r[n].getHexString():"#444444",t.style.color=s}}}}}class rb extends ib{constructor(t,e,n,i){super(t,e,n,i);const r=this;let s=0;return this.addSlide(a(r.currentTop),s),n.clientHeight,this.handleNext=function(t,n){void 0!==n&&n!==r.surveyTree?r.replaceSlide(a(n),++s):"ui-path"===t.id&&(e.section=r.currentTop)},this.handleBack=function(t){if("surveyBack"===t.id){if(r.currentTop===r.surveyTree)return;r.replaceSlide(a(r.currentTop.parent),--s)}},this;function a(t){let e;for(r.nodes=new WeakMap;e=r.titleBar.firstChild;)r.titleBar.removeChild(e);if(t===r.surveyTree)r.titleBar.textContent=""===t.name?"[model]":t.name,r.nodes.set(r.titleBar,t);else{const e=document.createElement("span");e.id="surveyBack",e.textContent=" ◄",r.nodes.set(e,t),r.titleBar.appendChild(e),r.titleBar.appendChild(document.createTextNode(" "+t.name))}return r.displaySectionCommon(t)}}}class sb extends ib{constructor(t,e,n,i){super(t,e,n,i);const r=this,s=r.displaySectionCommon(this.currentTop);let a=null,o=0;return this.appendChild(s),n.clientHeight,this.handleNext=function(t,n){if(void 0!==n&&n!==r.surveyTree){const e=t.parentNode;if(!t.classList.contains("open")){const i=r.displaySectionCommon(n);return e.appendChild(i),t.classList.add("open"),i}e.removeChild(e.lastElementChild),t.classList.remove("open")}else"ui-path"===t.id&&(e.section=r.currentTop)},this.handleBack=function(){},void this.addListener(e,"station",(function(t){if(!r.isOntop)return;const e=t.node.station;if(null===e)return r.frame.frame.removeEventListener("scroll",c),void(o>performance.now()-1e3?setTimeout(h,1e3):h());const n=[];let i=e;do{n.push(i),i=i.parent}while(0!==i.id);let a=s,u=a.childNodes;i=n.pop();for(;void 0!==i;){let t,s=0;for(s=0;s<u.length&&(t=u[s],r.nodes.get(t)!==i);s++);if(s===u.length)break;if(i===e){l(t);break}{let e=t.lastElementChild;"DIV"===e.tagName&&(e=r.handleNext(e,i)),i=n.pop(),u=e.childNodes,a=e}}}));function l(t){o=0,r.frame.frame.addEventListener("scroll",c),t.classList.add("highlight"),t.scrollIntoView({behavior:"smooth",block:"center"}),null!==a&&h(),a=t}function h(){null!==a&&(a.classList.remove("highlight"),a=null,o=0)}function c(t){o=t.timeStamp}}}const ab={"shading.height":1,"shading.length":2,"shading.inclination":3,"shading.height_cursor":4,"shading.fixed":5,"shading.survey":6,"shading.route":i,"shading.distance":s},ob={"view.viewpoints.none":0,"view.viewpoints.plan":1,"view.viewpoints.elevation_n":2,"view.viewpoints.elevation_s":3,"view.viewpoints.elevation_e":4,"view.viewpoints.elevation_w":5},lb={"view.camera.orthographic":1,"view.camera.perspective":2,"view.camera.anaglyph":3};class hb extends tb{constructor(t,e,n){super("icon_settings","settings"),t.addPage(this);const s=[],a=[],o=e.ctx.cfg,l=Object.assign({},ab),h=e.routeNames;e.hasRealTerrain&&(l["shading.depth"]=9,l["shading.depth_cursor"]=r),this.addHeader("survey.header"),n.fileCount>1?this.addFileSelect("survey.caption",n.fileList,n,"file"):this.addLine(n.selectedFile);const c=this.addCollapsingHeader("view.header");c.appendChild(this.addSelect("view.camera.caption",lb,e,"cameraType")),c.appendChild(this.addSelect("view.viewpoints.caption",ob,e,"view")),c.appendChild(this.addRange("view.vertical_scaling",e,"zScale")),c.appendChild(this.addRange("view.linewidth",e,"linewidth")),c.appendChild(this.addCheckbox("view.autorotate",e,"autoRotate")),c.appendChild(this.addRange("view.rotation_speed",e,"autoRotateSpeed"));this.addCollapsingHeader("shading.header").appendChild(this.addSelect("shading.caption",l,e,"shadingMode")),0!==h.length?(e.route||(e.route=h[0]),a.push(this.addSelect("selected_route",h,e,"route"))):a.push(this.addText(this.i18n("no_routes")));const u=this.addCollapsingHeader("visibility.header");e.hasLegs&&u.appendChild(this.addCheckbox("visibility.legs",e,"legs")),e.hasEntrances&&u.appendChild(this.addCheckbox("visibility.entrances",e,"entrances")),e.hasEntrances&&u.appendChild(this.addCheckbox("visibility.entrance_dots",e,"entrance_dots")),e.hasStations&&u.appendChild(this.addCheckbox("visibility.stations",e,"stations")),e.hasStationLabels&&u.appendChild(this.addCheckbox("visibility.labels",e,"stationLabels")),e.hasStationComments&&u.appendChild(this.addCheckbox("visibility.comments",e,"stationComments")),e.hasSplays&&u.appendChild(this.addCheckbox("visibility.splays",e,"splays")),e.hasWalls&&u.appendChild(this.addCheckbox("visibility.walls",e,"walls")),e.hasScraps&&u.appendChild(this.addCheckbox("visibility.scraps",e,"scraps")),e.hasDuplicateLegs&&u.appendChild(this.addCheckbox("visibility.duplicates",e,"duplicateLegs")),e.hasTraces&&u.appendChild(this.addCheckbox("visibility.traces",e,"traces")),u.appendChild(this.addCheckbox("visibility.fog",e,"fog")),u.appendChild(this.addCheckbox("visibility.hud",e,"HUD")),u.appendChild(this.addCheckbox("visibility.box",e,"box")),u.appendChild(this.addCheckbox("visibility.grid",e,"grid")),e.hasWarnings&&u.appendChild(this.addCheckbox("visibility.warnings",e,"warnings"));const d=this.addCollapsingHeader("controls.header");d.appendChild(this.addCheckbox("controls.svx_control_mode",e,"svxControlMode")),d.appendChild(this.addCheckbox("controls.zoom_to_cursor",e,"zoomToCursor")),d.appendChild(this.addCheckbox("ui.selection_tree",o,"selectionTree"));const p=this.addCollapsingHeader("colors.header");return p.appendChild(this.addColor("colors.background_color","background")),p.appendChild(this.addColor("colors.entrance_text","stations.entrances.text")),p.appendChild(this.addColor("colors.entrance_background","stations.entrances.background")),p.appendChild(this.addColor("colors.entrance_marker","stations.entrances.marker")),p.appendChild(this.addColor("colors.bounding_box","box.bounding")),p.appendChild(this.addColor("colors.legs_fixed","shading.single")),p.appendChild(this.addColor("colors.surface_fixed","shading.surface")),p.appendChild(this.addColor("colors.duplicate_fixed","shading.duplicate")),p.appendChild(this.addColor("colors.hud_text","hud.text")),p.appendChild(this.addButton("colors.defaults",o.resetColors.bind(o))),e.svxControlMode&&d.appendChild(this.addCheckbox("controls.wheel_tilt",e,"wheelTilt")),f({name:"cameraType"}),f({name:"shadingMode"}),this.onChange=f,this;function f(n){"shadingMode"===n.name&&t.setControlsVisibility(a,e.shadingMode===i),"cameraType"===n.name&&t.setControlsVisibility(s,3===e.cameraType)}}}const cb={"surface.shading.height":1,"surface.shading.inclination":3,"surface.shading.height_cursor":4,"surface.shading.fixed":17};class ub extends tb{constructor(t,e){const n=[];if(super("icon_terrain","surface"),t.addPage(this),this.addHeader("surface.header"),e.hasSurfaceLegs&&(this.addCheckbox("surface.legs",e,"surfaceLegs"),this.addSelect("surface.shading.caption",cb,e,"surfaceShading")),e.hasTerrain){this.addHeader("terrain.header"),this.addCheckbox("terrain.terrain",e,"terrain"),n.push(this.addSelect("terrain.shading.caption",e.terrainShadingModes,e,"terrainShading")),n.push(this.addRange("terrain.opacity",e,"terrainOpacity")),n.push(this.addCheckbox("terrain.datum_shift",e,"terrainDatumShift")),n.push(this.addCheckbox("terrain.lighting",e,"terrainDirectionalLighting")),e.hasRealTerrain||n.push(this.addDownloadButton("terrain.downloadTileSet",e.terrainTileSet,"tileSetEntry.json"));const t=e.terrainAttributions;for(let e=0;e<t.length;e++)this.addText(t[e])}return i({name:"terrain"}),this.onChange=i,this;function i(i){"terrain"===i.name&&t.setControlsVisibility(n,e.terrain)}}}class db{constructor(t){this.page=t,this.elements=[],this.dynamic=[],this.onShow=function(){this.dynamic.forEach((t=>t.parentElement.removeChild(t))),this.dynamic=[]}}add(t){return this.elements.push(t),t}addDynamic(t){return this.dynamic.push(t),t}setVisibility(t){const e=this.page.frame;e.setControlsVisibility(this.elements,t),e.setControlsVisibility(this.dynamic,t),t&&null!==this.onShow&&this.onShow()}}class pb extends db{constructor(t,e,n){super(t);const i=this,r=e.getMetadata(),s=e.routeNames;this.add(t.addHeader("route.header"));let a,o=t.addSelect("route.current",s,e,"route");this.add(o),this.add(t.addButton("route.save",(function(){}))),this.add(t.addTextBox("route.new","---",(function(t){a=t}))),this.add(t.addButton("route.add",(function(){console.log(a),o=i.addSelect("Current Route",e.routeNames,e,"route",o)}))),this.add(t.addDownloadButton("route.download",r.getURL,Qg(n.file,"json")))}}class fb extends db{constructor(t,e){super(t);const n=this,i=t.i18n("trace.start")+":",r=t.i18n("trace.end")+":";t.addListener(e,"selectedTrace",(function(e){void 0!==e.add?function(e){o(),void 0!==e.start&&(s.textContent=i+" "+e.start);void 0!==e.end&&(a.textContent=r+" "+e.end,n.addDynamic(t.addButton("trace.add",(function(){e.add(),o()}))))}(e):void 0!==e.delete&&function(e){const l=e.trace;o(),s.textContent=i+" "+l.start,a.textContent=r+" "+l.end,n.addDynamic(t.addButton("trace.delete",(function(){e.delete(),o()})))}(e)})),this.add(t.addHeader("trace.header"));const s=this.add(t.addLine(i)),a=this.add(t.addLine(r));function o(){n.onShow(),s.textContent=i,a.textContent=r}}}const mb={"modes.none":0,"modes.route":1,"modes.trace":3};class gb extends tb{constructor(t,e,n){super("icon_route","edit",(function(){a={shadingMode:e.shadingMode,stations:e.stations,traces:e.traces},h({type:"change",name:"editMode"})}),(function(){e.setView(a)})),t.addPage(this);const r=this,s=[];let a,o=null,l=null;return this.addSelect("mode",mb,e,"editMode"),s.push(this.addText(this.i18n("intro"))),void(this.onChange=h);function h(h){if("editMode"===h.name){const h=Object.assign({},a);switch(e.editMode){case 3:null===l&&(l=new fb(r,e)),h.traces=!0;break;case 1:null===o&&(o=new pb(r,e,n)),h.shadingMode=i}e.setView(h),t.setControlsVisibility(s,0===e.editMode),null!==o&&o.setVisibility(1===e.editMode),null!==l&&l.setVisibility(3===e.editMode)}}}}function vb(t,e,n){function a(a){t.surveyLoaded&&t.mouseOver&&(a.preventDefault(),function(e){if(e.ctrlKey)return!1;let n=!0;if(e.altKey)switch(e.key){case"s":t.svxControlMode=!t.svxControlMode;break;case"f":t.flatShading=!t.flatShading;break;case"h":t.hideMode=!t.hideMode;break;case"x":t.zoomToCursor=!t.zoomToCursor;break;default:n=!1}else switch(e.key){case"0":t.shadingMode=s;break;case"1":t.shadingMode=1;break;case"2":t.shadingMode=3;break;case"3":t.shadingMode=2;break;case"4":t.shadingMode=4;break;case"5":t.shadingMode=5;break;case"6":t.shadingMode=6;break;case"7":t.shadingMode=i;break;case"8":t.shadingMode=9;break;case"9":t.shadingMode=r;break;case"f":t.fullscreen=!t.fullscreen;break;case"j":t.hasStationLabels&&(t.stationLabels=!t.stationLabels);break;case"o":t.cameraType=1;break;case"q":t.hasSplays&&(t.splays=!t.splays);break;case"t":t.hasTerrain&&(t.terrain=!t.terrain);break;case"+":t.cursorHeight++;break;case"-":t.cursorHeight--;break;case"<":t.hasTerrain&&(t.terrainOpacity=Math.max(t.terrainOpacity-.05,0));break;case">":t.hasTerrain&&(t.terrainOpacity=Math.min(t.terrainOpacity+.05,1));break;case"(":t.focalLength=Math.max(10,t.focalLength-10);break;case")":t.focalLength=Math.min(300,t.focalLength+10);break;default:n=!1}return n}(a)||(n?function(e){if(e.ctrlKey)switch(e.key){case"b":t.box=!t.box;break;case"e":t.wheelTilt=!t.wheelTilt;break;case"f":t.hasSurfaceLegs&&(t.surfaceLegs=!t.surfaceLegs);break;case"l":t.hasLegs&&(t.legs=!t.legs);break;case"n":t.hasStationLabels&&(t.stationLabels=!t.stationLabels);break;case"x":t.stations=!t.stations}else switch(e.key){case"Delete":t.reset=!0;break;case"Enter":t.autoRotate=!0;break;case" ":t.autoRotate=!t.autoRotate;break;case"l":t.polarAngle=Math.PI/2;break;case"e":t.azimuthAngle=3*Math.PI/2;break;case"n":t.azimuthAngle=0;break;case"p":t.polarAngle=0;break;case"r":t.autoRotateSpeed*=-1;break;case"s":t.azimuthAngle=Math.PI;break;case"w":t.azimuthAngle=Math.PI/2;break;case"x":t.autoRotateSpeed-=.1;break;case"z":t.autoRotateSpeed+=.1}}(a):function(n){if(n.ctrlKey)return;switch(n.key){case"c":t.hasScraps&&(t.scraps=!t.scraps);break;case"d":t.hasTraces&&(t.traces=!t.traces);break;case"f":t.fullscreen=!t.fullscreen;break;case"j":t.hasStationLabels&&(t.stationLabels=!t.stationLabels);break;case"l":t.hasEntrances&&(t.entrances=!t.entrances);break;case"n":e.nextFile();break;case"o":t.cameraType=1;break;case"p":t.cameraType=2;break;case"q":t.hasSplays&&(t.splays=!t.splays);break;case"r":t.view=1;break;case"s":t.hasSurfaceLegs&&(t.surfaceLegs=!t.surfaceLegs);break;case"t":t.hasTerrain&&(t.terrain=!t.terrain);break;case"v":tb.clear(),t.cut=!0;break;case"w":t.hasWalls&&(t.walls=!t.walls);break;case"x":t.setPOI=!0;break;case"z":t.stations=!t.stations;break;case"]":t.cursorHeight++;break;case"[":t.cursorHeight--}}(a)))}document.addEventListener("keydown",a),this.dispose=function(){document.removeEventListener("keydown",a)}}class xb extends d{constructor(t,e){super(),this.fileList=[],this.fileCount=0,this.currentIndex=1/0,this.loadedFile=null,this.isMultiple=!1,this.splash=null,this.localFilename=null;const n=this;function i(){const e=n.splash;t.classList.remove("cv-splash"),null!==e&&(e.parentNode.removeChild(e),n.splash=null)}function r(i){if(i.preventDefault(),null!==n.splash)return;const r=document.createElement("div");r.innerHTML=e.cfg.i18n("dnd.splash_text")||"dnd.splash_text",r.id="cv-splash",t.appendChild(r),t.classList.add("cv-splash"),n.splash=r}function s(t){t.preventDefault(),t.dataTransfer.dropEffect="copy"}function a(e){e.preventDefault(),e.relatedTarget===t.parentNode&&i()}function o(t){i();const e=t.dataTransfer;t.preventDefault();const r=e.files.length,s=[];if(r>0){for(let t=0;t<r;t++)s.push(e.files[t]);n.selectFile(s,null)}}t.addEventListener("drop",o),t.addEventListener("dragenter",r),t.addEventListener("dragover",s),t.addEventListener("dragleave",a),Object.defineProperty(this,"file",{get:function(){return this.selectedFile},set:this.selectFile}),this.dispose=function(){t.removeEventListener("drop",o),t.removeEventListener("dragover",s),t.removeEventListener("dragleave",a),t.removeEventListener("dragenter",r)}}}xb.prototype.addList=function(t){this.fileList=t,this.fileCount=t.length},xb.prototype.nextFile=function(){const t=this.fileList;if(0===this.fileCount)return!1;++this.currentIndex>=this.fileCount&&(this.currentIndex=0),this.selectFile(t[this.currentIndex])},xb.prototype.selectFile=function(t,e){Array.isArray(t)?1===t.length?(this.localFilename=t[0].name,this.selectedFile=t[0],this.isMultiple=!1):(this.selectedFile="[multiple]",this.localFilename="multiple",this.isMultiple=!0):(this.selectedFile=t,this.localFilename=t),this.loadedFile=t,this.dispatchEvent({type:"selected",file:t,section:e})},xb.prototype.reload=function(){this.selectFile(this.loadedFile)};class yb extends tb{constructor(t,e,n){super("icon_export","exports"),t.addPage(this),this.addHeader("png_export.header");const i=[];let r=e.maxSnapshotSize;do{i.push(r)}while((r/=2)>512);const s={exportSize:i[0],lineScale:1};this.addSelect("png_export.line_scale",[1,2,3,4,5,6],s,"lineScale"),this.addSelect("png_export.size",i,s,"exportSize"),this.addDownloadButton("png_export.export",(()=>e.getSnapshot(s.exportSize,s.lineScale)),"snapshot.png"),this.addHeader("gltf_export.header");const a={legs:!1,walls:!1,scraps:!1},o={rotate:!1,binary:!1};e.hasWalls&&(a.walls=!0,this.addCheckbox("gltf_export.walls",a,"walls")),e.hasScraps&&(a.scraps=!0,this.addCheckbox("gltf_export.scraps",a,"scraps")),this.addCheckbox("gltf_export.legs",a,"legs"),this.addCheckbox("gltf_export.rotate_axes",o,"rotate"),this.addButton("gltf_export.export",(function(){e.getGLTFExport(a,o,h)}));const l=this;return;function h(t,e){const i=Qg(n.localFilename,e?"glb":"gltf");l.download(URL.createObjectURL(t),i)}}}t.CAMERA_ANAGLYPH=3,t.CAMERA_NONE=0,t.CAMERA_OFFSET=n,t.CAMERA_ORTHOGRAPHIC=1,t.CAMERA_PERSPECTIVE=2,t.CLUSTER_MARKERS=16,t.CaveViewUI=function(t){const e=t.ctx,n=t.container,i=new $M(e),r=e.cfg,s=new xb(n,e);s.addEventListener("selected",(function(e){i.clear(),t.clearView(),Array.isArray(e.file)?t.loadCaves(e.file):t.loadCave(e.file,e.section)})),r.setPropertyValue("selectionTree",!0),t.addEventListener("change",i.handleChange.bind(i)),t.addEventListener("newCave",o),r.addEventListener("change",o);const a=new vb(t,s,r.value("avenControls",!0));function o(){t.surveyLoaded&&(i.clear(),new hb(i,t,s),(t.hasSurfaceLegs||t.hasTerrain)&&new ub(i,t),r.selectionTree?new sb(i,t,n,s):new rb(i,t,n,s),r.value("showEditPage",!1)&&!s.isMultiple&&new gb(i,t,s),r.value("showExportPage",!1)&&tb.canDownload()&&new yb(i,t,s),new nb(i,t,s),new eb(i,t.svxControlMode),i.setParent(n),i.addFullscreenButton("fullscreen",t,"fullscreen"))}this.loadCaveList=function(t){s.addList(t),s.nextFile()},this.loadCave=function(t,e){s.selectFile(t,e)},this.loadCaves=function(e){t.clearView(),t.loadCaves(e)},this.clearView=function(){i.clear(),t.clearView()},this.dispose=function(){i.clear(),t.clearView(),s.dispose(),a.dispose(),t.dispose()}},t.CaveViewer=class extends d{constructor(t,n){super(),console.log("CaveView v"+e);const r=document.getElementById(t);this.container=r,r||alert("No container DOM object ["+t+"] available"),r.classList.add("cv-container");const d=new GM(n),f={cfg:d,container:r,workerPools:new jM(d),glyphStringCache:new Map,viewer:this};this.ctx=f;const g=new Hg(this);f.materials=g,r.style.backgroundColor=d.themeColorCSS("background");let v=new xs({antialias:!0,alpha:!0});nt(),v.clear(),v.autoClear=!1,r.appendChild(v.domElement);const x=new ys(d.themeColorCSS("background"),.0025),y=new _s;y.fog=x,y.name="CV.Viewer";const _=new Vg(f,v,y),M=new sa;M.layers.enableAll();const b=new Wg(f,y),w=new JM(_,v.domElement,this);w.maxPolarAngle=d.themeAngle("maxPolarAngle"),w.addEventListener("change",ht),w.addEventListener("end",(function(){j.dispatchEvent(E)}));const S=new Jg(w,ht),E={type:"moved",cameraManager:_},T={};let L=!1;const C={type:"select",node:null};let A=0,R=0,P=[],D=!1,I=0,N=null,z=null,F=null,O={},U=!1,B=!0,k=null,H=!1;const G=new he,V=new ot,W=new lt,j=this;let X=null,q=null,Y=!1;function Z(){Y=!0}function J(){Y=!1}window.addEventListener("resize",dt),Object.defineProperties(this,{mouseOver:{get:function(){return Y}},reset:{set:function(){pt(!1)}},surveyLoaded:{get:function(){return L}},terrain:{get:function(){return _.testCameraLayer(7)},set:function(t){null!==N&&N.isLoaded&&(N.setVisibility(t),_.setCameraLayer(7,t),j.dispatchEvent({type:"change",name:"terrain"}),wt())}},terrainShading:{get:function(){return null!==N?N.shadingMode:null},set:et(st,"terrainShading")},hasTerrain:{get:function(){return!!N}},hasRealTerrain:{get:function(){return N&&!N.isFlat}},terrainAttributions:{get:function(){return null!==N?N.attributions:[]}},terrainDirectionalLighting:{get:function(){return b.directionalLighting},set:function(t){b.directionalLighting=t,wt()}},terrainThrough:{get:function(){return null!==N?N.throughMode:null},set:et((function(t){if(null===N)return;N.setThroughMode(t),g.distanceTransparency=2===t?200:0,st(N.shadingMode)}),"terrainThrough")},terrainShadingModes:{get:function(){return null!==N?N.terrainShadingModes:{}}},terrainTileSet:{get:function(){return N.tileSet.bind(N)}},terrainDatumShift:{get:function(){return!!N.activeDatumShift},set:function(t){if(null===N)return;N.applyDatumShift(t),j.dispatchEvent({type:"change",name:"terrainDatumShift"}),wt()}},terrainOpacity:{get:function(){return null!==N?N.getOpacity():0},set:function(t){if(null===N)return;N.setOpacity(t),j.dispatchEvent({type:"change",name:"terrainOpacity"}),wt()}},shadingMode:{get:function(){return z.caveShading},set:et(ct,"shadingMode")},hideMode:{get:function(){return z.hideMode},set:function(t){z.setHideMode(t),wt()}},flatShading:{get:function(){return z.wallsMode},set:function(t){z.setWallsMode(t),wt()}},route:{get:function(){return z.getRoutes().setRoute},set:function(t){z.getRoutes().setRoute=t}},routeNames:{get:function(){return z.getRoutes().getRouteNames()}},surfaceShading:{get:function(){return z.surfaceShading},set:et((function(t){z.setSurfaceShading(t),wt()}),"surfaceShading")},duplicateShading:{get:function(){return z.duplicateShading},set:et((function(t){z.setDuplicateShading(t),wt()}),"duplicateShading")},cameraType:{get:function(){return _.mode},set:et((function(t){_.setCamera(t,w.target),wt()}),"cameraType")},eyeSeparation:{get:function(){return _.eyeSeparation},set:function(t){_.eyeSeparation=t,wt()}},view:{get:function(){return 0},set:et((function(t){const e=W;switch(t){case 0:return;case 1:e.set(0,0,-1);break;case 2:e.set(0,1,0);break;case 3:e.set(0,-1,0);break;case 4:e.set(1,0,0);break;case 5:e.set(-1,0,0);break;default:return void console.warn("invalid view mode specified: ",t)}S.prepare(z.getWorldBoundingBox(),e),S.start(B)}),"view")},cursorHeight:{get:function(){return g.cursorHeight},set:function(t){g.cursorHeight=t,j.dispatchEvent({type:"cursorChange",name:"cursorHeight"}),wt()}},linewidth:{get:function(){return(g.linewidth-1)/10},set:function(t){g.linewidth=10*t+1,wt()}},maxDistance:{get:function(){return z.getMaxDistance()}},maxHeight:{get:function(){return null===F?0:F.max.z}},minHeight:{get:function(){return null===F?0:F.min.z}},maxLegLength:{get:function(){return O.maxLegLength}},minLegLength:{get:function(){return O.minLegLength}},section:{get:function(){return z.selection.getNode()},set:et(ut,"section")},sectionByName:{get:function(){return z.selection.getName()},set:function(t){ut(z.surveyTree.getByPath(t)||z.surveyTree)}},popup:{set:function(t){xt(),t.isStation()&&vt(t)}},highlight:{set:et((function(t){z.highlightSelection(t),wt()}),"highlight")},polarAngle:{get:function(){return w.getPolarAngle()},set:function(t){S.setPolarAngle(t)}},azimuthAngle:{set:function(t){S.setAzimuthAngle(t)}},editMode:{get:function(){return R},set:et((function(t){switch(R=Number(t),A=R,I=0,z.markers.clear(),z.selectSection(z.surveyTree),wt(),M.params.Points.threshold=3,R){case 3:P=z.pointTargets.concat([z.dyeTraces]);break;case 0:P=z.pointTargets;break;case 1:P=z.legTargets;break;case 4:P=z.entranceTargets,M.params.Points.threshold=15;break;default:console.warn("invalid mouse mode",t)}}),"editMode")},setPOI:{set:et((function(){S.start(!0)}),"setPOI")},HUD:{get:function(){return Q.getVisibility()},set:function(t){Q.setVisibility(t)}},cut:{set:function(){const t=z.selection;if(t.isEmpty()||t.isStation())return;S.cancel(),z.remove(N),z.cutSection(t.getNode());const e=z;q=$.saveState(),j.clearView(),H=!0,ft(e)}},zScale:{get:function(){return z.zScale},set:function(t){z.zScale=t,wt()}},autoRotate:{get:function(){return w.autoRotate},set:function(t){var e;e=!!t,S.setAutoRotate(e),j.dispatchEvent({type:"change",name:"autoRotate"})}},wheelTilt:{get:function(){return w.wheelTilt},set:function(t){w.wheelTilt=!!t,j.dispatchEvent({type:"change",name:"wheelTilt"})}},svxControlMode:{get:function(){return w.svxControlMode},set:function(t){w.svxControlMode=!!t,j.dispatchEvent({type:"newCave",name:"newCave"})}},zoomToCursor:{get:function(){return w.zoomToCursor},set:function(t){w.zoomToCursor=!!t,j.dispatchEvent({type:"change",name:"zoomToCursor"})}},autoRotateSpeed:{get:function(){return w.autoRotateSpeed/11},set:function(t){w.autoRotateSpeed=11*Math.max(Math.min(t,1),-1),j.dispatchEvent({type:"change",name:"autoRotateSpeed"})}},fullscreen:{get:it,set:function(t){if(it()===t)return;t?(r.classList.add("toggle-fullscreen"),null===document.fullscreenElement?r.requestFullscreen():null===document.webkitFullscreenElement&&r.webkitRequestFullscreen()):(r.classList.remove("toggle-fullscreen"),document.fullscreenElement?document.exitFullscreen():document.webkitFullscreenElement&&(document.webkitExitFullscreen?document.webkitExitFullscreen():document.webkitCancelFullScreen&&document.webkitCancelFullScreen()))}},hasContours:{get:function(){return!(null===v.extensions.get("OES_standard_derivatives"))}},fog:{get:function(){return U},set:function(t){U=t,x.density=U?.0025:0,wt()}},isClipped:{get:function(){return H}},maxSnapshotSize:{get:function(){const t=v.getContext();return t.getParameter(t.MAX_RENDERBUFFER_SIZE)}},focalLength:{get:function(){return _.focalLength},set:function(t){const e=t/_.focalLength;_.focalLength=t,w.scaleDolly(e)}}}),tt(4,"box"),tt(6,"entrances"),tt(17,"entrance_dots"),tt(8,"stations"),tt(9,"traces"),tt(c,"grid"),tt(o,"scraps"),tt(a,"walls"),tt(1,"legs"),tt(2,"splays"),tt(3,"surfaceLegs"),tt(u,"duplicateLegs"),tt(l,"stationLabels"),tt(h,"stationComments"),tt(14,"warnings"),r.addEventListener("mouseover",Z),r.addEventListener("mouseleave",J),r.addEventListener("fullscreenchange",rt),r.addEventListener("webkitfullscreenchange",rt),this.addEventListener("change",(function(t){null!==z&&"splays"===t.name&&z.stations.setSplaysVisibility(j.splays)})),d.addEventListener("colors",(()=>{r.style.backgroundColor=d.themeColorCSS("background"),v.setClearColor(d.themeColor("background"),0),z&&z.refreshColors(),wt()})),this.getControls=function(){return w};const Q=new ao(this,v),K=new m_(f,(function(t){if(!t)return void alert("failed loading cave information");dt(),ft(new hM(f,t)),K.reset()}));Q.getProgressDial(0).watch(K);const $=new qM(this);function tt(t,e){Object.defineProperty(j,e,{get:function(){return _.testCameraLayer(t)},set:function(n){_.setCameraLayer(t,n),j.dispatchEvent({type:"change",name:e}),wt()}});const n="has"+e.substr(0,1).toUpperCase()+e.substr(1);Object.defineProperty(j,n,{get:function(){return z.hasFeature(t)}})}function et(t,e){return function(n){t(isNaN(n)?n:Number(n)),j.dispatchEvent({type:"change",name:e})}}function nt(){v.setSize(r.clientWidth,r.clientHeight),v.setPixelRatio(window.devicePixelRatio),v.setClearColor(d.themeColor("background"),0),v.setClearAlpha(0),v.setRenderTarget(null)}function it(){return window.innerHeight===r.clientHeight&&window.innerWidth===r.clientWidth}function rt(){document.fullscreenElement||document.webkitFullscreenElement?r.classList.add("toggle-fullscreen"):r.classList.remove("toggle-fullscreen"),dt(),j.dispatchEvent({type:"change",name:"fullscreen"})}function st(t){null!==z.terrain&&(N.setShadingMode(t,wt),wt(),N.isTiled&&N.zoomCheck(_))}function at(t){t.isLoaded&&(N=t,N.setup(v,y,z),N.isTiled&&(N.addEventListener("progress",mt),N.watch(j))),St(),pt(!0)}function ht(){const t=_.activeCamera;G.setFromQuaternion(t.getWorldQuaternion(V)),b.setRotation(G),wt()}function ct(t){z.setShadingMode(t,D)===s?(A=R,R=2,P=z.pointTargets):R=A,wt()}function ut(t){return t.isStation()?function(t){3===R?bt(t):(z.selectStation(t),S.preparePoint(z.getWorldPosition(t.clone())))}(t):function(t){z.selectSection(t),S.cancel(),S.prepare(z.selection.getWorldBoundingBox()),z.selection.isEmpty()&&S.start(B)}(t),void wt()}function dt(){const t=r.clientWidth,e=r.clientHeight;v.setSize(t,e),j.dispatchEvent({type:"resized",name:"rts",width:t,height:e}),wt()}function pt(t){B=!0,null===q?j.setView(XM,d.value("view",{})):(j.setView(q),q=null),t&&j.dispatchEvent({type:"newCave",name:"newCave"})}function ft(t){B=!1,z=t,Q.getProgressDial(1).watch(z),O=j.getLegStats(1),St(),g.flushCache(),y.addStatic(z),P=z.pointTargets,y.matrixAutoUpdate=!1,r.addEventListener("mousedown",Mt,!1),w.enabled=!0,z.getRoutes().addEventListener("changed",gt),z.addEventListener("changed",gt),L=!0;let e=z.terrain;null!==e?at(e):navigator.onLine?(e=new zM(f,z,at),Q.getProgressDial(0).watch(e),pt(!1)):pt(!0)}function mt(t){"end"===t.name&&wt()}function gt(){ct(z.caveShading)}function vt(t){if(null!==k)return;const e=N?t.z-N.getHeight(t):null;k=new mM(f,t,z,e,T.station,z.caveShading===s,j.warnings),z.add(k),wt()}function xt(){null!==k&&(k.close(),k=null)}function yt(){r.removeEventListener("mouseup",yt),X&&X(),wt(),j.dispatchEvent(C)}function _t(t){t.filterConnected&&(D=!0,ct(z.caveShading),wt(),D=!1)}function Mt(t){if(t.target!==v.domElement)return;const e=_.getMouse(t.clientX,t.clientY);if(M.setFromCamera(e,_.activeCamera),r.addEventListener("mouseup",yt),j.entrances){const e=M.intersectObjects(z.entrances.labels,!1)[0];if(void 0!==e){const n=z.surveyTree.findById(e.object.stationID),i={type:"entrance",displayName:e.name,station:new vM(z,n),filterConnected:!1,handled:!1,mouseEvent:t};return j.dispatchEvent(i),_t(i),void(i.handled||o(n))}}const n=M.intersectObjects(P,!1)[0];var s,a;if(void 0!==n)switch(R){case 0:o(n.station);break;case 1:a=n,z.getRoutes().toggleSegment(a.index),ct(i),wt();break;case 2:s=n.station,t.button===p?(z.showShortestPath(s),l(s)):t.button===m&&(z.shortestPathSearch(s),j.dispatchEvent({type:"change",name:"shadingMode"}),wt());break;case 3:t.button===p&&(n.station?bt(n.station):function(t){const e=z.dyeTraces,n=t.faceIndex;z.markers.clear(),e.outlineTrace(n),j.dispatchEvent({type:"selectedTrace",trace:e.getTraceStations(n),delete:function(){e.deleteTrace(n),wt()}}),wt()}(n))}else!function(t){const e=z.features.get(1),n=M.intersectObject(e,!1)[0];let i=null;if(n){i=n.faceIndex;const s=e.getLegStations(i),a={type:"leg",leg:new gM(new vM(z,s.start),new vM(z,s.start)),handled:!1,highlight:!1,mouseEvent:t};j.dispatchEvent(a),a.highlight&&(X=r,r(),wt()),i=null}function r(){z.topology.legsObject.setHighlightLeg(i),ct(z.caveShading)}}(t);function o(e){z.selectStation(e);const n={type:"station",node:new vM(z,e),handled:!1,mouseEvent:t,filterConnected:!1};j.dispatchEvent(n),_t(n),n.handled||(t.button===p?l(e):t.button===m&&function(e){z.selection.contains(e.id)||z.selectSection(z.surveyTree);ut(e),S.start(!0),t.stopPropagation(),X=null}(e))}function l(t){vt(t),X=xt,S.preparePoint(z.getWorldPosition(t.clone()))}}function bt(t){const e=z.dyeTraces,n=z.markers;e.outlineTrace(null),3==++I&&(n.clear(),I=1),n.mark(t);const i=n.getStations();let r,s;void 0!==i[0]&&(r=i[0].getPath()),void 0!==i[1]&&(s=i[1].getPath()),j.dispatchEvent({type:"selectedTrace",start:r,end:s,add:function(){2===i.length&&(e.addTrace(i[0],i[1]),n.clear(),wt())}}),wt()}function wt(){B&&(v.clear(),L&&(z.update(_,w.target),U&&g.setFog(!0),_.activeRenderer()),U&&g.setFog(!1),Q.renderHUD())}function St(){const t=r.clientWidth,e=r.clientHeight,n=z.scaleFactor;F=z.limits;const i=z.combinedLimits.getSize(W);let s=Math.min(t/i.x,e/i.y);s===1/0&&(s=1);const a=s*n;z.setScale(s,a),Q.setScale(a)}this.renderView=wt,dt(),this.addOverlay=function(t,e){Q_.addOverlay(f,t,e)},this.addFormatters=function(t){T.station=t},this.clearView=function(){L=!1,v.clear(),Q.setVisibility(!1),f.workerPools.terminateActive(),N&&N.isTiled&&N.unwatch(j),y.remove(z),w.enabled=!1,z=null,N=null,F=null,R=0,P=[],r.removeEventListener("mousedown",Mt),_.resetCameras(),w.reset(),this.dispatchEvent({type:"clear"})},this.loadCave=function(t,e){K.reset(),K.loadFile(t,e),H=void 0!==e&&""!==e},this.loadCaves=function(t){K.reset(),K.loadFiles(t)},this.setView=function(t,e){B&&(B=!1,Object.assign(this,t,e),B=!0,wt())},this.getStation=function(t){const e=M.params.Points.threshold;M.setFromCamera(t,_.activeCamera),M.params.Points.threshold=20;const n=M.intersectObject(z.stations,!1)[0];return M.params.Points.threshold=e,void 0!==n?z.getWorldPosition(n.station.clone()):null},this.resetRenderer=nt,this.renderView=wt,this.resize=dt,this.getLegStats=function(t){return void 0!==z.getFeature(t)?z.getFeature(t).stats:{legs:0,legLength:0,minLegLength:0,maxLegLength:0}},this.getMetadata=function(){return z.metadata},this.getGLTFExport=function(t,e,n){new QM(f,z,t,e,n)},this.getSurveyTree=function(){return z.surveyTree},this.showImagePopup=function(t,e){!function(t,e){null===k&&(k=new xM(f,t,e,wt),z.add(k),wt())}(t.node,e),X=xt},this.getSnapshot=function(t,e){return new KM(f,v).getSnapshot(t,e)},this.dispose=function(){f.workerPools.dispose(),y.remove(z),w.dispose(),Q.dispose(),f.glyphStringCache=null,f.cfg=null,f.workerPools=null,f.materials=null,f.container=null,window.removeEventListener("resize",dt),r.removeChild(v.domElement),r.removeEventListener("mouseover",Z),r.removeEventListener("mouseleave",J),r.removeEventListener("mousedown",Mt),r.removeEventListener("fullscreenchange",rt),r.removeEventListener("webkitfullscreenchange",rt),v.clear(),v.dispose(),v=null}}},t.FACE_SCRAPS=o,t.FACE_WALLS=a,t.FEATURE_BOX=4,t.FEATURE_ENTRANCES=6,t.FEATURE_ENTRANCE_DOTS=17,t.FEATURE_GRID=c,t.FEATURE_SELECTED_BOX=5,t.FEATURE_STATIONS=8,t.FEATURE_SURVEY=0,t.FEATURE_TERRAIN=7,t.FEATURE_TRACES=9,t.LABEL_STATION=l,t.LABEL_STATION_COMMENT=h,t.LEG_CAVE=1,t.LEG_DUPLICATE=u,t.LEG_SPLAY=2,t.LEG_SURFACE=3,t.MOUSE_MODE_DISTANCE=2,t.MOUSE_MODE_ENTRANCES=4,t.MOUSE_MODE_NORMAL=0,t.MOUSE_MODE_ROUTE_EDIT=1,t.MOUSE_MODE_TRACE_EDIT=3,t.SHADING_CONTOURS=15,t.SHADING_CURSOR=4,t.SHADING_DEPTH=9,t.SHADING_DEPTH_CURSOR=r,t.SHADING_DISTANCE=s,t.SHADING_DUPLICATE=18,t.SHADING_HEIGHT=1,t.SHADING_INCLINATION=3,t.SHADING_LENGTH=2,t.SHADING_OVERLAY=7,t.SHADING_PATH=i,t.SHADING_RELIEF=8,t.SHADING_SHADED=8,t.SHADING_SINGLE=5,t.SHADING_SURFACE=17,t.SHADING_SURVEY=6,t.STATION_ENTRANCE=2,t.STATION_NORMAL=1,t.STATION_XSECT=4,t.SURVEY_WARNINGS=14,t.TERRAIN_BASIC=0,t.TERRAIN_BLEND=2,t.TERRAIN_STENCIL=1,t.VERSION=e,t.VIEW_ELEVATION_E=4,t.VIEW_ELEVATION_N=2,t.VIEW_ELEVATION_S=3,t.VIEW_ELEVATION_W=5,t.VIEW_NONE=0,t.VIEW_PLAN=1,t.WALL_DIAMOND=3,t.WALL_OVAL=1,t.WALL_SQUARE=2,Object.defineProperty(t,"__esModule",{value:!0})}));
